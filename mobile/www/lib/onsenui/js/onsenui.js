/*! onsenui v2.0.0-rc.13 - 2016-06-21 */
/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/


/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
window.animit = (function(){
  'use strict';

  var TIMEOUT_RATIO = 1.4;

  var util = {
  };

  // capitalize string
  util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
  * @param {Object} params
  * @param {String} params.property
  * @param {Float} params.duration
  * @param {String} params.timing
  */
  util.buildTransitionValue = function(params) {
    params.property = params.property || 'all';
    params.duration = params.duration || 0.4;
    params.timing = params.timing || 'linear';

    var props = params.property.split(/ +/);

    return props.map(function(prop) {
      return prop + ' ' + params.duration + 's ' + params.timing;
    }).join(', ');
  };

  /**
  * Add an event handler on "transitionend" event.
  */
  util.onceOnTransitionEnd = function(element, callback) {
    if (!element) {
      return function() {};
    }

    var fn = function(event) {
      if (element == event.target) {
        event.stopPropagation();
        removeListeners();

        callback();
      }
    };

    var removeListeners = function() {
      util._transitionEndEvents.forEach(function(eventName) {
        element.removeEventListener(eventName, fn, false);
      });
    };

    util._transitionEndEvents.forEach(function(eventName) {
      element.addEventListener(eventName, fn, false);
    });

    return removeListeners;
  };

  util._transitionEndEvents = (function() {

    if ('ontransitionend' in window) {
      return ['transitionend'];
    }

    if ('onwebkittransitionend' in window) {
      return ['webkitTransitionEnd'];
    }

    if (util.vendorPrefix === 'webkit' || util.vendorPrefix === 'o' || util.vendorPrefix === 'moz' || util.vendorPrefix === 'ms') {
      return [util.vendorPrefix + 'TransitionEnd', 'transitionend'];
    }

    return [];
  })();

  util._cssPropertyDict = (function() {
    var styles = window.getComputedStyle(document.documentElement, '');
    var dict = {};
    var a = 'A'.charCodeAt(0);
    var z = 'z'.charCodeAt(0);

    var upper = function(s) {
      return s.substr(1).toUpperCase();
    };

    for (var i = 0; i < styles.length; i++) {

      var key = styles[i]
        .replace(/^[\-]+/, '')
        .replace(/[\-][a-z]/g, upper)
        .replace(/^moz/, 'Moz');

      if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
        if (key !== 'cssText' && key !== 'parentText') {
          dict[key] = true;
        }
      }
    }

    return dict;
  })();

  util.hasCssProperty = function(name) {
    return name in util._cssPropertyDict;
  };

  /**
   * Vendor prefix for css property.
   */
  util.vendorPrefix = (function() {
    var styles = window.getComputedStyle(document.documentElement, ''),
    pre = (Array.prototype.slice
      .call(styles)
      .join('')
      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
    )[1];
    return pre;
  })();

  util.forceLayoutAtOnce = function(elements, callback) {
    this.batchImmediate(function() {
      elements.forEach(function(element) {
        // force layout
        element.offsetHeight;
      });
      callback();
    });
  };

  util.batchImmediate = (function() {
    var callbacks = [];

    return function(callback) {
      if (callbacks.length === 0) {
        setImmediate(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.batchAnimationFrame = (function() {
    var callbacks = [];

    var raf = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      setTimeout(callback, 1000 / 60);
    };

    return function(callback) {
      if (callbacks.length === 0) {
        raf(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.transitionPropertyName = (function() {
    if (util.hasCssProperty('transitionDuration')) {
      return 'transition';
    }

    if (util.hasCssProperty(util.vendorPrefix + 'TransitionDuration')) {
      return util.vendorPrefix + 'Transition';
    }

    throw new Error('Invalid state');
  })();


  /**
   * @param {HTMLElement} element
   */
  var Animit = function(element) {
    if (!(this instanceof Animit)) {
      return new Animit(element);
    }

    if (element instanceof HTMLElement) {
      this.elements = [element];
    } else if (Object.prototype.toString.call(element) === '[object Array]') {
      this.elements = element;

    } else {
      throw new Error('First argument must be an array or an instance of HTMLElement.');
    }

    this.transitionQueue = [];
    this.lastStyleAttributeDict = [];
  };

  Animit.prototype = {

    /**
     * @property {Array}
     */
    transitionQueue: undefined,

    /**
     * @property {Array}
     */
    elements: undefined,

    /**
     * Start animation sequence with passed animations.
     *
     * @param {Function} callback
     */
    play: function(callback) {
      if (typeof callback === 'function') {
        this.transitionQueue.push(function(done) {
          callback();
          done();
        });
      }

      this.startAnimation();

      return this;
    },

    /**
     * Queue transition animations or other function.
     *
     * e.g. animit(elt).queue({color: 'red'})
     * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
     * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
     *
     * @param {Object|Animit.Transition|Function} transition
     * @param {Object} [options]
     */
    queue: function(transition, options) {
      var queue = this.transitionQueue;

      if (transition && options) {
        options.css = transition;
        transition = new Animit.Transition(options);
      }

      if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
        if (transition.css) {
          transition = new Animit.Transition(transition);
        } else {
          transition = new Animit.Transition({
            css: transition
          });
        }
      }

      if (transition instanceof Function) {
        queue.push(transition);
      } else if (transition instanceof Animit.Transition) {
        queue.push(transition.build());
      } else {
        throw new Error('Invalid arguments');
      }

      return this;
    },

    /**
     * Queue transition animations.
     *
     * @param {Float} seconds
     */
    wait: function(seconds) {
      if (seconds > 0) {
        this.transitionQueue.push(function(done) {
          setTimeout(done, 1000 * seconds);
        });
      }

      return this;
    },

    saveStyle: function() {

      this.transitionQueue.push(function(done) {
        this.elements.forEach(function(element, index) {
          var css = this.lastStyleAttributeDict[index] = {};

          for (var i = 0; i < element.style.length; i++) {
            css[element.style[i]] = element.style[element.style[i]];
          }
        }.bind(this));
        done();
      }.bind(this));

      return this;
    },

    /**
     * Restore element's style.
     *
     * @param {Object} [options]
     * @param {Float} [options.duration]
     * @param {String} [options.timing]
     * @param {String} [options.transition]
     */
    restoreStyle: function(options) {
      options = options || {};
      var self = this;

      if (options.transition && !options.duration) {
        throw new Error('"options.duration" is required when "options.transition" is enabled.');
      }

      var transitionName = util.transitionPropertyName;

      if (options.transition || (options.duration && options.duration > 0)) {
        var transitionValue = options.transition || ('all ' + options.duration + 's ' + (options.timing || 'linear'));

        this.transitionQueue.push(function(done) {
          var elements = this.elements;
          var timeoutId;

          var clearTransition = function() {
            elements.forEach(function(element) {
              element.style[transitionName] = '';
            });
          };

          // add "transitionend" event handler
          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            clearTransition();
            done();
          });

          // for fail safe.
          timeoutId = setTimeout(function() {
            removeListeners();
            clearTransition();
            done();
          }, options.duration * 1000 * TIMEOUT_RATIO);

          // transition and style settings
          elements.forEach(function(element, index) {

            var css = self.lastStyleAttributeDict[index];

            if (!css) {
              throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
            }

            self.lastStyleAttributeDict[index] = undefined;

            var name;
            for (var i = 0, len = element.style.length; i < len; i++) {
              name = element.style[i];
              if (css[name] === undefined) {
                css[name] = '';
              }
            }

            element.style[transitionName] = transitionValue;

            Object.keys(css).forEach(function(key) {
              if (key !== transitionName) {
                element.style[key] = css[key];
              }
            });

            element.style[transitionName] = transitionValue;
          });
        });
      } else {
        this.transitionQueue.push(function(done) {
          reset();
          done();
        });
      }

      return this;

      function reset() {
        // Clear transition animation settings.
        self.elements.forEach(function(element, index) {
          element.style[transitionName] = 'none';

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          for (var i = 0, name = ''; i < element.style.length; i++) {
            name = element.style[i];
            if (typeof css[element.style[i]] === 'undefined') {
              css[element.style[i]] = '';
            }
          }

          Object.keys(css).forEach(function(key) {
            element.style[key] = css[key];
          });

        });
      }
    },

    /**
     * Start animation sequence.
     */
    startAnimation: function() {
      this._dequeueTransition();

      return this;
    },

    _dequeueTransition: function() {
      var transition = this.transitionQueue.shift();
      if (this._currentTransition) {
        throw new Error('Current transition exists.');
      }
      this._currentTransition = transition;
      var self = this;
      var called = false;

      var done = function() {
        if (!called) {
          called = true;
          self._currentTransition = undefined;
          self._dequeueTransition();
        } else {
          throw new Error('Invalid state: This callback is called twice.');
        }
      };

      if (transition) {
        transition.call(this, done);
      }
    }

  };

  /**
   * @param {Animit} arguments
   */
  Animit.runAll = function(/* arguments... */) {
    for (var i = 0; i < arguments.length; i++) {
      arguments[i].play();
    }
  };


  /**
   * @param {Object} options
   * @param {Float} [options.duration]
   * @param {String} [options.property]
   * @param {String} [options.timing]
   */
  Animit.Transition = function(options) {
    this.options = options || {};
    this.options.duration = this.options.duration || 0;
    this.options.timing = this.options.timing || 'linear';
    this.options.css = this.options.css || {};
    this.options.property = this.options.property || 'all';
  };

  Animit.Transition.prototype = {

    /**
     * @param {HTMLElement} element
     * @return {Function}
     */
    build: function() {

      if (Object.keys(this.options.css).length === 0) {
        throw new Error('options.css is required.');
      }

      var css = createActualCssProps(this.options.css);

      if (this.options.duration > 0) {
        var transitionValue = util.buildTransitionValue(this.options);
        var self = this;

        return function(callback) {
          var elements = this.elements;
          var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
          var timeoutId;

          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            callback();
          });

          timeoutId = setTimeout(function() {
            removeListeners();
            callback();
          }, timeout);

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = transitionValue;

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

        };
      }

      if (this.options.duration <= 0) {
        return function(callback) {
          var elements = this.elements;

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = '';

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

          if (elements.length > 0) {
            util.forceLayoutAtOnce(elements, function() {
              util.batchAnimationFrame(callback);
            });
          } else {
            util.batchAnimationFrame(callback);
          }
        };
      }

      function createActualCssProps(css) {
        var result = {};

        Object.keys(css).forEach(function(name) {
          var value = css[name];

          if (util.hasCssProperty(name)) {
            result[name] = value;
            return;
          }

          var prefixed = util.vendorPrefix + util.capitalize(name);
          if (util.hasCssProperty(prefixed)) {
            result[prefixed] = value;
          } else {
            result[prefixed] = value;
            result[name] = value;
          }
        });

        return result;
      }

    }
  };


  return Animit;
})();

/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.3
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(this);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);
})(window.CustomElements);

window.CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : "none";
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e && e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  function forDocumentTree(doc, cb) {
    _forDocumentTree(doc, cb, []);
  }
  function _forDocumentTree(doc, cb, processingDocuments) {
    doc = wrap(doc);
    if (processingDocuments.indexOf(doc) >= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb, processingDocuments);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node) {
    return added(node) || addedSubtree(node);
  }
  function added(node) {
    if (scope.upgrade(node)) {
      return true;
    }
    attached(node);
  }
  function addedSubtree(node) {
    forSubtree(node, function(e) {
      if (added(e)) {
        return true;
      }
    });
  }
  function attachedNode(node) {
    attached(node);
    if (inDocument(node)) {
      forSubtree(node, function(e) {
        attached(e);
      });
    }
  }
  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
  scope.hasPolyfillMutations = hasPolyfillMutations;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (!element.__attached && inDocument(element)) {
        element.__attached = true;
        if (element.attachedCallback) {
          element.attachedCallback();
        }
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (element.__attached && !inDocument(element)) {
        element.__attached = false;
        if (element.detachedCallback) {
          element.detachedCallback();
        }
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot && !node.shadowRoot.__watched) {
      flags.dom && console.log("watching shadow-root for: ", node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx && mx.type === "childList" && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
          u = u.split("/?").shift().split("/").pop();
        }
      }
      console.group("mutations (%d) [%s]", mutations.length, u || "");
    }
    mutations.forEach(function(mx) {
      if (mx.type === "childList") {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom && console.groupEnd();
  }
  function takeRecords(node) {
    node = wrap(node);
    if (!node) {
      node = wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler);
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = wrap(doc);
    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
    addedNode(doc);
    observe(doc);
    flags.dom && console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attachedNode = attachedNode;
  scope.takeRecords = takeRecords;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node) {
    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute("is");
      var definition = scope.getRegisteredDefinition(is || node.localName);
      if (definition) {
        if (is && definition.tag == node.localName) {
          return upgradeWithDefinition(node, definition);
        } else if (!is && !definition.extends) {
          return upgradeWithDefinition(node, definition);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition) {
    flags.upgrade && console.group("upgrade:", element.localName);
    if (definition.is) {
      element.setAttribute("is", definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    scope.attachedNode(element);
    scope.upgradeSubtree(element);
    flags.upgrade && console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

window.CustomElements.addModule(function(scope) {
  var isIE11OrOlder = scope.isIE11OrOlder;
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeAll = scope.upgradeAll;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error("document.registerElement: first argument `name` must not be empty");
    }
    if (name.indexOf("-") < 0) {
      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
    }
    if (isReservedTag(name)) {
      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
    }
    if (getRegisteredDefinition(name)) {
      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback && newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is && a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        var expectedPrototype = Object.getPrototypeOf(inst);
        if (expectedPrototype === definition.prototype) {
          nativePrototype = expectedPrototype;
        }
      }
      var proto = definition.prototype, ancestor;
      while (proto && proto !== nativePrototype) {
        ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    if (tag) {
      tag = tag.toLowerCase();
    }
    if (typeExtension) {
      typeExtension = typeExtension.toLowerCase();
    }
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute("is", typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf("-") >= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var isInstance;
  if (!Object.__proto__ && !useNative) {
    isInstance = function(obj, ctor) {
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  function wrapDomMethodToForceUpgrade(obj, methodName) {
    var orig = obj[methodName];
    obj[methodName] = function() {
      var n = orig.apply(this, arguments);
      upgradeAll(n);
      return n;
    };
  }
  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
  wrapDomMethodToForceUpgrade(document, "importNode");
  if (isIE11OrOlder) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE11OrOlder = /Trident/.test(navigator.userAgent);
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  function bootstrap() {
    upgradeDocumentTree(wrap(document));
    if (window.HTMLImports) {
      HTMLImports.__importsParsingHook = function(elt) {
        upgradeDocumentTree(wrap(elt.import));
      };
    }
    CustomElements.ready = true;
    setTimeout(function() {
      CustomElements.readyTime = Date.now();
      if (window.HTMLImports) {
        CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
      }
      document.dispatchEvent(new CustomEvent("WebComponentsReady", {
        bubbles: true
      }));
    });
  }
  if (isIE11OrOlder && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (document.readyState === "complete" || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
    window.addEventListener(loadEvent, bootstrap);
  }
  scope.isIE11OrOlder = isIE11OrOlder;
})(window.CustomElements);

if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
!function n(t,e,r){function o(u,f){if(!e[u]){if(!t[u]){var c="function"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var s=new Error("Cannot find module '"+u+"'");throw s.code="MODULE_NOT_FOUND",s}var l=e[u]={exports:{}};t[u][0].call(l.exports,function(n){var e=t[u][1][n];return o(e?e:n)},l,l.exports,n,t,e,r)}return e[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)o(r[u]);return o}({1:[function(n,t,e){"use strict";function r(){}function o(n){try{return n.then}catch(t){return d=t,w}}function i(n,t){try{return n(t)}catch(e){return d=e,w}}function u(n,t,e){try{n(t,e)}catch(r){return d=r,w}}function f(n){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof n)throw new TypeError("not a function");this._37=0,this._12=null,this._59=[],n!==r&&v(n,this)}function c(n,t,e){return new n.constructor(function(o,i){var u=new f(r);u.then(o,i),s(n,new p(t,e,u))})}function s(n,t){for(;3===n._37;)n=n._12;return 0===n._37?void n._59.push(t):void y(function(){var e=1===n._37?t.onFulfilled:t.onRejected;if(null===e)return void(1===n._37?l(t.promise,n._12):a(t.promise,n._12));var r=i(e,n._12);r===w?a(t.promise,d):l(t.promise,r)})}function l(n,t){if(t===n)return a(n,new TypeError("A promise cannot be resolved with itself."));if(t&&("object"==typeof t||"function"==typeof t)){var e=o(t);if(e===w)return a(n,d);if(e===n.then&&t instanceof f)return n._37=3,n._12=t,void h(n);if("function"==typeof e)return void v(e.bind(t),n)}n._37=1,n._12=t,h(n)}function a(n,t){n._37=2,n._12=t,h(n)}function h(n){for(var t=0;t<n._59.length;t++)s(n,n._59[t]);n._59=null}function p(n,t,e){this.onFulfilled="function"==typeof n?n:null,this.onRejected="function"==typeof t?t:null,this.promise=e}function v(n,t){var e=!1,r=u(n,function(n){e||(e=!0,l(t,n))},function(n){e||(e=!0,a(t,n))});e||r!==w||(e=!0,a(t,d))}var y=n("asap/raw"),d=null,w={};t.exports=f,f._99=r,f.prototype.then=function(n,t){if(this.constructor!==f)return c(this,n,t);var e=new f(r);return s(this,new p(n,t,e)),e}},{"asap/raw":4}],2:[function(n,t,e){"use strict";function r(n){var t=new o(o._99);return t._37=1,t._12=n,t}var o=n("./core.js");t.exports=o;var i=r(!0),u=r(!1),f=r(null),c=r(void 0),s=r(0),l=r("");o.resolve=function(n){if(n instanceof o)return n;if(null===n)return f;if(void 0===n)return c;if(n===!0)return i;if(n===!1)return u;if(0===n)return s;if(""===n)return l;if("object"==typeof n||"function"==typeof n)try{var t=n.then;if("function"==typeof t)return new o(t.bind(n))}catch(e){return new o(function(n,t){t(e)})}return r(n)},o.all=function(n){var t=Array.prototype.slice.call(n);return new o(function(n,e){function r(u,f){if(f&&("object"==typeof f||"function"==typeof f)){if(f instanceof o&&f.then===o.prototype.then){for(;3===f._37;)f=f._12;return 1===f._37?r(u,f._12):(2===f._37&&e(f._12),void f.then(function(n){r(u,n)},e))}var c=f.then;if("function"==typeof c){var s=new o(c.bind(f));return void s.then(function(n){r(u,n)},e)}}t[u]=f,0===--i&&n(t)}if(0===t.length)return n([]);for(var i=t.length,u=0;u<t.length;u++)r(u,t[u])})},o.reject=function(n){return new o(function(t,e){e(n)})},o.race=function(n){return new o(function(t,e){n.forEach(function(n){o.resolve(n).then(t,e)})})},o.prototype["catch"]=function(n){return this.then(null,n)}},{"./core.js":1}],3:[function(n,t,e){"use strict";function r(){if(c.length)throw c.shift()}function o(n){var t;t=f.length?f.pop():new i,t.task=n,u(t)}function i(){this.task=null}var u=n("./raw"),f=[],c=[],s=u.makeRequestCallFromTimer(r);t.exports=o,i.prototype.call=function(){try{this.task.call()}catch(n){o.onerror?o.onerror(n):(c.push(n),s())}finally{this.task=null,f[f.length]=this}}},{"./raw":4}],4:[function(n,t,e){(function(n){"use strict";function e(n){f.length||(u(),c=!0),f[f.length]=n}function r(){for(;s<f.length;){var n=s;if(s+=1,f[n].call(),s>l){for(var t=0,e=f.length-s;e>t;t++)f[t]=f[t+s];f.length-=s,s=0}}f.length=0,s=0,c=!1}function o(n){var t=1,e=new a(n),r=document.createTextNode("");return e.observe(r,{characterData:!0}),function(){t=-t,r.data=t}}function i(n){return function(){function t(){clearTimeout(e),clearInterval(r),n()}var e=setTimeout(t,0),r=setInterval(t,50)}}t.exports=e;var u,f=[],c=!1,s=0,l=1024,a=n.MutationObserver||n.WebKitMutationObserver;u="function"==typeof a?o(r):i(r),e.requestFlush=u,e.makeRequestCallFromTimer=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],5:[function(n,t,e){"function"!=typeof Promise.prototype.done&&(Promise.prototype.done=function(n,t){var e=arguments.length?this.then.apply(this,arguments):this;e.then(null,function(n){setTimeout(function(){throw n},0)})})},{}],6:[function(n,t,e){n("asap");"undefined"==typeof Promise&&(Promise=n("./lib/core.js"),n("./lib/es6-extensions.js")),n("./polyfill-done.js")},{"./lib/core.js":1,"./lib/es6-extensions.js":2,"./polyfill-done.js":5,asap:3}]},{},[6]);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   (global.ons = factory());
}(this, function () { 'use strict';

   var babelHelpers = {};
   babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
     return typeof obj;
   } : function (obj) {
     return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
   };

   babelHelpers.classCallCheck = function (instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   };

   babelHelpers.createClass = function () {
     function defineProperties(target, props) {
       for (var i = 0; i < props.length; i++) {
         var descriptor = props[i];
         descriptor.enumerable = descriptor.enumerable || false;
         descriptor.configurable = true;
         if ("value" in descriptor) descriptor.writable = true;
         Object.defineProperty(target, descriptor.key, descriptor);
       }
     }

     return function (Constructor, protoProps, staticProps) {
       if (protoProps) defineProperties(Constructor.prototype, protoProps);
       if (staticProps) defineProperties(Constructor, staticProps);
       return Constructor;
     };
   }();

   babelHelpers.inherits = function (subClass, superClass) {
     if (typeof superClass !== "function" && superClass !== null) {
       throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
     }

     subClass.prototype = Object.create(superClass && superClass.prototype, {
       constructor: {
         value: subClass,
         enumerable: false,
         writable: true,
         configurable: true
       }
     });
     if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
   };

   babelHelpers.possibleConstructorReturn = function (self, call) {
     if (!self) {
       throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
     }

     return call && (typeof call === "object" || typeof call === "function") ? call : self;
   };

   babelHelpers;

   var unwrap = function unwrap(string) {
     return string.slice(1, -1);
   };
   var isObjectString = function isObjectString(string) {
     return string.startsWith('{') && string.endsWith('}');
   };
   var isArrayString = function isArrayString(string) {
     return string.startsWith('[') && string.endsWith(']');
   };
   var isQuotedString = function isQuotedString(string) {
     return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
   };

   var error = function error(token, string, originalString) {
     throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
   };

   var processToken = function processToken(token, string, originalString) {
     if (token === 'true' || token === 'false') {
       return token === 'true';
     } else if (isQuotedString(token)) {
       return unwrap(token);
     } else if (!isNaN(token)) {
       return +token;
     } else if (isObjectString(token)) {
       return parseObject(unwrap(token));
     } else if (isArrayString(token)) {
       return parseArray(unwrap(token));
     } else {
       error(token, string, originalString);
     }
   };

   var nextToken = function nextToken(string) {
     string = string.trimLeft();
     var limit = string.length;

     if (string[0] === ':' || string[0] === ',') {

       limit = 1;
     } else if (string[0] === '{' || string[0] === '[') {

       var c = string.charCodeAt(0);
       var nestedObject = 1;
       for (var i = 1; i < string.length; i++) {
         if (string.charCodeAt(i) === c) {
           nestedObject++;
         } else if (string.charCodeAt(i) === c + 2) {
           nestedObject--;
           if (nestedObject === 0) {
             limit = i + 1;
             break;
           }
         }
       }
     } else if (string[0] === '\'' || string[0] === '\"') {

       for (var _i = 1; _i < string.length; _i++) {
         if (string[_i] === string[0]) {
           limit = _i + 1;
           break;
         }
       }
     } else {

       for (var _i2 = 1; _i2 < string.length; _i2++) {
         if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
           limit = _i2;
           break;
         }
       }
     }

     return string.slice(0, limit);
   };

   var parseObject = function parseObject(string) {
     var isValidKey = function isValidKey(key) {
       return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
       );
     };

     string = string.trim();
     var originalString = string;
     var object = {};
     var readingKey = true,
         key = void 0,
         previousToken = void 0,
         token = void 0;

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
         error(token, string, originalString);
       } else if (token === ':' && readingKey && previousToken) {
         if (isValidKey(previousToken)) {
           key = previousToken;
           readingKey = false;
         } else {
           throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
         }
       } else if (token === ',' && !readingKey && previousToken) {
         object[key] = processToken(previousToken, string, originalString);
         readingKey = true;
       }
     }

     if (token) {
       object[key] = processToken(token, string, originalString);
     }

     return object;
   };

   var parseArray = function parseArray(string) {
     string = string.trim();
     var originalString = string;
     var array = [];
     var previousToken = void 0,
         token = void 0;

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ',' && (!previousToken || previousToken === ',')) {
         error(token, string, originalString);
       } else if (token === ',') {
         array.push(processToken(previousToken, string, originalString));
       }
     }

     if (token) {
       if (token !== ',') {
         array.push(processToken(token, string, originalString));
       } else {
         error(token, string, originalString);
       }
     }

     return array;
   };

   var parse = function parse(string) {
     string = string.trim();

     if (isObjectString(string)) {
       return parseObject(unwrap(string));
     } else if (isArrayString(string)) {
       return parseArray(unwrap(string));
     } else {
       throw new Error('Provided string must be object or array like: ' + string);
     }
   };

   var util = {};

   /**
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {Function}
    */
   util.prepareQuery = function (query) {
     return query instanceof Function ? query : function (element) {
       return util.match(element, query);
     };
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name.
    * @return {Boolean}
    */
   util.match = function (element, query) {
     if (query[0] === '.') {
       return element.classList.contains(query.slice(1));
     }
     return element.nodeName.toLowerCase() === query;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findChild = function (element, query) {
     var match = util.prepareQuery(query);

     for (var i = 0; i < element.children.length; i++) {
       var node = element.children[i];
       if (match(node)) {
         return node;
       }
     }
     return null;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findParent = function (element, query) {
     var match = util.prepareQuery(query);

     var parent = element.parentNode;
     for (;;) {
       if (!parent || parent === document) {
         return null;
       }
       if (match(parent)) {
         return parent;
       }
       parent = parent.parentNode;
     }
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.isAttached = function (element) {
     while (document.documentElement !== element) {
       if (!element) {
         return false;
       }
       element = element.parentNode;
     }
     return true;
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.hasAnyComponentAsParent = function (element) {
     while (element && document.documentElement !== element) {
       element = element.parentNode;
       if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-sliding-menu|ons-split-view)/)) {
         return true;
       }
     }
     return false;
   };

   /**
    * @param {Element} element
    * @param {String} action to propagate
    */
   util.propagateAction = function (element, action) {
     for (var i = 0; i < element.childNodes.length; i++) {
       var child = element.childNodes[i];
       if (child[action] instanceof Function) {
         child[action]();
       } else {
         util.propagateAction(child, action);
       }
     }
   };

   /**
    * @param {String} selector - tag and class only
    * @param {Object} style
    * @param {Element}
    */
   util.create = function () {
     var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
     var style = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     var classList = selector.split('.');
     var element = document.createElement(classList.shift() || 'div');

     if (classList.length) {
       element.className = classList.join(' ');
     }

     util.extend(element.style, style);

     return element;
   };

   /**
    * @param {String} html
    * @return {Element}
    */
   util.createElement = function (html) {
     var wrapper = document.createElement('div');
     wrapper.innerHTML = html;

     if (wrapper.children.length > 1) {
       throw new Error('"html" must be one wrapper element.');
     }

     return wrapper.children[0];
   };

   /**
    * @param {String} html
    * @return {HTMLFragment}
    */
   util.createFragment = function (html) {
     var wrapper = document.createElement('div');
     wrapper.innerHTML = html;
     var fragment = document.createDocumentFragment();

     while (wrapper.firstChild) {
       fragment.appendChild(wrapper.firstChild);
     }

     return fragment;
   };

   /*
    * @param {Object} dst Destination object.
    * @param {...Object} src Source object(s).
    * @returns {Object} Reference to `dst`.
    */
   util.extend = function (dst) {
     for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
       args[_key - 1] = arguments[_key];
     }

     for (var i = 0; i < args.length; i++) {
       if (args[i]) {
         var keys = Object.keys(args[i]);
         for (var j = 0; j < keys.length; j++) {
           var key = keys[j];
           dst[key] = args[i][key];
         }
       }
     }

     return dst;
   };

   /**
    * @param {Object} arrayLike
    * @return {Array}
    */
   util.arrayFrom = function (arrayLike) {
     return Array.prototype.slice.apply(arrayLike);
   };

   /**
    * @param {String} jsonString
    * @param {Object} [failSafe]
    * @return {Object}
    */
   util.parseJSONObjectSafely = function (jsonString) {
     var failSafe = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     try {
       var result = JSON.parse('' + jsonString);
       if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
         return result;
       }
     } catch (e) {
       return failSafe;
     }
     return failSafe;
   };

   /**
    * @param {String} path - path such as 'myApp.controllers.data.loadData'
    * @return {Any} - whatever is located at that path
    */
   util.findFromPath = function (path) {
     path = path.split('.');
     var el = window,
         key;
     while (key = path.shift()) {
       // eslint-disable-line no-cond-assign
       el = el[key];
     }
     return el;
   };

   /**
    * @param {Element} element
    * @param {String} eventName
    * @param {Object} [detail]
    * @return {CustomEvent}
    */
   util.triggerElementEvent = function (target, eventName) {
     var detail = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];


     var event = new CustomEvent(eventName, {
       bubbles: true,
       cancelable: true,
       detail: detail
     });

     Object.keys(detail).forEach(function (key) {
       event[key] = detail[key];
     });

     target.dispatchEvent(event);

     return event;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean}
    */
   util.hasModifier = function (target, modifierName) {
     if (!target.hasAttribute('modifier')) {
       return false;
     }
     return target.getAttribute('modifier').split(/\s+/).some(function (e) {
       return e === modifierName;
     });
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was added or not.
    */
   util.addModifier = function (target, modifierName) {
     if (util.hasModifier(target, modifierName)) {
       return false;
     }

     modifierName = modifierName.trim();
     var modifierAttribute = target.getAttribute('modifier') || '';
     target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
     return true;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was found or not.
    */
   util.removeModifier = function (target, modifierName) {
     if (!target.getAttribute('modifier')) {
       return false;
     }

     var modifiers = target.getAttribute('modifier').split(/\s+/);

     var newModifiers = modifiers.filter(function (item) {
       return item && item !== modifierName;
     });
     target.setAttribute('modifier', newModifiers.join(' '));

     return modifiers.length !== newModifiers.length;
   };

   util.updateParentPosition = function (el) {
     if (!el._parentUpdated && el.parentElement) {
       if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
         el.parentElement.style.position = 'relative';
       }
       el._parentUpdated = true;
     }
   };

   util.toggleAttribute = function (element, name, enable) {
     if (enable) {
       element.setAttribute(name, '');
     } else {
       element.removeAttribute(name);
     }
   };

   util.bindListeners = function (element, listenerNames) {
     listenerNames.forEach(function (name) {
       var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
       element[boundName] = element[boundName] || element[name].bind(element);
     });
   };

   util.each = function (obj, f) {
     return Object.keys(obj).forEach(function (key) {
       return f(key, obj[key]);
     });
   };

   /**
    * @param {Element} target
    */
   util.updateRipple = function (target) {
     var rippleElement = util.findChild(target, 'ons-ripple');

     if (target.hasAttribute('ripple')) {
       if (!rippleElement) {
         target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
       }
     } else if (rippleElement) {
       rippleElement.remove();
     }
   };

   /**
    * @param {String}
    * @return {Object}
    */
   util.animationOptionsParse = parse;

   /**
    * @param {*} value
    */
   util.isInteger = function (value) {
     return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
   };

   var Event$1;
   var Utils;
   var Detection;
   var PointerEvent;
   /**
    * @object ons.GestureDetector
    * @category gesture
    * @description
    *   [en]Utility class for gesture detection.[/en]
    *   [ja][/ja]
    */

   /**
    * @method constructor
    * @signature constructor(element[, options])
    * @description
    *  [en]Create a new GestureDetector instance.[/en]
    *  [ja]GestureDetector[/ja]
    * @param {Element} element
    *   [en]Name of the event.[/en]
    *   [ja]DOM[/ja]
    * @param {Object} [options]
    *   [en]Options object.[/en]
    *   [ja][/ja]
    * @return {ons.GestureDetector.Instance}
    */
   var GestureDetector = function GestureDetector(element, options) {
     return new GestureDetector.Instance(element, options || {});
   };

   /**
    * default settings.
    * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
    * by setting it's name (like `swipe`) to false.
    * You can set the defaults for all instances by changing this object before creating an instance.
    * @example
    * ````
    *  GestureDetector.defaults.drag = false;
    *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
    *  delete GestureDetector.defaults.behavior.userSelect;
    * ````
    * @property defaults
    * @type {Object}
    */
   GestureDetector.defaults = {
     behavior: {
       // userSelect: 'none', // Also disables selection in `input` children
       touchAction: 'pan-y',
       touchCallout: 'none',
       contentZooming: 'none',
       userDrag: 'none',
       tapHighlightColor: 'rgba(0,0,0,0)'
     }
   };

   /**
    * GestureDetector document where the base events are added at
    * @property DOCUMENT
    * @type {HTMLElement}
    * @default window.document
    */
   GestureDetector.DOCUMENT = document;

   /**
    * detect support for pointer events
    * @property HAS_POINTEREVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

   /**
    * detect support for touch events
    * @property HAS_TOUCHEVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

   /**
    * detect mobile browsers
    * @property IS_MOBILE
    * @type {Boolean}
    */
   GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

   /**
    * detect if we want to support mouseevents at all
    * @property NO_MOUSEEVENTS
    * @type {Boolean}
    */
   GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

   /**
    * interval in which GestureDetector recalculates current velocity/direction/angle in ms
    * @property CALCULATE_INTERVAL
    * @type {Number}
    * @default 25
    */
   GestureDetector.CALCULATE_INTERVAL = 25;

   /**
    * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
    * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
    * @property EVENT_TYPES
    * @private
    * @writeOnce
    * @type {Object}
    */
   var EVENT_TYPES = {};

   /**
    * direction strings, for safe comparisons
    * @property DIRECTION_DOWN|LEFT|UP|RIGHT
    * @final
    * @type {String}
    * @default 'down' 'left' 'up' 'right'
    */
   var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
   var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
   var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
   var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

   /**
    * pointertype strings, for safe comparisons
    * @property POINTER_MOUSE|TOUCH|PEN
    * @final
    * @type {String}
    * @default 'mouse' 'touch' 'pen'
    */
   var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
   var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
   var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

   /**
    * eventtypes
    * @property EVENT_START|MOVE|END|RELEASE|TOUCH
    * @final
    * @type {String}
    * @default 'start' 'change' 'move' 'end' 'release' 'touch'
    */
   var EVENT_START = GestureDetector.EVENT_START = 'start';
   var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
   var EVENT_END = GestureDetector.EVENT_END = 'end';
   var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
   var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

   /**
    * if the window events are set...
    * @property READY
    * @writeOnce
    * @type {Boolean}
    * @default false
    */
   GestureDetector.READY = false;

   /**
    * plugins namespace
    * @property plugins
    * @type {Object}
    */
   GestureDetector.plugins = GestureDetector.plugins || {};

   /**
    * gestures namespace
    * see `/gestures` for the definitions
    * @property gestures
    * @type {Object}
    */
   GestureDetector.gestures = GestureDetector.gestures || {};

   /**
    * setup events to detect gestures on the document
    * this function is called when creating an new instance
    * @private
    */
   function setup() {
     if (GestureDetector.READY) {
       return;
     }

     // find what eventtypes we add listeners to
     Event$1.determineEventTypes();

     // Register all gestures inside GestureDetector.gestures
     Utils.each(GestureDetector.gestures, function (gesture) {
       Detection.register(gesture);
     });

     // Add touch events on the document
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

     // GestureDetector is ready...!
     GestureDetector.READY = true;
   }

   /**
    * @module GestureDetector
    *
    * @class Utils
    * @static
    */
   Utils = GestureDetector.utils = {
     /**
      * extend method, could also be used for cloning when `dest` is an empty object.
      * changes the dest object
      * @param {Object} dest
      * @param {Object} src
      * @param {Boolean} [merge=false]  do a merge
      * @return {Object} dest
      */
     extend: function extend(dest, src, merge) {
       for (var key in src) {
         if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
           dest[key] = src[key];
         }
       }
       return dest;
     },

     /**
      * simple addEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     on: function on(element, type, handler) {
       element.addEventListener(type, handler, false);
     },

     /**
      * simple removeEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     off: function off(element, type, handler) {
       element.removeEventListener(type, handler, false);
     },

     /**
      * forEach over arrays and objects
      * @param {Object|Array} obj
      * @param {Function} iterator
      * @param {any} iterator.item
      * @param {Number} iterator.index
      * @param {Object|Array} iterator.obj the source object
      * @param {Object} context value to use as `this` in the iterator
      */
     each: function each(obj, iterator, context) {
       var i, len;

       // native forEach on arrays
       if ('forEach' in obj) {
         obj.forEach(iterator, context);
         // arrays
       } else if (obj.length !== undefined) {
           for (i = 0, len = obj.length; i < len; i++) {
             if (iterator.call(context, obj[i], i, obj) === false) {
               return;
             }
           }
           // objects
         } else {
             for (i in obj) {
               if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
                 return;
               }
             }
           }
     },

     /**
      * find if a string contains the string using indexOf
      * @param {String} src
      * @param {String} find
      * @return {Boolean} found
      */
     inStr: function inStr(src, find) {
       return src.indexOf(find) > -1;
     },

     /**
      * find if a array contains the object using indexOf or a simple polyfill
      * @param {String} src
      * @param {String} find
      * @return {Boolean|Number} false when not found, or the index
      */
     inArray: function inArray(src, find) {
       if (src.indexOf) {
         var index = src.indexOf(find);
         return index === -1 ? false : index;
       } else {
         for (var i = 0, len = src.length; i < len; i++) {
           if (src[i] === find) {
             return i;
           }
         }
         return false;
       }
     },

     /**
      * convert an array-like object (`arguments`, `touchlist`) to an array
      * @param {Object} obj
      * @return {Array}
      */
     toArray: function toArray(obj) {
       return Array.prototype.slice.call(obj, 0);
     },

     /**
      * find if a node is in the given parent
      * @param {HTMLElement} node
      * @param {HTMLElement} parent
      * @return {Boolean} found
      */
     hasParent: function hasParent(node, parent) {
       while (node) {
         if (node == parent) {
           return true;
         }
         node = node.parentNode;
       }
       return false;
     },

     /**
      * get the center of all the touches
      * @param {Array} touches
      * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
      */
     getCenter: function getCenter(touches) {
       var pageX = [],
           pageY = [],
           clientX = [],
           clientY = [],
           min = Math.min,
           max = Math.max;

       // no need to loop when only one touch
       if (touches.length === 1) {
         return {
           pageX: touches[0].pageX,
           pageY: touches[0].pageY,
           clientX: touches[0].clientX,
           clientY: touches[0].clientY
         };
       }

       Utils.each(touches, function (touch) {
         pageX.push(touch.pageX);
         pageY.push(touch.pageY);
         clientX.push(touch.clientX);
         clientY.push(touch.clientY);
       });

       return {
         pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
         pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
         clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
         clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
       };
     },

     /**
      * calculate the velocity between two points. unit is in px per ms.
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      * @return {Object} velocity `x` and `y`
      */
     getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
       return {
         x: Math.abs(deltaX / deltaTime) || 0,
         y: Math.abs(deltaY / deltaTime) || 0
       };
     },

     /**
      * calculate the angle between two coordinates
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {Number} angle
      */
     getAngle: function getAngle(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.atan2(y, x) * 180 / Math.PI;
     },

     /**
      * do a small comparison to get the direction between two touches.
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
      */
     getDirection: function getDirection(touch1, touch2) {
       var x = Math.abs(touch1.clientX - touch2.clientX),
           y = Math.abs(touch1.clientY - touch2.clientY);

       if (x >= y) {
         return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
       }
       return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
     },

     /**
      * calculate the distance between two touches
      * @param {Touch}touch1
      * @param {Touch} touch2
      * @return {Number} distance
      */
     getDistance: function getDistance(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.sqrt(x * x + y * y);
     },

     /**
      * calculate the scale factor between two touchLists
      * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} scale
      */
     getScale: function getScale(start, end) {
       // need two fingers...
       if (start.length >= 2 && end.length >= 2) {
         return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
       }
       return 1;
     },

     /**
      * calculate the rotation degrees between two touchLists
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} rotation
      */
     getRotation: function getRotation(start, end) {
       // need two fingers
       if (start.length >= 2 && end.length >= 2) {
         return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
       }
       return 0;
     },

     /**
      * find out if the direction is vertical   *
      * @param {String} direction matches `DIRECTION_UP|DOWN`
      * @return {Boolean} is_vertical
      */
     isVertical: function isVertical(direction) {
       return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
     },

     /**
      * set css properties with their prefixes
      * @param {HTMLElement} element
      * @param {String} prop
      * @param {String} value
      * @param {Boolean} [toggle=true]
      * @return {Boolean}
      */
     setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
       var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
       prop = Utils.toCamelCase(prop);

       for (var i = 0; i < prefixes.length; i++) {
         var p = prop;
         // prefixes
         if (prefixes[i]) {
           p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
         }

         // test the style
         if (p in element.style) {
           element.style[p] = (toggle === null || toggle) && value || '';
           break;
         }
       }
     },

     /**
      * toggle browser default behavior by setting css properties.
      * `userSelect='none'` also sets `element.onselectstart` to false
      * `userDrag='none'` also sets `element.ondragstart` to false
      *
      * @param {HtmlElement} element
      * @param {Object} props
      * @param {Boolean} [toggle=true]
      */
     toggleBehavior: function toggleBehavior(element, props, toggle) {
       if (!props || !element || !element.style) {
         return;
       }

       // set the css properties
       Utils.each(props, function (value, prop) {
         Utils.setPrefixedCss(element, prop, value, toggle);
       });

       var falseFn = toggle && function () {
         return false;
       };

       // also the disable onselectstart
       if (props.userSelect == 'none') {
         element.onselectstart = falseFn;
       }
       // and disable ondragstart
       if (props.userDrag == 'none') {
         element.ondragstart = falseFn;
       }
     },

     /**
      * convert a string with underscores to camelCase
      * so prevent_default becomes preventDefault
      * @param {String} str
      * @return {String} camelCaseStr
      */
     toCamelCase: function toCamelCase(str) {
       return str.replace(/[_-]([a-z])/g, function (s) {
         return s[1].toUpperCase();
       });
     }
   };

   /**
    * @module GestureDetector
    */
   /**
    * @class Event
    * @static
    */
   Event$1 = GestureDetector.event = {
     /**
      * when touch events have been fired, this is true
      * this is used to stop mouse events
      * @property prevent_mouseevents
      * @private
      * @type {Boolean}
      */
     preventMouseEvents: false,

     /**
      * if EVENT_START has been fired
      * @property started
      * @private
      * @type {Boolean}
      */
     started: false,

     /**
      * when the mouse is hold down, this is true
      * @property should_detect
      * @private
      * @type {Boolean}
      */
     shouldDetect: false,

     /**
      * simple event binder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     on: function on(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.on(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * simple event unbinder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     off: function off(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.off(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * the core touch event handler.
      * this finds out if we should to detect gestures
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Function} handler
      * @return onTouchHandler {Function} the core event handler
      */
     onTouch: function onTouch(element, eventType, handler) {
       var self = this;

       var onTouchHandler = function onTouchHandler(ev) {
         var srcType = ev.type.toLowerCase(),
             isPointer = GestureDetector.HAS_POINTEREVENTS,
             isMouse = Utils.inStr(srcType, 'mouse'),
             triggerType;

         // if we are in a mouseevent, but there has been a touchevent triggered in this session
         // we want to do nothing. simply break out of the event.
         if (isMouse && self.preventMouseEvents) {
           return;

           // mousebutton must be down
         } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
             self.preventMouseEvents = false;
             self.shouldDetect = true;
           } else if (isPointer && eventType == EVENT_START) {
             self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
             // just a valid start event, but no mouse
           } else if (!isMouse && eventType == EVENT_START) {
               self.preventMouseEvents = true;
               self.shouldDetect = true;
             }

         // update the pointer event before entering the detection
         if (isPointer && eventType != EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }

         // we are in a touch/down state, so allowed detection of gestures
         if (self.shouldDetect) {
           triggerType = self.doDetect.call(self, ev, eventType, element, handler);
         }

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         if (triggerType == EVENT_END) {
           self.preventMouseEvents = false;
           self.shouldDetect = false;
           PointerEvent.reset();
           // update the pointerevent object after the detection
         }

         if (isPointer && eventType == EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }
       };

       this.on(element, EVENT_TYPES[eventType], onTouchHandler);
       return onTouchHandler;
     },

     /**
      * the core detection method
      * this finds out what GestureDetector-touch-events to trigger
      * @param {Object} ev
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {HTMLElement} element
      * @param {Function} handler
      * @return {String} triggerType matches `EVENT_START|MOVE|END`
      */
     doDetect: function doDetect(ev, eventType, element, handler) {
       var touchList = this.getTouchList(ev, eventType);
       var touchListLength = touchList.length;
       var triggerType = eventType;
       var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
       var changedLength = touchListLength;

       // at each touchstart-like event we want also want to trigger a TOUCH event...
       if (eventType == EVENT_START) {
         triggerChange = EVENT_TOUCH;
         // ...the same for a touchend-like event
       } else if (eventType == EVENT_END) {
           triggerChange = EVENT_RELEASE;

           // keep track of how many touches have been removed
           changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
         }

       // after there are still touches on the screen,
       // we just want to trigger a MOVE event. so change the START or END to a MOVE
       // but only after detection has been started, the first time we actually want a START
       if (changedLength > 0 && this.started) {
         triggerType = EVENT_MOVE;
       }

       // detection has been started, we keep track of this, see above
       this.started = true;

       // generate some event data, some basic information
       var evData = this.collectEventData(element, triggerType, touchList, ev);

       // trigger the triggerType event before the change (TOUCH, RELEASE) events
       // but the END event should be at last
       if (eventType != EVENT_END) {
         handler.call(Detection, evData);
       }

       // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
       if (triggerChange) {
         evData.changedLength = changedLength;
         evData.eventType = triggerChange;

         handler.call(Detection, evData);

         evData.eventType = triggerType;
         delete evData.changedLength;
       }

       // trigger the END event
       if (triggerType == EVENT_END) {
         handler.call(Detection, evData);

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         this.started = false;
       }

       return triggerType;
     },

     /**
      * we have different events for each device/browser
      * determine what we need and set them in the EVENT_TYPES constant
      * the `onTouch` method is bind to these properties.
      * @return {Object} events
      */
     determineEventTypes: function determineEventTypes() {
       var types;
       if (GestureDetector.HAS_POINTEREVENTS) {
         if (window.PointerEvent) {
           types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
         } else {
           types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
         }
       } else if (GestureDetector.NO_MOUSEEVENTS) {
         types = ['touchstart', 'touchmove', 'touchend touchcancel'];
       } else {
         types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
       }

       EVENT_TYPES[EVENT_START] = types[0];
       EVENT_TYPES[EVENT_MOVE] = types[1];
       EVENT_TYPES[EVENT_END] = types[2];
       return EVENT_TYPES;
     },

     /**
      * create touchList depending on the event
      * @param {Object} ev
      * @param {String} eventType
      * @return {Array} touches
      */
     getTouchList: function getTouchList(ev, eventType) {
       // get the fake pointerEvent touchlist
       if (GestureDetector.HAS_POINTEREVENTS) {
         return PointerEvent.getTouchList();
       }

       // get the touchlist
       if (ev.touches) {
         if (eventType == EVENT_MOVE) {
           return ev.touches;
         }

         var identifiers = [];
         var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
         var touchList = [];

         Utils.each(concat, function (touch) {
           if (Utils.inArray(identifiers, touch.identifier) === false) {
             touchList.push(touch);
           }
           identifiers.push(touch.identifier);
         });

         return touchList;
       }

       // make fake touchList from mouse position
       ev.identifier = 1;
       return [ev];
     },

     /**
      * collect basic event data
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Array} touches
      * @param {Object} ev
      * @return {Object} ev
      */
     collectEventData: function collectEventData(element, eventType, touches, ev) {
       // find out pointerType
       var pointerType = POINTER_TOUCH;
       if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
         pointerType = POINTER_MOUSE;
       } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
         pointerType = POINTER_PEN;
       }

       return {
         center: Utils.getCenter(touches),
         timeStamp: Date.now(),
         target: ev.target,
         touches: touches,
         eventType: eventType,
         pointerType: pointerType,
         srcEvent: ev,

         /**
          * prevent the browser default actions
          * mostly used to disable scrolling of the browser
          */
         preventDefault: function preventDefault() {
           var srcEvent = this.srcEvent;
           srcEvent.preventManipulation && srcEvent.preventManipulation();
           srcEvent.preventDefault && srcEvent.preventDefault();
         },

         /**
          * stop bubbling the event up to its parents
          */
         stopPropagation: function stopPropagation() {
           this.srcEvent.stopPropagation();
         },

         /**
          * immediately stop gesture detection
          * might be useful after a swipe was detected
          * @return {*}
          */
         stopDetect: function stopDetect() {
           return Detection.stopDetect();
         }
       };
     }
   };

   /**
    * @module GestureDetector
    *
    * @class PointerEvent
    * @static
    */
   PointerEvent = GestureDetector.PointerEvent = {
     /**
      * holds all pointers, by `identifier`
      * @property pointers
      * @type {Object}
      */
     pointers: {},

     /**
      * get the pointers as an array
      * @return {Array} touchlist
      */
     getTouchList: function getTouchList() {
       var touchlist = [];
       // we can use forEach since pointerEvents only is in IE10
       Utils.each(this.pointers, function (pointer) {
         touchlist.push(pointer);
       });
       return touchlist;
     },

     /**
      * update the position of a pointer
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Object} pointerEvent
      */
     updatePointer: function updatePointer(eventType, pointerEvent) {
       if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
         delete this.pointers[pointerEvent.pointerId];
       } else {
         pointerEvent.identifier = pointerEvent.pointerId;
         this.pointers[pointerEvent.pointerId] = pointerEvent;
       }
     },

     /**
      * check if ev matches pointertype
      * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
      * @param {PointerEvent} ev
      */
     matchType: function matchType(pointerType, ev) {
       if (!ev.pointerType) {
         return false;
       }

       var pt = ev.pointerType,
           types = {};

       types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
       types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
       types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
       return types[pointerType];
     },

     /**
      * reset the stored pointers
      */
     reset: function resetList() {
       this.pointers = {};
     }
   };

   /**
    * @module GestureDetector
    *
    * @class Detection
    * @static
    */
   Detection = GestureDetector.detection = {
     // contains all registered GestureDetector.gestures in the correct order
     gestures: [],

     // data of the current GestureDetector.gesture detection session
     current: null,

     // the previous GestureDetector.gesture session data
     // is a full clone of the previous gesture.current object
     previous: null,

     // when this becomes true, no gestures are fired
     stopped: false,

     /**
      * start GestureDetector.gesture detection
      * @param {GestureDetector.Instance} inst
      * @param {Object} eventData
      */
     startDetect: function startDetect(inst, eventData) {
       // already busy with a GestureDetector.gesture detection on an element
       if (this.current) {
         return;
       }

       this.stopped = false;

       // holds current session
       this.current = {
         inst: inst, // reference to GestureDetectorInstance we're working for
         startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
         lastEvent: false, // last eventData
         lastCalcEvent: false, // last eventData for calculations.
         futureCalcEvent: false, // last eventData for calculations.
         lastCalcData: {}, // last lastCalcData
         name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
       };

       this.detect(eventData);
     },

     /**
      * GestureDetector.gesture detection
      * @param {Object} eventData
      * @return {any}
      */
     detect: function detect(eventData) {
       if (!this.current || this.stopped) {
         return;
       }

       // extend event data with calculations about scale, distance etc
       eventData = this.extendEventData(eventData);

       // GestureDetector instance and instance options
       var inst = this.current.inst,
           instOptions = inst.options;

       // call GestureDetector.gesture handlers
       Utils.each(this.gestures, function triggerGesture(gesture) {
         // only when the instance options have enabled this gesture
         if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
           gesture.handler.call(gesture, eventData, inst);
         }
       }, this);

       // store as previous event event
       if (this.current) {
         this.current.lastEvent = eventData;
       }

       if (eventData.eventType == EVENT_END) {
         this.stopDetect();
       }

       return eventData; // eslint-disable-line consistent-return
     },

     /**
      * clear the GestureDetector.gesture vars
      * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
      * to stop other GestureDetector.gestures from being fired
      */
     stopDetect: function stopDetect() {
       // clone current data to the store as the previous gesture
       // used for the double tap gesture, since this is an other gesture detect session
       this.previous = Utils.extend({}, this.current);

       // reset the current
       this.current = null;
       this.stopped = true;
     },

     /**
      * calculate velocity, angle and direction
      * @param {Object} ev
      * @param {Object} center
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      */
     getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
       var cur = this.current,
           recalc = false,
           calcEv = cur.lastCalcEvent,
           calcData = cur.lastCalcData;

       if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
         center = calcEv.center;
         deltaTime = ev.timeStamp - calcEv.timeStamp;
         deltaX = ev.center.clientX - calcEv.center.clientX;
         deltaY = ev.center.clientY - calcEv.center.clientY;
         recalc = true;
       }

       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         cur.futureCalcEvent = ev;
       }

       if (!cur.lastCalcEvent || recalc) {
         calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
         calcData.angle = Utils.getAngle(center, ev.center);
         calcData.direction = Utils.getDirection(center, ev.center);

         cur.lastCalcEvent = cur.futureCalcEvent || ev;
         cur.futureCalcEvent = ev;
       }

       ev.velocityX = calcData.velocity.x;
       ev.velocityY = calcData.velocity.y;
       ev.interimAngle = calcData.angle;
       ev.interimDirection = calcData.direction;
     },

     /**
      * extend eventData for GestureDetector.gestures
      * @param {Object} ev
      * @return {Object} ev
      */
     extendEventData: function extendEventData(ev) {
       var cur = this.current,
           startEv = cur.startEvent,
           lastEv = cur.lastEvent || startEv;

       // update the start touchlist to calculate the scale/rotation
       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         startEv.touches = [];
         Utils.each(ev.touches, function (touch) {
           startEv.touches.push({
             clientX: touch.clientX,
             clientY: touch.clientY
           });
         });
       }

       var deltaTime = ev.timeStamp - startEv.timeStamp,
           deltaX = ev.center.clientX - startEv.center.clientX,
           deltaY = ev.center.clientY - startEv.center.clientY;

       this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

       Utils.extend(ev, {
         startEvent: startEv,

         deltaTime: deltaTime,
         deltaX: deltaX,
         deltaY: deltaY,

         distance: Utils.getDistance(startEv.center, ev.center),
         angle: Utils.getAngle(startEv.center, ev.center),
         direction: Utils.getDirection(startEv.center, ev.center),
         scale: Utils.getScale(startEv.touches, ev.touches),
         rotation: Utils.getRotation(startEv.touches, ev.touches)
       });

       return ev;
     },

     /**
      * register new gesture
      * @param {Object} gesture object, see `gestures/` for documentation
      * @return {Array} gestures
      */
     register: function register(gesture) {
       // add an enable gesture options if there is no given
       var options = gesture.defaults || {};
       if (options[gesture.name] === undefined) {
         options[gesture.name] = true;
       }

       // extend GestureDetector default options with the GestureDetector.gesture options
       Utils.extend(GestureDetector.defaults, options, true);

       // set its index
       gesture.index = gesture.index || 1000;

       // add GestureDetector.gesture to the list
       this.gestures.push(gesture);

       // sort the list by index
       this.gestures.sort(function (a, b) {
         if (a.index < b.index) {
           return -1;
         }
         if (a.index > b.index) {
           return 1;
         }
         return 0;
       });

       return this.gestures;
     }
   };

   /**
    * @module GestureDetector
    */

   /**
    * create new GestureDetector instance
    * all methods should return the instance itself, so it is chainable.
    *
    * @class Instance
    * @constructor
    * @param {HTMLElement} element
    * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
    * @return {GestureDetector.Instance}
    */
   GestureDetector.Instance = function (element, options) {
     var self = this;

     // setup GestureDetectorJS window events and register all gestures
     // this also sets up the default options
     setup();

     /**
      * @property element
      * @type {HTMLElement}
      */
     this.element = element;

     /**
      * @property enabled
      * @type {Boolean}
      * @protected
      */
     this.enabled = true;

     /**
      * options, merged with the defaults
      * options with an _ are converted to camelCase
      * @property options
      * @type {Object}
      */
     Utils.each(options, function (value, name) {
       delete options[name];
       options[Utils.toCamelCase(name)] = value;
     });

     this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

     // add some css to the element to prevent the browser from doing its native behavior
     if (this.options.behavior) {
       Utils.toggleBehavior(this.element, this.options.behavior, true);
     }

     /**
      * event start handler on the element to start the detection
      * @property eventStartHandler
      * @type {Object}
      */
     this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
       if (self.enabled && ev.eventType == EVENT_START) {
         Detection.startDetect(self, ev);
       } else if (ev.eventType == EVENT_TOUCH) {
         Detection.detect(ev);
       }
     });

     /**
      * keep a list of user event handlers which needs to be removed when calling 'dispose'
      * @property eventHandlers
      * @type {Array}
      */
     this.eventHandlers = [];
   };

   GestureDetector.Instance.prototype = {
     /**
      * @method on
      * @signature on(gestures, handler)
      * @description
      *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
      *  [ja]drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate [/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja][/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja][/ja]
      */
     on: function onEvent(gestures, handler) {
       var self = this;
       Event$1.on(self.element, gestures, handler, function (type) {
         self.eventHandlers.push({ gesture: type, handler: handler });
       });
       return self;
     },

     /**
      * @method off
      * @signature off(gestures, handler)
      * @description
      *  [en]Remove an event listener.[/en]
      *  [ja][/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja][/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja][/ja]
      */
     off: function offEvent(gestures, handler) {
       var self = this;

       Event$1.off(self.element, gestures, handler, function (type) {
         var index = Utils.inArray({ gesture: type, handler: handler });
         if (index !== false) {
           self.eventHandlers.splice(index, 1);
         }
       });
       return self;
     },

     /**
      * trigger gesture event
      * @method trigger
      * @signature trigger(gesture, eventData)
      * @param {String} gesture
      * @param {Object} [eventData]
      */
     trigger: function triggerEvent(gesture, eventData) {
       // optional
       if (!eventData) {
         eventData = {};
       }

       // create DOM event
       var event = GestureDetector.DOCUMENT.createEvent('Event');
       event.initEvent(gesture, true, true);
       event.gesture = eventData;

       // trigger on the target if it is in the instance element,
       // this is for event delegation tricks
       var element = this.element;
       if (Utils.hasParent(eventData.target, element)) {
         element = eventData.target;
       }

       element.dispatchEvent(event);
       return this;
     },

     /**
      * @method enable
      * @signature enable(state)
      * @description
      *  [en]Enable or disable gesture detection.[/en]
      *  [ja]/[/ja]
      * @param {Boolean} state
      *   [en]Specify if it should be enabled or not.[/en]
      *   [ja][/ja]
      */
     enable: function enable(state) {
       this.enabled = state;
       return this;
     },

     /**
      * @method dispose
      * @signature dispose()
      * @description
      *  [en]Remove and destroy all event handlers for this instance.[/en]
      *  [ja][/ja]
      */
     dispose: function dispose() {
       var i, eh;

       // undo all changes made by stop_browser_behavior
       Utils.toggleBehavior(this.element, this.options.behavior, false);

       // unbind all custom event handlers
       for (i = -1; eh = this.eventHandlers[++i];) {
         // eslint-disable-line no-cond-assign
         Utils.off(this.element, eh.gesture, eh.handler);
       }

       this.eventHandlers = [];

       // unbind the start event listener
       Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

       return null;
     }
   };

   /**
    * @module gestures
    */
   /**
    * Move with x fingers (default 1) around on the page.
    * Preventing the default browser behavior is a good way to improve feel and working.
    * ````
    *  GestureDetectortime.on("drag", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Drag
    * @static
    */
   /**
    * @event drag
    * @param {Object} ev
    */
   /**
    * @event dragstart
    * @param {Object} ev
    */
   /**
    * @event dragend
    * @param {Object} ev
    */
   /**
    * @event drapleft
    * @param {Object} ev
    */
   /**
    * @event dragright
    * @param {Object} ev
    */
   /**
    * @event dragup
    * @param {Object} ev
    */
   /**
    * @event dragdown
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function dragGesture(ev, inst) {
       var cur = Detection.current;

       // max touches
       if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
         return;
       }

       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
             return;
           }

           var startCenter = cur.startEvent.center;

           // we are dragging!
           if (cur.name != name) {
             cur.name = name;
             if (inst.options.dragDistanceCorrection && ev.distance > 0) {
               // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
               // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
               // It might be useful to save the original start point somewhere
               var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
               startCenter.pageX += ev.deltaX * factor;
               startCenter.pageY += ev.deltaY * factor;
               startCenter.clientX += ev.deltaX * factor;
               startCenter.clientY += ev.deltaY * factor;

               // recalculate event data using new start point
               ev = Detection.extendEventData(ev);
             }
           }

           // lock drag to axis?
           if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
             ev.dragLockToAxis = true;
           }

           // keep direction on the axis that the drag gesture started on
           var lastDirection = cur.lastEvent.direction;
           if (ev.dragLockToAxis && lastDirection !== ev.direction) {
             if (Utils.isVertical(lastDirection)) {
               ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
             } else {
               ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
             }
           }

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           // trigger events
           inst.trigger(name, ev);
           inst.trigger(name + ev.direction, ev);

           var isVertical = Utils.isVertical(ev.direction);

           // block the browser events
           if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
             ev.preventDefault();
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;

         case EVENT_END:
           triggered = false;
           break;
       }
     }

     GestureDetector.gestures.Drag = {
       name: name,
       index: 50,
       handler: dragGesture,
       defaults: {
         /**
          * minimal movement that have to be made before the drag event gets triggered
          * @property dragMinDistance
          * @type {Number}
          * @default 10
          */
         dragMinDistance: 10,

         /**
          * Set dragDistanceCorrection to true to make the starting point of the drag
          * be calculated from where the drag was triggered, not from where the touch started.
          * Useful to avoid a jerk-starting drag, which can make fine-adjustments
          * through dragging difficult, and be visually unappealing.
          * @property dragDistanceCorrection
          * @type {Boolean}
          * @default true
          */
         dragDistanceCorrection: true,

         /**
          * set 0 for unlimited, but this can conflict with transform
          * @property dragMaxTouches
          * @type {Number}
          * @default 1
          */
         dragMaxTouches: 1,

         /**
          * prevent default browser behavior when dragging occurs
          * be careful with it, it makes the element a blocking element
          * when you are using the drag gesture, it is a good practice to set this true
          * @property dragBlockHorizontal
          * @type {Boolean}
          * @default false
          */
         dragBlockHorizontal: false,

         /**
          * same as `dragBlockHorizontal`, but for vertical movement
          * @property dragBlockVertical
          * @type {Boolean}
          * @default false
          */
         dragBlockVertical: false,

         /**
          * dragLockToAxis keeps the drag gesture on the axis that it started on,
          * It disallows vertical directions if the initial direction was horizontal, and vice versa.
          * @property dragLockToAxis
          * @type {Boolean}
          * @default false
          */
         dragLockToAxis: false,

         /**
          * drag lock only kicks in when distance > dragLockMinDistance
          * This way, locking occurs only when the distance has become large enough to reliably determine the direction
          * @property dragLockMinDistance
          * @type {Number}
          * @default 25
          */
         dragLockMinDistance: 25
       }
     };
   })('drag');

   /**
    * @module gestures
    */
   /**
    * trigger a simple gesture event, so you can do anything in your handler.
    * only usable if you know what your doing...
    *
    * @class Gesture
    * @static
    */
   /**
    * @event gesture
    * @param {Object} ev
    */
   GestureDetector.gestures.Gesture = {
     name: 'gesture',
     index: 1337,
     handler: function releaseGesture(ev, inst) {
       inst.trigger(this.name, ev);
     }
   };

   /**
    * @module gestures
    */
   /**
    * Touch stays at the same place for x time
    *
    * @class Hold
    * @static
    */
   /**
    * @event hold
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var timer;

     function holdGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current;

       switch (ev.eventType) {
         case EVENT_START:
           clearTimeout(timer);

           // set the gesture so we can check in the timeout if it still is
           current.name = name;

           // set timer and if after the timeout it still is hold,
           // we trigger the hold event
           timer = setTimeout(function () {
             if (current && current.name == name) {
               inst.trigger(name, ev);
             }
           }, options.holdTimeout);
           break;

         case EVENT_MOVE:
           if (ev.distance > options.holdThreshold) {
             clearTimeout(timer);
           }
           break;

         case EVENT_RELEASE:
           clearTimeout(timer);
           break;
       }
     }

     GestureDetector.gestures.Hold = {
       name: name,
       index: 10,
       defaults: {
         /**
          * @property holdTimeout
          * @type {Number}
          * @default 500
          */
         holdTimeout: 500,

         /**
          * movement allowed while holding
          * @property holdThreshold
          * @type {Number}
          * @default 2
          */
         holdThreshold: 2
       },
       handler: holdGesture
     };
   })('hold');

   /**
    * @module gestures
    */
   /**
    * when a touch is being released from the page
    *
    * @class Release
    * @static
    */
   /**
    * @event release
    * @param {Object} ev
    */
   GestureDetector.gestures.Release = {
     name: 'release',
     index: Infinity,
     handler: function releaseGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         inst.trigger(this.name, ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * triggers swipe events when the end velocity is above the threshold
    * for best usage, set `preventDefault` (on the drag gesture) to `true`
    * ````
    *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Swipe
    * @static
    */
   /**
    * @event swipe
    * @param {Object} ev
    */
   /**
    * @event swipeleft
    * @param {Object} ev
    */
   /**
    * @event swiperight
    * @param {Object} ev
    */
   /**
    * @event swipeup
    * @param {Object} ev
    */
   /**
    * @event swipedown
    * @param {Object} ev
    */
   GestureDetector.gestures.Swipe = {
     name: 'swipe',
     index: 40,
     defaults: {
       /**
        * @property swipeMinTouches
        * @type {Number}
        * @default 1
        */
       swipeMinTouches: 1,

       /**
        * @property swipeMaxTouches
        * @type {Number}
        * @default 1
        */
       swipeMaxTouches: 1,

       /**
        * horizontal swipe velocity
        * @property swipeVelocityX
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityX: 0.6,

       /**
        * vertical swipe velocity
        * @property swipeVelocityY
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityY: 0.6
     },

     handler: function swipeGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         var touches = ev.touches.length,
             options = inst.options;

         // max touches
         if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
           return;
         }

         // when the distance we moved is too small we skip this gesture
         // or we can be already in dragging
         if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
           // trigger swipe events
           inst.trigger(this.name, ev);
           inst.trigger(this.name + ev.direction, ev);
         }
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * Single tap and a double tap on a place
    *
    * @class Tap
    * @static
    */
   /**
    * @event tap
    * @param {Object} ev
    */
   /**
    * @event doubletap
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var hasMoved = false;

     function tapGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current,
           prev = Detection.previous,
           sincePrev,
           didDoubleTap;

       switch (ev.eventType) {
         case EVENT_START:
           hasMoved = false;
           break;

         case EVENT_MOVE:
           hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
           break;

         case EVENT_END:
           if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
             // previous gesture, for the double tap since these are two different gesture detections
             sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
             didDoubleTap = false;

             // check if double tap
             if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
               inst.trigger('doubletap', ev);
               didDoubleTap = true;
             }

             // do a single tap
             if (!didDoubleTap || options.tapAlways) {
               current.name = name;
               inst.trigger(current.name, ev);
             }
           }
           break;
       }
     }

     GestureDetector.gestures.Tap = {
       name: name,
       index: 100,
       handler: tapGesture,
       defaults: {
         /**
          * max time of a tap, this is for the slow tappers
          * @property tapMaxTime
          * @type {Number}
          * @default 250
          */
         tapMaxTime: 250,

         /**
          * max distance of movement of a tap, this is for the slow tappers
          * @property tapMaxDistance
          * @type {Number}
          * @default 10
          */
         tapMaxDistance: 10,

         /**
          * always trigger the `tap` event, even while double-tapping
          * @property tapAlways
          * @type {Boolean}
          * @default true
          */
         tapAlways: true,

         /**
          * max distance between two taps
          * @property doubleTapDistance
          * @type {Number}
          * @default 20
          */
         doubleTapDistance: 20,

         /**
          * max time between two taps
          * @property doubleTapInterval
          * @type {Number}
          * @default 300
          */
         doubleTapInterval: 300
       }
     };
   })('tap');

   /**
    * @module gestures
    */
   /**
    * when a touch is being touched at the page
    *
    * @class Touch
    * @static
    */
   /**
    * @event touch
    * @param {Object} ev
    */
   GestureDetector.gestures.Touch = {
     name: 'touch',
     index: -Infinity,
     defaults: {
       /**
        * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
        * but it improves gestures like transforming and dragging.
        * be careful with using this, it can be very annoying for users to be stuck on the page
        * @property preventDefault
        * @type {Boolean}
        * @default false
        */
       preventDefault: false,

       /**
        * disable mouse events, so only touch (or pen!) input triggers events
        * @property preventMouse
        * @type {Boolean}
        * @default false
        */
       preventMouse: false
     },
     handler: function touchGesture(ev, inst) {
       if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
         ev.stopDetect();
         return;
       }

       if (inst.options.preventDefault) {
         ev.preventDefault();
       }

       if (ev.eventType == EVENT_TOUCH) {
         inst.trigger('touch', ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * User want to scale or rotate with 2 fingers
    * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
    * `preventDefault` option.
    *
    * @class Transform
    * @static
    */
   /**
    * @event transform
    * @param {Object} ev
    */
   /**
    * @event transformstart
    * @param {Object} ev
    */
   /**
    * @event transformend
    * @param {Object} ev
    */
   /**
    * @event pinchin
    * @param {Object} ev
    */
   /**
    * @event pinchout
    * @param {Object} ev
    */
   /**
    * @event rotate
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function transformGesture(ev, inst) {
       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // at least multitouch
           if (ev.touches.length < 2) {
             return;
           }

           var scaleThreshold = Math.abs(1 - ev.scale);
           var rotationThreshold = Math.abs(ev.rotation);

           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
             return;
           }

           // we are transforming!
           Detection.current.name = name;

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           inst.trigger(name, ev); // basic transform event

           // trigger rotate event
           if (rotationThreshold > inst.options.transformMinRotation) {
             inst.trigger('rotate', ev);
           }

           // trigger pinch event
           if (scaleThreshold > inst.options.transformMinScale) {
             inst.trigger('pinch', ev);
             inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength < 2) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;
       }
     }

     GestureDetector.gestures.Transform = {
       name: name,
       index: 45,
       defaults: {
         /**
          * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
          * @property transformMinScale
          * @type {Number}
          * @default 0.01
          */
         transformMinScale: 0.01,

         /**
          * rotation in degrees
          * @property transformMinRotation
          * @type {Number}
          * @default 1
          */
         transformMinRotation: 1
       },

       handler: transformGesture
     };
   })('transform');

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @object ons.platform
    * @category util
    * @description
    *   [en]Utility methods to detect current platform.[/en]
    *   [ja][/ja]
    */

   var Platform = function () {

     /**
      * All elements will be rendered as if the app was running on this platform.
      * @type {String}
      */

     function Platform() {
       babelHelpers.classCallCheck(this, Platform);

       this._renderPlatform = null;
     }

     /**
      * @method select
      * @signature select(platform)
      * @param  {string} platform Name of the platform.
      *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
      *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"[/ja]
      * @description
      *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
      *   [ja][/ja]
      */


     babelHelpers.createClass(Platform, [{
       key: 'select',
       value: function select(platform) {
         if (typeof platform === 'string') {
           this._renderPlatform = platform.trim().toLowerCase();
         }
       }

       /**
        * @method isWebView
        * @signature isWebView()
        * @description
        *   [en]Returns whether app is running in Cordova.[/en]
        *   [ja]Cordova[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isWebView',
       value: function isWebView() {
         if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
           throw new Error('isWebView() method is available after dom contents loaded.');
         }

         return !!(window.cordova || window.phonegap || window.PhoneGap);
       }

       /**
        * @method isIOS
        * @signature isIOS()
        * @description
        *   [en]Returns whether the OS is iOS.[/en]
        *   [ja]iOS[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS',
       value: function isIOS() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ios';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/iOS/i.test(device.platform)
           );
         } else {
           return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroid
        * @signature isAndroid()
        * @description
        *   [en]Returns whether the OS is Android.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroid',
       value: function isAndroid() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'android';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/Android/i.test(device.platform)
           );
         } else {
           return (/Android/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroidPhone
        * @signature isAndroidPhone()
        * @description
        *   [en]Returns whether the device is Android phone.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidPhone',
       value: function isAndroidPhone() {
         return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isAndroidTablet
        * @signature isAndroidTablet()
        * @description
        *   [en]Returns whether the device is Android tablet.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidTablet',
       value: function isAndroidTablet() {
         return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isWP',
       value: function isWP() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'wp';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/Win32NT|WinCE/i.test(device.platform)
           );
         } else {
           return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @methos isIPhone
        * @signature isIPhone()
        * @description
        *   [en]Returns whether the device is iPhone.[/en]
        *   [ja]iPhone[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPhone',
       value: function isIPhone() {
         return (/iPhone/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isIPad
        * @signature isIPad()
        * @description
        *   [en]Returns whether the device is iPad.[/en]
        *   [ja]iPad[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPad',
       value: function isIPad() {
         return (/iPad/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isIPod',
       value: function isIPod() {
         return (/iPod/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isBlackBerry
        * @signature isBlackBerry()
        * @description
        *   [en]Returns whether the device is BlackBerry.[/en]
        *   [ja]BlackBerry[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isBlackBerry',
       value: function isBlackBerry() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'blackberry';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/BlackBerry/i.test(device.platform)
           );
         } else {
           return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isOpera
        * @signature isOpera()
        * @description
        *   [en]Returns whether the browser is Opera.[/en]
        *   [ja]Opera[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isOpera',
       value: function isOpera() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'opera';
         } else {
           return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
         }
       }

       /**
        * @method isFirefox
        * @signature isFirefox()
        * @description
        *   [en]Returns whether the browser is Firefox.[/en]
        *   [ja]Firefox[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isFirefox',
       value: function isFirefox() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'firefox';
         } else {
           return typeof InstallTrigger !== 'undefined';
         }
       }

       /**
        * @method isSafari
        * @signature isSafari()
        * @description
        *   [en]Returns whether the browser is Safari.[/en]
        *   [ja]Safari[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isSafari',
       value: function isSafari() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'safari';
         } else {
           return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
         }
       }

       /**
        * @method isChrome
        * @signature isChrome()
        * @description
        *   [en]Returns whether the browser is Chrome.[/en]
        *   [ja]Chrome[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isChrome',
       value: function isChrome() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'chrome';
         } else {
           return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
         }
       }

       /**
        * @method isIE
        * @signature isIE()
        * @description
        *   [en]Returns whether the browser is Internet Explorer.[/en]
        *   [ja]Internet Explorer[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIE',
       value: function isIE() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ie';
         } else {
           return false || !!document.documentMode;
         }
       }

       /**
        * @method isEdge
        * @signature isEdge()
        * @description
        *   [en]Returns whether the browser is Edge.[/en]
        *   [ja]Edge[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isEdge',
       value: function isEdge() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'edge';
         } else {
           return navigator.userAgent.indexOf(' Edge/') >= 0;
         }
       }

       /**
        * @method isIOS7above
        * @signature isIOS7above()
        * @description
        *   [en]Returns whether the iOS version is 7 or above.[/en]
        *   [ja]iOS7[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS7above',
       value: function isIOS7above() {
         if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
           );
         } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
           var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
           return parseInt(ver.split('.')[0]) >= 7;
         }
         return false;
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getMobileOS',
       value: function getMobileOS() {
         if (this.isAndroid()) {
           return 'android';
         } else if (this.isIOS()) {
           return 'ios';
         } else if (this.isWP()) {
           return 'wp';
         } else {
           return 'other';
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getIOSDevice',
       value: function getIOSDevice() {
         if (this.isIPhone()) {
           return 'iphone';
         } else if (this.isIPad()) {
           return 'ipad';
         } else if (this.isIPod()) {
           return 'ipod';
         } else {
           return 'na';
         }
       }
     }]);
     return Platform;
   }();

   var platform = new Platform();

   /**
    * @object ons.notification
    * @category dialog
    * @codepen Qwwxyp
    * @tutorial vanilla/Reference/dialog
    * @description
    *   [en]
    *     Utility methods to create different kinds of alert dialogs. There are three methods available:
    *
    *     * `ons.notification.alert()`
    *     * `ons.notification.confirm()`
    *     * `ons.notification.prompt()`
    *
    *     It will automatically display a Material Design dialog on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @example
    * ons.notification.alert('Hello, world!');
    *
    * ons.notification.confirm('Are you ready?')
    *   .then(
    *     function(answer) {
    *       if (answer === 1) {
    *         ons.notification.alert('Let\'s go!');
    *       }
    *     }
    *   );
    *
    * ons.notification.prompt('How old are ?')
    *   .then(
    *     function(age) {
    *       ons.notification.alert('You are ' + age + ' years old.');
    *     }
    *   );
    */
   var notification = {};

   notification._createAlertDialog = function (title, message, buttonLabels, primaryButtonIndex, modifier, animation, id, _callback, messageIsHTML, cancelable, promptDialog, autofocus, placeholder, defaultValue, submitOnEnter, compile) {

     compile = compile || function (object) {
       return object;
     };

     var titleElementHTML = typeof title === 'string' ? '<div class="alert-dialog-title"></div>' : '';

     var dialogElement = util.createElement('\n  <ons-alert-dialog>\n    ' + titleElementHTML + '\n    <div class="alert-dialog-content"></div>\n    <div class="alert-dialog-footer"></div>\n  </ons-alert-dialog>');

     CustomElements.upgrade(dialogElement);

     if (id) {
       dialogElement.setAttribute('id', id);
     }

     var titleElement = dialogElement.querySelector('.alert-dialog-title');
     var messageElement = dialogElement.querySelector('.alert-dialog-content');
     var footerElement = dialogElement.querySelector('.alert-dialog-footer');
     var inputElement = void 0;
     var result = {};

     result.promise = new Promise(function (resolve, reject) {
       result.resolve = resolve;
       result.reject = reject;
     });

     modifier = modifier || dialogElement.getAttribute('modifier');

     if (typeof title === 'string') {
       titleElement.textContent = title;
     }

     titleElement = null;

     dialogElement.setAttribute('animation', animation);

     if (messageIsHTML) {
       messageElement.innerHTML = message;
     } else {
       messageElement.textContent = message;
     }

     if (promptDialog) {
       inputElement = util.createElement('<input class="text-input text-input--underbar" type="text"></input>');

       if (modifier) {
         inputElement.classList.add('text-input--' + modifier);
       }

       inputElement.setAttribute('placeholder', placeholder);
       inputElement.value = defaultValue;
       inputElement.style.width = '100%';
       inputElement.style.marginTop = '10px';

       messageElement.appendChild(inputElement);

       if (submitOnEnter) {
         inputElement.addEventListener('keypress', function (event) {
           if (event.keyCode === 13) {
             dialogElement.hide({
               callback: function callback() {
                 _callback(inputElement.value);
                 result.resolve(inputElement.value);
                 dialogElement.remove();
                 dialogElement = null;
               }
             });
           }
         }, false);
       }
     }

     document.body.appendChild(dialogElement);

     compile(dialogElement);

     if (buttonLabels.length <= 2) {
       footerElement.classList.add('alert-dialog-footer--one');
     }

     var createButton = function createButton(i) {
       var buttonElement = util.createElement('<button class="alert-dialog-button"></button>');
       buttonElement.appendChild(document.createTextNode(buttonLabels[i]));

       if (i == primaryButtonIndex) {
         buttonElement.classList.add('alert-dialog-button--primal');
       }

       if (buttonLabels.length <= 2) {
         buttonElement.classList.add('alert-dialog-button--one');
       }

       var onClick = function onClick() {
         buttonElement.removeEventListener('click', onClick, false);

         dialogElement.hide({
           callback: function callback() {
             if (promptDialog) {
               _callback(inputElement.value);
               result.resolve(inputElement.value);
             } else {
               _callback(i);
               result.resolve(i);
             }
             dialogElement.remove();
             dialogElement = inputElement = buttonElement = null;
           }
         });
       };

       buttonElement.addEventListener('click', onClick, false);
       footerElement.appendChild(buttonElement);
     };

     for (var i = 0; i < buttonLabels.length; i++) {
       createButton(i);
     }

     if (cancelable) {
       dialogElement.cancelable = true;
       dialogElement.addEventListener('cancel', function () {
         if (promptDialog) {
           _callback(null);
           result.reject(null);
         } else {
           _callback(-1);
           result.reject(-1);
         }
         setTimeout(function () {
           dialogElement.remove();
           dialogElement = null;
           inputElement = null;
         });
       }, false);
     }

     dialogElement.show({
       callback: function callback() {
         if (inputElement && promptDialog && autofocus) {
           inputElement.focus();
         }
       }
     });

     messageElement = footerElement = null;

     if (modifier) {
       dialogElement.setAttribute('modifier', '');
       dialogElement.setAttribute('modifier', modifier);
     }

     return result.promise;
   };

   notification._alertOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       callback: function callback() {}
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Alert dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, false, false, false, '', '', false, options.compile);
   };

   /**
    * @method alert
    * @signature alert(message [, options] | options)
    * @return {Promise}
    *   [en]Will resolve when the dialog is closed.[/en]
    *   [ja][/ja]
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {String} [options.message]
    *   [en]Alert message.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Alert message in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is `"OK"`.[/en]
    *   [ja]"OK"[/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Alert"`.[/en]
    *   [ja]"Alert"[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]Function that executes after dialog has been closed.[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Display an alert dialog to show the user a message.
    *
    *     The content of the message can be either simple text or HTML.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.alert(message, options);
    *     ons.notification.alert(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     HTML
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.alert = notification._alertOriginal;

   notification._confirmOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabels: ['Cancel', 'OK'],
       primaryButtonIndex: 1,
       animation: 'default',
       title: 'Confirm',
       callback: function callback() {},
       cancelable: false
     };

     options = util.extend({}, defaults, options);

     if (!options.message && !options.messageHTML) {
       throw new Error('Confirm dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, options.buttonLabels, options.primaryButtonIndex, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, false, false, '', '', false, options.compile);
   };

   /**
    * @method confirm
    * @signature confirm(message [, options] | options)
    * @return {Promise}
    *   [en]Will resolve to the index of the button that was pressed.[/en]
    *   [ja][/ja]
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    * @param {String} [options.message]
    *   [en]Confirmation question.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {Array} [options.buttonLabels]
    *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
    *   [ja]["Cancel", "OK"][/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is `1`.[/en]
    *   [ja] 1 [/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
    *   [ja][/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Confirm"`.[/en]
    *   [ja]"Confirm"[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the index of the button that was pressed or `-1` if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     
    *     
    *     -1
    *   [/ja]
    * @description
    *   [en]
    *     Display a dialog to ask the user for confirmation.
    *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.confirm(message, options);
    *     ons.notification.confirm(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     "Cancel""OK"
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.confirm = notification._confirmOriginal;

   notification._promptOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       defaultValue: '',
       placeholder: '',
       callback: function callback() {},
       cancelable: false,
       autofocus: true,
       submitOnEnter: true
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Prompt dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, true, options.autofocus, options.placeholder, options.defaultValue, options.submitOnEnter, options.compile);
   };

   /**
    * @method prompt
    * @signature prompt(message [, options] | options)
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Will resolve to the input value when the dialog is closed.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {String} [options.message]
    *   [en]Prompt question.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is `"OK"`.[/en]
    *   [ja]"OK"[/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is `1`.[/en]
    *   [ja] 1 [/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is false. When the dialog is cancelable it will be closed if the user taps the background or presses the Android back button.[/en]
    *   [ja] false [/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Alert"`.[/en]
    *   [ja] "Alert" [/ja]
    * @param {String} [options.placeholder]
    *   [en]Placeholder for the text input.[/en]
    *   [ja][/ja]
    * @param {String} [options.defaultValue]
    *   [en]Default value for the text input.[/en]
    *   [ja][/ja]
    * @param {Boolean} [options.autofocus]
    *   [en]Autofocus the input element. Default is `true`.[/en]
    *   [ja]inputtrue[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the value of the input field or `null` if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     
    *     null
    *   [/ja]
    * @param {Boolean} [options.submitOnEnter]
    *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
    *   [ja]Enterformsubmittrue[/ja]
    * @description
    *   [en]
    *     Display a dialog with a prompt to ask the user a question.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.prompt(message, options);
    *     ons.notification.prompt(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.prompt = notification._promptOriginal;

   var pageAttributeExpression = {
     _variables: {},

     /**
      * Define a variable.
      *
      * @param {String} name Name of the variable
      * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
      * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
      */
     defineVariable: function defineVariable(name, value) {
       var overwrite = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

       if (typeof name !== 'string') {
         throw new Error('Variable name must be a string.');
       } else if (typeof value !== 'string' && typeof value !== 'function') {
         throw new Error('Variable value must be a string or a function.');
       } else if (this._variables.hasOwnProperty(name) && !overwrite) {
         throw new Error('"' + name + '" is already defined.');
       }
       this._variables[name] = value;
     },

     /**
      * Get a variable.
      *
      * @param {String} name Name of the variable.
      * @return {String|Function|null}
      */
     getVariable: function getVariable(name) {
       if (!this._variables.hasOwnProperty(name)) {
         return null;
       }

       return this._variables[name];
     },

     /**
      * Remove a variable.
      *
      * @param {String} name Name of the varaible.
      */
     removeVariable: function removeVariable(name) {
       delete this._variables[name];
     },

     /**
      * Get all variables.
      *
      * @return {Object}
      */
     getAllVariables: function getAllVariables() {
       return this._variables;
     },
     _parsePart: function _parsePart(part) {
       var c = void 0,
           inInterpolation = false,
           currentIndex = 0;

       var tokens = [];

       if (part.length === 0) {
         throw new Error('Unable to parse empty string.');
       }

       for (var i = 0; i < part.length; i++) {
         c = part.charAt(i);

         if (c === '$' && part.charAt(i + 1) === '{') {
           if (inInterpolation) {
             throw new Error('Nested interpolation not supported.');
           }

           var token = part.substring(currentIndex, i);
           if (token.length > 0) {
             tokens.push(part.substring(currentIndex, i));
           }

           currentIndex = i;
           inInterpolation = true;
         } else if (c === '}') {
           if (!inInterpolation) {
             throw new Error('} must be preceeded by ${');
           }

           var _token = part.substring(currentIndex, i + 1);
           if (_token.length > 0) {
             tokens.push(part.substring(currentIndex, i + 1));
           }

           currentIndex = i + 1;
           inInterpolation = false;
         }
       }

       if (inInterpolation) {
         throw new Error('Unterminated interpolation.');
       }

       tokens.push(part.substring(currentIndex, part.length));

       return tokens;
     },
     _replaceToken: function _replaceToken(token) {
       var re = /^\${(.*?)}$/,
           match = token.match(re);

       if (match) {
         var name = match[1].trim();
         var variable = this.getVariable(name);

         if (variable === null) {
           throw new Error('Variable "' + name + '" does not exist.');
         } else if (typeof variable === 'string') {
           return variable;
         } else {
           var rv = variable();

           if (typeof rv !== 'string') {
             throw new Error('Must return a string.');
           }

           return rv;
         }
       } else {
         return token;
       }
     },
     _replaceTokens: function _replaceTokens(tokens) {
       return tokens.map(this._replaceToken.bind(this));
     },
     _parseExpression: function _parseExpression(expression) {
       return expression.split(',').map(function (part) {
         return part.trim();
       }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
         return part.join('');
       });
     },

     /**
      * Evaluate an expression.
      *
      * @param {String} expression An page attribute expression.
      * @return {Array}
      */
     evaluate: function evaluate(expression) {
       if (!expression) {
         return [];
       }

       return this._parseExpression(expression);
     }
   };

   // Define default variables.
   pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
   pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
   pageAttributeExpression.defineVariable('runtime', function () {
     return platform.isWebView() ? 'cordova' : 'browser';
   });

   var internal = {};

   internal.config = {
     autoStatusBarFill: true,
     animationsDisabled: false
   };

   internal.nullElement = window.document.createElement('div');

   /**
    * @return {Boolean}
    */
   internal.isEnabledAutoStatusBarFill = function () {
     return !!internal.config.autoStatusBarFill;
   };

   /**
    * @param {String} html
    * @return {String}
    */
   internal.normalizePageHTML = function (html) {
     html = ('' + html).trim();

     if (!html.match(/^<ons-page/)) {
       html = '<ons-page _muted>' + html + '</ons-page>';
     }

     return html;
   };

   internal.waitDOMContentLoaded = function (callback) {
     if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
       window.document.addEventListener('DOMContentLoaded', callback);
     } else {
       setImmediate(callback);
     }
   };

   internal.autoStatusBarFill = function (action) {
     var onReady = function onReady() {
       if (internal.shouldFillStatusBar()) {
         action();
       }
       document.removeEventListener('deviceready', onReady);
       document.removeEventListener('DOMContentLoaded', onReady);
     };

     if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
       document.addEventListener('deviceready', onReady);
     } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
       document.addEventListener('DOMContentLoaded', function () {
         onReady();
       });
     } else {
       onReady();
     }
   };

   internal.shouldFillStatusBar = function () {
     return internal.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
   };

   internal.templateStore = {
     _storage: {},

     /**
      * @param {String} key
      * @return {String/null} template
      */
     get: function get(key) {
       return internal.templateStore._storage[key] || null;
     },


     /**
      * @param {String} key
      * @param {String} template
      */
     set: function set(key, template) {
       internal.templateStore._storage[key] = template;
     }
   };

   window.document.addEventListener('_templateloaded', function (e) {
     if (e.target.nodeName.toLowerCase() === 'ons-template') {
       internal.templateStore.set(e.templateId, e.template);
     }
   }, false);

   window.document.addEventListener('DOMContentLoaded', function () {
     register('script[type="text/ons-template"]');
     register('script[type="text/template"]');
     register('script[type="text/ng-template"]');

     function register(query) {
       var templates = window.document.querySelectorAll(query);
       for (var i = 0; i < templates.length; i++) {
         internal.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
       }
     }
   }, false);

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getTemplateHTMLAsync = function (page) {
     return new Promise(function (resolve, reject) {
       setImmediate(function () {
         var cache = internal.templateStore.get(page);

         if (cache) {
           var html = typeof cache === 'string' ? cache : cache[1];
           resolve(html);
         } else {
           (function () {
             var xhr = new XMLHttpRequest();
             xhr.open('GET', page, true);
             xhr.onload = function (response) {
               var html = xhr.responseText;
               if (xhr.status >= 400 && xhr.status < 600) {
                 reject(html);
               } else {
                 resolve(html);
               }
             };
             xhr.onerror = function () {
               throw new Error('The page is not found: ' + page);
             };
             xhr.send(null);
           })();
         }
       });
     });
   };

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getPageHTMLAsync = function (page) {
     var pages = pageAttributeExpression.evaluate(page);

     var getPage = function getPage(page) {
       if (typeof page !== 'string') {
         return Promise.reject('Must specify a page.');
       }

       return internal.getTemplateHTMLAsync(page).then(function (html) {
         return internal.normalizePageHTML(html);
       }, function (error) {
         if (pages.length === 0) {
           return Promise.reject(error);
         }

         return getPage(pages.shift());
       }).then(function (html) {
         return internal.normalizePageHTML(html);
       });
     };

     return getPage(pages.shift());
   };

   var AnimatorFactory = function () {

     /**
      * @param {Object} opts
      * @param {Object} opts.animators The dictionary for animator classes
      * @param {Function} opts.baseClass The base class of animators
      * @param {String} [opts.baseClassName] The name of the base class of animators
      * @param {String} [opts.defaultAnimation] The default animation name
      * @param {Object} [opts.defaultAnimationOptions] The default animation options
      */

     function AnimatorFactory(opts) {
       babelHelpers.classCallCheck(this, AnimatorFactory);

       this._animators = opts.animators;
       this._baseClass = opts.baseClass;
       this._baseClassName = opts.baseClassName || opts.baseClass.name;
       this._animation = opts.defaultAnimation || 'default';
       this._animationOptions = opts.defaultAnimationOptions || {};

       if (!this._animators[this._animation]) {
         throw new Error('No such animation: ' + this._animation);
       }
     }

     /**
      * @param {String} jsonString
      * @return {Object/null}
      */


     babelHelpers.createClass(AnimatorFactory, [{
       key: 'setAnimationOptions',


       /**
        * @param {Object} options
        */
       value: function setAnimationOptions(options) {
         this._animationOptions = options;
       }

       /**
        * @param {Object} options
        * @param {String} [options.animation] The animation name
        * @param {Object} [options.animationOptions] The animation options
        * @param {Object} defaultAnimator The default animator instance
        * @return {Object} An animator instance
        */

     }, {
       key: 'newAnimator',
       value: function newAnimator() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var defaultAnimator = arguments[1];


         var animator = null;

         if (options.animation instanceof this._baseClass) {
           return options.animation;
         }

         var Animator = null;

         if (typeof options.animation === 'string') {
           Animator = this._animators[options.animation];
         }

         if (!Animator && defaultAnimator) {
           animator = defaultAnimator;
         } else {
           Animator = Animator || this._animators[this._animation];

           var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

           animator = new Animator(animationOpts);

           if (typeof animator === 'function') {
             animator = new animator(animationOpts); // eslint-disable-line new-cap
           }
         }

         if (!(animator instanceof this._baseClass)) {
           throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
         }

         return animator;
       }
     }], [{
       key: 'parseAnimationOptionsString',
       value: function parseAnimationOptionsString(jsonString) {
         try {
           if (typeof jsonString === 'string') {
             var result = util.animationOptionsParse(jsonString);
             if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
               return result;
             } else {
               console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
             }
           }
           return {};
         } catch (e) {
           console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
           return {};
         }
       }
     }]);
     return AnimatorFactory;
   }();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModifierUtil = function () {
     function ModifierUtil() {
       babelHelpers.classCallCheck(this, ModifierUtil);
     }

     babelHelpers.createClass(ModifierUtil, null, [{
       key: 'diff',

       /**
        * @param {String} last
        * @param {String} current
        */
       value: function diff(last, current) {
         last = makeDict(('' + last).trim());
         current = makeDict(('' + current).trim());

         var removed = Object.keys(last).reduce(function (result, token) {
           if (!current[token]) {
             result.push(token);
           }
           return result;
         }, []);

         var added = Object.keys(current).reduce(function (result, token) {
           if (!last[token]) {
             result.push(token);
           }
           return result;
         }, []);

         return { added: added, removed: removed };

         function makeDict(modifier) {
           var dict = {};
           ModifierUtil.split(modifier).forEach(function (token) {
             return dict[token] = token;
           });
           return dict;
         }
       }

       /**
        * @param {Object} diff
        * @param {Object} classList
        * @param {String} template
        */

     }, {
       key: 'applyDiffToClassList',
       value: function applyDiffToClassList(diff, classList, template) {
         diff.added.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.add(klass);
         });

         diff.removed.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.remove(klass);
         });
       }

       /**
        * @param {Object} diff
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'applyDiffToElement',
       value: function applyDiffToElement(diff, element, scheme) {
         var matches = function matches(e, s) {
           return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
         };
         for (var selector in scheme) {
           if (scheme.hasOwnProperty(selector)) {
             var targetElements = !selector || matches(element, selector) ? [element] : element.querySelectorAll(selector);
             for (var i = 0; i < targetElements.length; i++) {
               ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
             }
           }
         }
       }

       /**
        * @param {String} last
        * @param {String} current
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'onModifierChanged',
       value: function onModifierChanged(last, current, element, scheme) {
         return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
       }

       /**
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'initModifier',
       value: function initModifier(element, scheme) {
         var modifier = element.getAttribute('modifier');
         if (typeof modifier !== 'string') {
           return;
         }

         ModifierUtil.applyDiffToElement({
           removed: [],
           added: ModifierUtil.split(modifier)
         }, element, scheme);
       }
     }, {
       key: 'split',
       value: function split(modifier) {
         if (typeof modifier !== 'string') {
           return [];
         }

         return modifier.trim().split(/ +/).filter(function (token) {
           return token !== '';
         });
       }
     }]);
     return ModifierUtil;
   }();

   var LazyRepeatDelegate = function () {
     function LazyRepeatDelegate(userDelegate) {
       var templateElement = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
       babelHelpers.classCallCheck(this, LazyRepeatDelegate);

       if ((typeof userDelegate === 'undefined' ? 'undefined' : babelHelpers.typeof(userDelegate)) !== 'object' || userDelegate === null) {
         throw Error('"delegate" parameter must be an object.');
       }
       this._userDelegate = userDelegate;

       if (!(templateElement instanceof Element) && templateElement !== null) {
         throw Error('"templateElement" parameter must be an instance of Element or null.');
       }
       this._templateElement = templateElement;
     }

     babelHelpers.createClass(LazyRepeatDelegate, [{
       key: 'hasRenderFunction',


       /**
        * @return {Boolean}
        */
       value: function hasRenderFunction() {
         return this._userDelegate._render instanceof Function;
       }

       /**
        * @return {void}
        */

     }, {
       key: '_render',
       value: function _render(items, height) {
         this._userDelegate._render(items, height);
       }

       /**
        * @param {Number} index
        * @param {Element} parent
        * @param {Function} done A function that take item object as parameter.
        */

     }, {
       key: 'loadItemElement',
       value: function loadItemElement(index, parent, done) {
         if (this._userDelegate.loadItemElement instanceof Function) {
           this._userDelegate.loadItemElement(index, parent, function (element) {
             return done({ element: element });
           });
         } else {
           var element = this._userDelegate.createItemContent(index, this._templateElement);
           if (!(element instanceof Element)) {
             throw Error('createItemContent() must return an instance of Element.');
           }
           parent.appendChild(element);
           done({ element: element });
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'countItems',
       value: function countItems() {
         var count = this._userDelegate.countItems();
         if (typeof count !== 'number') {
           throw Error('countItems() must return a number.');
         }
         return count;
       }

       /**
        * @param {Number} index
        * @param {Object} item
        * @param {Element} item.element
        */

     }, {
       key: 'updateItem',
       value: function updateItem(index, item) {
         if (this._userDelegate.updateItemContent instanceof Function) {
           this._userDelegate.updateItemContent(index, item);
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'calculateItemHeight',
       value: function calculateItemHeight(index) {
         if (this._userDelegate.calculateItemHeight instanceof Function) {
           var height = this._userDelegate.calculateItemHeight(index);

           if (typeof height !== 'number') {
             throw Error('calculateItemHeight() must return a number.');
           }

           return height;
         }

         return 0;
       }

       /**
        * @param {Number} index
        * @param {Object} item
        */

     }, {
       key: 'destroyItem',
       value: function destroyItem(index, item) {
         if (this._userDelegate.destroyItem instanceof Function) {
           this._userDelegate.destroyItem(index, item);
         }
       }

       /**
        * @return {void}
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         if (this._userDelegate.destroy instanceof Function) {
           this._userDelegate.destroy();
         }

         this._userDelegate = this._templateElement = null;
       }
     }, {
       key: 'itemHeight',
       get: function get() {
         return this._userDelegate.itemHeight;
       }
     }]);
     return LazyRepeatDelegate;
   }();

   /**
    * This class provide core functions for ons-lazy-repeat.
    */
   var LazyRepeatProvider = function () {

     /**
      * @param {Element} wrapperElement
      * @param {LazyRepeatDelegate} delegate
      */

     function LazyRepeatProvider(wrapperElement, delegate) {
       babelHelpers.classCallCheck(this, LazyRepeatProvider);

       if (!(delegate instanceof LazyRepeatDelegate)) {
         throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
       }

       this._wrapperElement = wrapperElement;
       this._delegate = delegate;

       if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
         wrapperElement.classList.add('lazy-list');
       }

       this._pageContent = util.findParent(wrapperElement, '.page__content');

       if (!this._pageContent) {
         throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
       }

       this._topPositions = [];
       this._renderedItems = {};

       if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
         this._unknownItemHeight = true;
       }
       this._addEventListeners();
       this._onChange();
     }

     babelHelpers.createClass(LazyRepeatProvider, [{
       key: '_checkItemHeight',
       value: function _checkItemHeight(callback) {
         var _this = this;

         this._delegate.loadItemElement(0, this._wrapperElement, function (item) {
           if (!_this._unknownItemHeight) {
             throw Error('Invalid state');
           }

           var done = function done() {
             _this._wrapperElement.removeChild(item.element);
             delete _this._unknownItemHeight;
             callback();
           };

           _this._itemHeight = item.element.offsetHeight;

           if (_this._itemHeight > 0) {
             done();
             return;
           }

           // retry to measure offset height
           // dirty fix for angular2 directive
           var lastVisibility = _this._wrapperElement.style.visibility;
           _this._wrapperElement.style.visibility = 'hidden';
           item.element.style.visibility = 'hidden';

           setImmediate(function () {
             _this._itemHeight = item.element.offsetHeight;
             if (_this._itemHeight == 0) {
               throw Error('Invalid state: this._itemHeight must be greater than zero.');
             }
             _this._wrapperElement.style.visibility = lastVisibility;
             done();
           });
         });
       }
     }, {
       key: '_countItems',
       value: function _countItems() {
         return this._delegate.countItems();
       }
     }, {
       key: '_getItemHeight',
       value: function _getItemHeight(i) {
         return this.staticItemHeight || this._delegate.calculateItemHeight(i);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._render();
       }
     }, {
       key: 'refresh',
       value: function refresh() {
         this._removeAllElements();
         this._onChange();
       }
     }, {
       key: '_render',
       value: function _render() {
         var _this2 = this;

         if (this._unknownItemHeight) {
           return this._checkItemHeight(this._render.bind(this));
         }

         var items = this._getItemsInView();

         if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
           this._delegate._render(items, this._listHeight);
           return null;
         }

         var keep = {};

         items.forEach(function (item) {
           _this2._renderElement(item);
           keep[item.index] = true;
         });

         Object.keys(this._renderedItems).forEach(function (key) {
           return keep[key] || _this2._removeElement(key);
         });

         this._wrapperElement.style.height = this._listHeight + 'px';
       }

       /**
        * @param {Object} item
        * @param {Number} item.index
        * @param {Number} item.top
        */

     }, {
       key: '_renderElement',
       value: function _renderElement(_ref) {
         var _this3 = this;

         var index = _ref.index;
         var top = _ref.top;

         var item = this._renderedItems[index];
         if (item) {
           this._delegate.updateItem(index, item); // update if it exists
           item.element.style.top = top + 'px';
           return;
         }

         this._delegate.loadItemElement(index, this._wrapperElement, function (item) {
           util.extend(item.element.style, {
             position: 'absolute',
             top: top + 'px',
             left: 0,
             right: 0
           });

           _this3._renderedItems[index] = item;
         });
       }

       /**
        * @param {Number} index
        */

     }, {
       key: '_removeElement',
       value: function _removeElement(index) {
         var item = this._renderedItems[index];

         this._delegate.destroyItem(index, item);

         if (item.element.parentElement) {
           item.element.parentElement.removeChild(item.element);
         }

         delete this._renderedItems[index];
       }
     }, {
       key: '_removeAllElements',
       value: function _removeAllElements() {
         var _this4 = this;

         Object.keys(this._renderedItems).forEach(function (key) {
           return _this4._removeElement(key);
         });
       }
     }, {
       key: '_calculateStartIndex',
       value: function _calculateStartIndex(current) {
         var start = 0;
         var end = this._itemCount - 1;

         if (this.staticItemHeight) {
           return parseInt(-current / this.staticItemHeight);
         }

         // Binary search for index at top of screen so we can speed up rendering.
         for (;;) {
           var middle = Math.floor((start + end) / 2);
           var value = current + this._topPositions[middle];

           if (end < start) {
             return 0;
           } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
             return middle;
           } else if (isNaN(value) || value >= 0) {
             end = middle - 1;
           } else {
             start = middle + 1;
           }
         }
       }
     }, {
       key: '_recalculateTopPositions',
       value: function _recalculateTopPositions() {
         var l = Math.min(this._topPositions.length, this._itemCount);
         this._topPositions[0] = 0;
         for (var i = 1, _l; i < _l; i++) {
           this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
         }
       }
     }, {
       key: '_getItemsInView',
       value: function _getItemsInView() {
         var offset = this._wrapperElement.getBoundingClientRect().top;
         var limit = 4 * window.innerHeight - offset;
         var count = this._countItems();

         if (count !== this._itemCount) {
           this._itemCount = count;
           this._recalculateTopPositions();
         }

         var i = Math.max(0, this._calculateStartIndex(offset) - 30);

         var items = [];
         for (var top = this._topPositions[i]; i < count && top < limit; i++) {
           if (i >= this._topPositions.length) {
             // perf optimization
             this._topPositions.length += 100;
           }

           this._topPositions[i] = top;
           items.push({ top: top, index: i });
           top += this._getItemHeight(i);
         }
         this._listHeight = top;

         return items;
       }
     }, {
       key: '_debounce',
       value: function _debounce(func, wait, immediate) {
         var timeout = void 0;
         return function () {
           var _this5 = this,
               _arguments = arguments;

           var callNow = immediate && !timeout;
           clearTimeout(timeout);
           if (callNow) {
             func.apply(this, arguments);
           } else {
             timeout = setTimeout(function () {
               timeout = null;
               func.apply(_this5, _arguments);
             }, wait);
           }
         };
       }
     }, {
       key: '_doubleFireOnTouchend',
       value: function _doubleFireOnTouchend() {
         this._render();
         this._debounce(this._render.bind(this), 100);
       }
     }, {
       key: '_addEventListeners',
       value: function _addEventListeners() {
         util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

         if (platform.isIOS()) {
           this._boundOnChange = this._debounce(this._boundOnChange, 30);
         }

         this._pageContent.addEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.addEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.removeEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: 'destroy',
       value: function destroy() {
         this._removeAllElements();
         this._delegate.destroy();
         this._parentElement = this._delegate = this._renderedItems = null;
         this._removeEventListeners();
       }
     }, {
       key: 'staticItemHeight',
       get: function get() {
         return this._delegate.itemHeight || this._itemHeight;
       }
     }]);
     return LazyRepeatProvider;
   }();

   internal.AnimatorFactory = AnimatorFactory;
   internal.ModifierUtil = ModifierUtil;
   internal.LazyRepeatProvider = LazyRepeatProvider;
   internal.LazyRepeatDelegate = LazyRepeatDelegate;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var create = function create() {

     /**
      * @object ons.orientation
      * @category util
      * @description
      *   [en]Utility methods for orientation detection.[/en]
      *   [ja][/ja]
      */
     var obj = {
       /**
        * @event change
        * @description
        *   [en]Fired when the device orientation changes.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Boolean} event.isPortrait
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]portraittrue[/ja]
        */

       /**
        * @method on
        * @signature on(eventName, listener)
        * @description
        *   [en]Add an event listener.[/en]
        *   [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       /**
        * @method once
        * @signature once(eventName, listener)
        * @description
        *  [en]Add an event listener that's only triggered once.[/en]
        *  [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       /**
        * @method off
        * @signature off(eventName, [listener])
        * @description
        *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
        *  [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       // actual implementation to detect if whether current screen is portrait or not
       _isPortrait: false,

       /**
        * @method isPortrait
        * @signature isPortrait()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]portraittrue[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is portrait or not.[/en]
        *   [ja]portrait[/ja]
        */
       isPortrait: function isPortrait() {
         return this._isPortrait();
       },

       /**
        * @method isLandscape
        * @signature isLandscape()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is landscape mode.[/en]
        *   [ja]landscapetrue[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is landscape or not.[/en]
        *   [ja]landscape[/ja]
        */
       isLandscape: function isLandscape() {
         return !this.isPortrait();
       },

       _init: function _init() {
         document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

         if ('orientation' in window) {
           window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
         } else {
           window.addEventListener('resize', this._onResize.bind(this), false);
         }

         this._isPortrait = function () {
           return window.innerHeight > window.innerWidth;
         };

         return this;
       },

       _onDOMContentLoaded: function _onDOMContentLoaded() {
         this._installIsPortraitImplementation();
         this.emit('change', { isPortrait: this.isPortrait() });
       },

       _installIsPortraitImplementation: function _installIsPortraitImplementation() {
         var isPortrait = window.innerWidth < window.innerHeight;

         if (!('orientation' in window)) {
           this._isPortrait = function () {
             return window.innerHeight > window.innerWidth;
           };
         } else if (window.orientation % 180 === 0) {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
           };
         } else {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
           };
         }
       },

       _onOrientationChange: function _onOrientationChange() {
         var _this = this;

         var isPortrait = this._isPortrait();

         // Wait for the dimensions to change because
         // of Android inconsistency.
         var nIter = 0;
         var interval = setInterval(function () {
           nIter++;

           var w = window.innerWidth;
           var h = window.innerHeight;

           if (isPortrait && w <= h || !isPortrait && w >= h) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           } else if (nIter === 50) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           }
         }, 20);
       },

       // Run on not mobile browser.
       _onResize: function _onResize() {
         this.emit('change', { isPortrait: this.isPortrait() });
       }
     };

     MicroEvent.mixin(obj);

     return obj;
   };

   var orientation = create()._init();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var softwareKeyboard = new MicroEvent();
   softwareKeyboard._visible = false;

   var onShow = function onShow() {
     softwareKeyboard._visible = true;
     softwareKeyboard.emit('show');
   };

   var onHide = function onHide() {
     softwareKeyboard._visible = false;
     softwareKeyboard.emit('hide');
   };

   var bindEvents = function bindEvents() {
     if (typeof Keyboard !== 'undefined') {
       // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
       Keyboard.onshow = onShow;
       Keyboard.onhide = onHide;
       softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

       return true;
     } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
       // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
       window.addEventListener('native.keyboardshow', onShow);
       window.addEventListener('native.keyboardhide', onHide);
       softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

       return true;
     }

     return false;
   };

   var noPluginError = function noPluginError() {
     console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
   };

   document.addEventListener('deviceready', function () {
     if (!bindEvents()) {
       if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
         noPluginError();
       }

       softwareKeyboard.on = noPluginError;
     }
   });

   var util$1 = {
     _ready: false,

     _domContentLoaded: false,

     _onDOMContentLoaded: function _onDOMContentLoaded() {
       util$1._domContentLoaded = true;

       if (platform.isWebView()) {
         window.document.addEventListener('deviceready', function () {
           util$1._ready = true;
         }, false);
       } else {
         util$1._ready = true;
       }
     },

     addBackButtonListener: function addBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.addEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.addEventListener('backbutton', fn, false);
         });
       }
     },

     removeBackButtonListener: function removeBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.removeEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.removeEventListener('backbutton', fn, false);
         });
       }
     }
   };
   window.addEventListener('DOMContentLoaded', function () {
     return util$1._onDOMContentLoaded();
   }, false);

   var HandlerRepository = {
     _store: {},

     _genId: function () {
       var i = 0;
       return function () {
         return i++;
       };
     }(),

     set: function set(element, handler) {
       if (element.dataset.deviceBackButtonHandlerId) {
         this.remove(element);
       }
       var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
       this._store[id] = handler;
     },

     remove: function remove(element) {
       if (element.dataset.deviceBackButtonHandlerId) {
         delete this._store[element.dataset.deviceBackButtonHandlerId];
         delete element.dataset.deviceBackButtonHandlerId;
       }
     },

     get: function get(element) {
       if (!element.dataset.deviceBackButtonHandlerId) {
         return undefined;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       if (!this._store[id]) {
         throw new Error();
       }

       return this._store[id];
     },

     has: function has(element) {
       if (!element.dataset) {
         return false;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       return !!this._store[id];
     }
   };

   var DeviceBackButtonDispatcher = function () {
     function DeviceBackButtonDispatcher() {
       babelHelpers.classCallCheck(this, DeviceBackButtonDispatcher);

       this._isEnabled = false;
       this._boundCallback = this._callback.bind(this);
     }

     /**
      * Enable to handle 'backbutton' events.
      */


     babelHelpers.createClass(DeviceBackButtonDispatcher, [{
       key: 'enable',
       value: function enable() {
         if (!this._isEnabled) {
           util$1.addBackButtonListener(this._boundCallback);
           this._isEnabled = true;
         }
       }

       /**
        * Disable to handle 'backbutton' events.
        */

     }, {
       key: 'disable',
       value: function disable() {
         if (this._isEnabled) {
           util$1.removeBackButtonListener(this._boundCallback);
           this._isEnabled = false;
         }
       }

       /**
        * Fire a 'backbutton' event manually.
        */

     }, {
       key: 'fireDeviceBackButtonEvent',
       value: function fireDeviceBackButtonEvent() {
         var event = document.createEvent('Event');
         event.initEvent('backbutton', true, true);
         document.dispatchEvent(event);
       }
     }, {
       key: '_callback',
       value: function _callback() {
         this._dispatchDeviceBackButtonEvent();
       }

       /**
        * @param {HTMLElement} element
        * @param {Function} callback
        */

     }, {
       key: 'createHandler',
       value: function createHandler(element, callback) {
         if (!(element instanceof HTMLElement)) {
           throw new Error('element must be an instance of HTMLElement');
         }

         if (!(callback instanceof Function)) {
           throw new Error('callback must be an instance of Function');
         }

         var handler = {
           _callback: callback,
           _element: element,

           disable: function disable() {
             HandlerRepository.remove(element);
           },

           setListener: function setListener(callback) {
             this._callback = callback;
           },

           enable: function enable() {
             HandlerRepository.set(element, this);
           },

           isEnabled: function isEnabled() {
             return HandlerRepository.get(element) === this;
           },

           destroy: function destroy() {
             HandlerRepository.remove(element);
             this._callback = this._element = null;
           }
         };

         handler.enable();

         return handler;
       }
     }, {
       key: '_dispatchDeviceBackButtonEvent',
       value: function _dispatchDeviceBackButtonEvent() {
         var tree = this._captureTree();

         var element = this._findHandlerLeafElement(tree);

         var handler = HandlerRepository.get(element);
         handler._callback(createEvent(element));

         function createEvent(element) {
           return {
             _element: element,
             callParentHandler: function callParentHandler() {
               var parent = this._element.parentNode;

               while (parent) {
                 handler = HandlerRepository.get(parent);
                 if (handler) {
                   return handler._callback(createEvent(parent));
                 }
                 parent = parent.parentNode;
               }
             }
           };
         }
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_captureTree',
       value: function _captureTree() {
         return createTree(document.body);

         function createTree(element) {
           return {
             element: element,
             children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

               if (childElement.style.display === 'none') {
                 return [];
               }

               if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
                 return [];
               }

               var result = createTree(childElement);

               if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
                 return [];
               }

               return [result];
             }))
           };
         }

         function arrayOf(target) {
           var result = [];
           for (var i = 0; i < target.length; i++) {
             result.push(target[i]);
           }
           return result;
         }
       }

       /**
        * @param {Object} tree
        * @return {HTMLElement}
        */

     }, {
       key: '_findHandlerLeafElement',
       value: function _findHandlerLeafElement(tree) {
         return find(tree);

         function find(node) {
           if (node.children.length === 0) {
             return node.element;
           }

           if (node.children.length === 1) {
             return find(node.children[0]);
           }

           return node.children.map(function (childNode) {
             return childNode.element;
           }).reduce(function (left, right) {
             if (!left) {
               return right;
             }

             var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
             var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

             if (!isNaN(leftZ) && !isNaN(rightZ)) {
               return leftZ > rightZ ? left : right;
             }

             throw new Error('Capturing backbutton-handler is failure.');
           }, null);
         }
       }
     }]);
     return DeviceBackButtonDispatcher;
   }();

   var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

   var autoStyleEnabled = true;

   // Modifiers
   var modifiersMap = {
     'quiet': 'material--flat',
     'light': 'material--flat',
     'outline': 'material--flat',
     'cta': '',
     'large--quiet': 'material--flat large',
     'large--cta': 'large',
     'noborder': '',
     'chevron': '',
     'tappable': ''
   };

   var platforms = {};

   platforms.android = function (element) {

     if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

       var oldModifier = element.getAttribute('modifier') || '';

       var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
         return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
       });
       newModifier.unshift('material');

       element.setAttribute('modifier', newModifier.join(' ').trim());
     }

     // Effects
     if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

       if (element.tagName.toLowerCase() === 'ons-list-item') {
         if (element.hasAttribute('tappable')) {
           element.setAttribute('ripple', '');
           element.removeAttribute('tappable');
         }
       } else {
         element.setAttribute('ripple', '');
       }
     }
   };

   platforms.ios = function (element) {

     // Modifiers
     if (/material/.test(element.getAttribute('modifier'))) {
       util.removeModifier(element, 'material');

       if (util.removeModifier(element, 'material--flat')) {
         util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
       }

       if (!element.getAttribute('modifier')) {
         element.removeAttribute('modifier');
       }
     }

     // Effects
     if (element.hasAttribute('ripple')) {
       if (element.tagName.toLowerCase() === 'ons-list-item') {
         element.setAttribute('tappable', '');
       }

       element.removeAttribute('ripple');
     }
   };

   var unlocked = {
     android: true
   };

   var prepareAutoStyle = function prepareAutoStyle(element, force) {
     if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
       var mobileOS = platform.getMobileOS();
       if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
         platforms[mobileOS](element);
       }
     }
   };

   var autoStyle = {
     isEnabled: function isEnabled() {
       return autoStyleEnabled;
     },
     enable: function enable() {
       return autoStyleEnabled = true;
     },
     disable: function disable() {
       return autoStyleEnabled = false;
     },
     prepare: prepareAutoStyle
   };

   var generateId = function () {
     var i = 0;
     return function () {
       return i++;
     };
   }();

   /**
    * Door locking system.
    *
    * @param {Object} [options]
    * @param {Function} [options.log]
    */

   var DoorLock = function () {
     function DoorLock() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, DoorLock);

       this._lockList = [];
       this._waitList = [];
       this._log = options.log || function () {};
     }

     /**
      * Register a lock.
      *
      * @return {Function} Callback for unlocking.
      */


     babelHelpers.createClass(DoorLock, [{
       key: 'lock',
       value: function lock() {
         var _this = this;

         var unlock = function unlock() {
           _this._unlock(unlock);
         };
         unlock.id = generateId();
         this._lockList.push(unlock);
         this._log('lock: ' + unlock.id);

         return unlock;
       }
     }, {
       key: '_unlock',
       value: function _unlock(fn) {
         var index = this._lockList.indexOf(fn);
         if (index === -1) {
           throw new Error('This function is not registered in the lock list.');
         }

         this._lockList.splice(index, 1);
         this._log('unlock: ' + fn.id);

         this._tryToFreeWaitList();
       }
     }, {
       key: '_tryToFreeWaitList',
       value: function _tryToFreeWaitList() {
         while (!this.isLocked() && this._waitList.length > 0) {
           this._waitList.shift()();
         }
       }

       /**
        * Register a callback for waiting unlocked door.
        *
        * @params {Function} callback Callback on unlocking the door completely.
        */

     }, {
       key: 'waitUnlock',
       value: function waitUnlock(callback) {
         if (!(callback instanceof Function)) {
           throw new Error('The callback param must be a function.');
         }

         if (this.isLocked()) {
           this._waitList.push(callback);
         } else {
           callback();
         }
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLocked',
       value: function isLocked() {
         return this._lockList.length > 0;
       }
     }]);
     return DoorLock;
   }();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */
   var readyMap = new WeakMap();
   var queueMap = new WeakMap();

   function isContentReady(element) {
     if (element.childNodes.length > 0) {
       setContentReady(element);
     }
     return readyMap.has(element);
   }

   function setContentReady(element) {
     readyMap.set(element, true);
   }

   function addCallback(element, fn) {
     if (!queueMap.has(element)) {
       queueMap.set(element, []);
     }
     queueMap.get(element).push(fn);
   }

   function consumeQueue(element) {
     var callbacks = queueMap.get(element, []) || [];
     queueMap.delete(element);
     callbacks.forEach(function (callback) {
       return callback();
     });
   }

   function contentReady(element, fn) {
     addCallback(element, fn);

     if (isContentReady(element)) {
       consumeQueue(element);
       return;
     }

     var observer = new MutationObserver(function (changes) {
       setContentReady(element);
       consumeQueue(element);
     });
     observer.observe(element, { childList: true, characterData: true });

     // failback for elements has empty content.
     setImmediate(function () {
       setContentReady(element);
       consumeQueue(element);
     });
   }

   /**
    * @object ons
    * @category util
    * @description
    *   [ja]Onsen UI[/ja]
    *   [en]A global object that's used in Onsen UI. [/en]
    */
   var ons = {};

   ons._util = util;
   ons._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
   ons._internal = internal;
   ons.GestureDetector = GestureDetector;
   ons.platform = platform;
   ons.softwareKeyboard = softwareKeyboard;
   ons.pageAttributeExpression = pageAttributeExpression;
   ons.orientation = orientation;
   ons.notification = notification;
   ons._animationOptionsParser = parse;
   ons._autoStyle = autoStyle;
   ons._DoorLock = DoorLock;
   ons._contentReady = contentReady;

   ons._readyLock = new DoorLock();

   ons.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

   waitDeviceReady();

   /**
    * @method isReady
    * @signature isReady()
    * @return {Boolean}
    *   [en]Will be true if Onsen UI is initialized.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Returns true if Onsen UI is initialized.[/en]
    *   [ja]Onsen UI[/ja]
    */
   ons.isReady = function () {
     return !ons._readyLock.isLocked();
   };

   /**
    * @method isWebView
    * @signature isWebView()
    * @return {Boolean}
    *   [en]Will be true if the app is running in Cordova.[/en]
    *   [ja]Cordovatrue[/ja]
    * @description
    *   [en]Returns true if running inside Cordova.[/en]
    *   [ja]Cordova[/ja]
    */
   ons.isWebView = ons.platform.isWebView;

   /**
    * @method ready
    * @signature ready(callback)
    * @description
    *   [ja]Onsen UI[/ja]
    *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
    * @param {Function} callback
    *   [en]Function that executes after Onsen UI has been initialized.[/en]
    *   [ja]Onsen UI[/ja]
    */
   ons.ready = function (callback) {
     if (ons.isReady()) {
       callback();
     } else {
       ons._readyLock.waitUnlock(callback);
     }
   };

   /**
    * @method setDefaultDeviceBackButtonListener
    * @signature setDefaultDeviceBackButtonListener(listener)
    * @param {Function} listener
    *   [en]Function that executes when device back button is pressed.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Set default handler for device back button.[/en]
    *   [ja][/ja]
    */
   ons.setDefaultDeviceBackButtonListener = function (listener) {
     ons._defaultDeviceBackButtonHandler.setListener(listener);
   };

   /**
    * @method disableDeviceBackButtonHandler
    * @signature disableDeviceBackButtonHandler()
    * @description
    * [en]Disable device back button event handler.[/en]
    * [ja][/ja]
    */
   ons.disableDeviceBackButtonHandler = function () {
     ons._deviceBackButtonDispatcher.disable();
   };

   /**
    * @method enableDeviceBackButtonHandler
    * @signature enableDeviceBackButtonHandler()
    * @description
    * [en]Enable device back button event handler.[/en]
    * [ja][/ja]
    */
   ons.enableDeviceBackButtonHandler = function () {
     ons._deviceBackButtonDispatcher.enable();
   };

   /**
    * @method enableAutoStatusBarFill
    * @signature enableAutoStatusBarFill()
    * @description
    *   [en]Enable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7[/ja]
    */
   ons.enableAutoStatusBarFill = function () {
     if (ons.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons._internal.config.autoStatusBarFill = true;
   };

   /**
    * @method disableAutoStatusBarFill
    * @signature disableAutoStatusBarFill()
    * @description
    *   [en]Disable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7[/ja]
    */
   ons.disableAutoStatusBarFill = function () {
     if (ons.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons._internal.config.autoStatusBarFill = false;
   };

   /**
    * @method disableAnimations
    * @signature disableAnimations()
    * @description
    *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
    *   [ja][/ja]
    */
   ons.disableAnimations = function () {
     ons._internal.config.animationsDisabled = true;
   };

   /**
    * @method enableAnimations
    * @signature enableAnimations()
    * @description
    *   [en]Enable animations (default).[/en]
    *   [ja][/ja]
    */
   ons.enableAnimations = function () {
     ons._internal.config.animationsDisabled = false;
   };

   /**
    * @method disableAutoStyling
    * @signature disableAutoStyling()
    * @description
    *   [en]Disable automatic styling.[/en]
    *   [ja][/ja]
    */
   ons.disableAutoStyling = ons._autoStyle.disable;

   /**
    * @method enableAutoStyling
    * @signature enableAutoStyling()
    * @description
    *   [en]Enable automatic styling based on OS (default).[/en]
    *   [ja][/ja]
    */
   ons.enableAutoStyling = ons._autoStyle.enable;

   /**
    * @method forcePlatformStyling
    * @signature forcePlatformStyling(platform)
    * @description
    *   [en]Refresh styling for the given platform.[/en]
    *   [ja][/ja]
    * @param {string} platform New platform to style the elements.
    */
   ons.forcePlatformStyling = function (newPlatform) {
     ons.enableAutoStyling();
     ons.platform.select(newPlatform || 'ios');

     ons._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
       if (element.tagName.toLowerCase() === 'ons-if') {
         element._platformUpdate();
       } else if (element.tagName.match(/^ons-/i)) {
         ons._autoStyle.prepare(element, true);
         if (element.tagName.toLowerCase() === 'ons-tabbar') {
           element._updatePosition();
         }
       }
     });
   };

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createPopoverOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var popover = div.querySelector('ons-popover');
       CustomElements.upgrade(popover);
       document.body.appendChild(popover);

       if (options.link instanceof Function) {
         options.link(popover);
       }

       return popover;
     });
   };

   /**
    * @method createPopover
    * @signature createPopover(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {Object} [options.parentScope]
    *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
    *   [ja]AngularJS[/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the popover component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a popover instance from a template.[/en]
    *   [ja][/ja]
    */
   ons.createPopover = ons._createPopoverOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var dialog = div.querySelector('ons-dialog');
       CustomElements.upgrade(dialog);
       document.body.appendChild(dialog);

       if (options.link instanceof Function) {
         options.link(dialog);
       }

       return dialog;
     });
   };

   /**
    * @method createDialog
    * @signature createDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the dialog component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a dialog instance from a template.[/en]
    *   [ja][/ja]
    */
   ons.createDialog = ons._createDialogOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createAlertDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var alertDialog = div.querySelector('ons-alert-dialog');
       CustomElements.upgrade(alertDialog);
       document.body.appendChild(alertDialog);

       if (options.link instanceof Function) {
         options.link(alertDialog);
       }

       return alertDialog;
     });
   };

   /**
    * @method createAlertDialog
    * @signature createAlertDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the alert dialog component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a alert dialog instance from a template.[/en]
    *   [ja][/ja]
    */
   ons.createAlertDialog = ons._createAlertDialogOriginal;

   /**
    * @param {String} page
    * @param {Function} link
    */
   ons._resolveLoadingPlaceholderOriginal = function (page, link) {
     var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

     if (elements.length > 0) {
       elements.filter(function (element) {
         return !element.getAttribute('page');
       }).forEach(function (element) {
         element.setAttribute('ons-loading-placeholder', page);
         ons._resolveLoadingPlaceholder(element, page, link);
       });
     } else {
       throw new Error('No ons-loading-placeholder exists.');
     }
   };

   /**
    * @method resolveLoadingPlaceholder
    * @signature resolveLoadingPlaceholder(page)
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @description
    *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
    *   [ja]ons-loading-placeholderons.resolveLoadingPlaceholder[/ja]
    */
   ons.resolveLoadingPlaceholder = ons._resolveLoadingPlaceholderOriginal;

   ons._setupLoadingPlaceHolders = function () {
     ons.ready(function () {
       var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

       elements.forEach(function (element) {
         var page = element.getAttribute('ons-loading-placeholder');
         if (typeof page === 'string') {
           ons._resolveLoadingPlaceholder(element, page);
         }
       });
     });
   };

   ons._resolveLoadingPlaceholder = function (element, page, link) {
     link = link || function (element, done) {
       done();
     };
     ons._internal.getPageHTMLAsync(page).then(function (html) {

       while (element.firstChild) {
         element.removeChild(element.firstChild);
       }

       var contentElement = ons._util.createElement('<div>' + html + '</div>');
       contentElement.style.display = 'none';

       element.appendChild(contentElement);

       link(contentElement, function () {
         contentElement.style.display = '';
       });
     }).catch(function (error) {
       throw new Error('Unabled to resolve placeholder: ' + error);
     });
   };

   function waitDeviceReady() {
     var unlockDeviceReady = ons._readyLock.lock();
     window.addEventListener('WebComponentsReady', function () {
       if (ons.isWebView()) {
         window.document.addEventListener('deviceready', unlockDeviceReady, false);
       } else {
         unlockDeviceReady();
       }
     }, false);
   }

   window._superSecretOns = ons;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   function getElementClass() {
     if (typeof HTMLElement !== 'function') {
       var _BaseElement = function _BaseElement() {};
       _BaseElement.prototype = document.createElement('div');
       return _BaseElement;
     } else {
       return HTMLElement;
     }
   }

   var BaseElement = function (_getElementClass) {
     babelHelpers.inherits(BaseElement, _getElementClass);

     function BaseElement() {
       babelHelpers.classCallCheck(this, BaseElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BaseElement).apply(this, arguments));
     }

     return BaseElement;
   }(getElementClass());

   /**
    * @element ons-template
    * @category template
    * @description
    *   [en]
    *     Define a separate HTML fragment and use as a template.
    *
    *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
    *   [/en]
    *   [ja]HTMLHTMLidpageURLons-navigator[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-navigator
    *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
    *   [ja][/ja]
    * @seealso ons-tabbar
    *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
    *   [ja][/ja]
    * @seealso ons-splitter
    *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
    *   [ja][/ja]
    * @example
    * <ons-template id="foobar.html">
    *   <ons-page>
    *     Page content
    *   </ons-page>
    * </ons-template>
    *
    * <ons-navigator page="foobar.html">
    * </ons-navigator>
    */

   var TemplateElement = function (_BaseElement) {
     babelHelpers.inherits(TemplateElement, _BaseElement);

     function TemplateElement() {
       babelHelpers.classCallCheck(this, TemplateElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TemplateElement).apply(this, arguments));
     }

     babelHelpers.createClass(TemplateElement, [{
       key: 'createdCallback',


       /**
        * @property template
        * @type {String}
        * @description
        *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
        *  [ja][/ja]
        */
       value: function createdCallback() {
         this.template = this.innerHTML;

         while (this.firstChild) {
           this.removeChild(this.firstChild);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
         event.template = this.template;
         event.templateId = this.getAttribute('id');

         this.dispatchEvent(event);
       }
     }]);
     return TemplateElement;
   }(BaseElement);

   window.OnsTemplateElement = document.registerElement('ons-template', {
     prototype: TemplateElement.prototype
   });

   /**
    * @element ons-if
    * @category conditional
    * @tutorial vanilla/Reference/if
    * @description
    *   [en]
    *     Conditionally display content depending on the platform, device orientation or both.
    *
    *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
    *   [/en]
    *   [ja][/ja]
    * @guide UtilityAPIs
    *   [en]Other utility APIs[/en]
    *   [ja]API[/ja]
    * @example
    * <ons-page>
    *   <ons-if orientation="landscape">
    *     Landscape view!
    *   </ons-if>
    *   <ons-if platform="android">
    *     This is Android.
    *   </ons-if>
    *   <ons-if platform="ios other">
    *     This is not Android.
    *   </ons-if>
    * </ons-page>
    */

   var ConditionalElement = function (_BaseElement) {
     babelHelpers.inherits(ConditionalElement, _BaseElement);

     function ConditionalElement() {
       babelHelpers.classCallCheck(this, ConditionalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ConditionalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ConditionalElement, [{
       key: 'createdCallback',


       /**
        * @attribute platform
        * @initonly
        * @type {string}
        * @description
        *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute orientation
        * @type {string}
        * @description
        *  [en]Either `"portrait"` or `"landscape"`.[/en]
        *  [ja]portraitlandscape[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (platform._renderPlatform !== null) {
             _this2._platformUpdate();
           } else if (!_this2._isAllowedPlatform()) {
             while (_this2.childNodes[0]) {
               _this2.childNodes[0].remove();
             }
             _this2._platformUpdate();
           }
         });

         this._onOrientationChange();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         orientation.on('change', this._onOrientationChange.bind(this));
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name) {
         if (name === 'orientation') {
           this._onOrientationChange();
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         orientation.off('change', this._onOrientationChange);
       }
     }, {
       key: '_platformUpdate',
       value: function _platformUpdate() {
         this.style.display = this._isAllowedPlatform() ? '' : 'none';
       }
     }, {
       key: '_isAllowedPlatform',
       value: function _isAllowedPlatform() {
         return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
       }
     }, {
       key: '_onOrientationChange',
       value: function _onOrientationChange() {
         if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
           var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
           var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

           this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
         }
       }
     }]);
     return ConditionalElement;
   }(BaseElement);

   window.OnsConditionalElement = document.registerElement('ons-if', {
     prototype: ConditionalElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var AlertDialogAnimator = function () {
     function AlertDialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, AlertDialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */


     babelHelpers.createClass(AlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return AlertDialogAnimator;
   }();

   /**
    * Android style animator for alert dialog.
    */
   var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
     babelHelpers.inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

     function AndroidAlertDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.2 : _ref2$duration;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       babelHelpers.classCallCheck(this, AndroidAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(AndroidAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidAlertDialogAnimator;
   }(AlertDialogAnimator);

   /**
    * iOS style animator for alert dialog.
    */
   var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
     babelHelpers.inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

     function IOSAlertDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       babelHelpers.classCallCheck(this, IOSAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /*
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSAlertDialogAnimator;
   }(AlertDialogAnimator);

   var scheme = {
     '.alert-dialog': 'alert-dialog--*',
     '.alert-dialog-container': 'alert-dialog-container--*',
     '.alert-dialog-title': 'alert-dialog-title--*',
     '.alert-dialog-content': 'alert-dialog-content--*',
     '.alert-dialog-footer': 'alert-dialog-footer--*',
     '.alert-dialog-button': 'alert-dialog-button--*',
     '.alert-dialog-footer--one': 'alert-dialog-footer--one--*',
     '.alert-dialog-button--one': 'alert-dialog-button--one--*',
     '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
     '.alert-dialog-mask': 'alert-dialog-mask--*'
   };

   var _animatorDict = {
     'none': AlertDialogAnimator,
     'default': function _default() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     }
   };

   /**
    * @element ons-alert-dialog
    * @category dialog
    * @description
    *   [en]
    *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
    *
    *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
    *   [/en]
    *   [ja][/ja]
    * @codepen Qwwxyp
    * @tutorial vanilla/Reference/dialog
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @guide UsingAlert
    *   [en]Learn how to use the alert dialog.[/en]
    *   [ja][/ja]
    * @seealso ons-dialog
    *   [en]ons-dialog component[/en]
    *   [ja]ons-dialog[/ja]
    * @seealso ons-popover
    *   [en]ons-popover component[/en]
    *   [ja]ons-dialog[/ja]
    * @seealso ons.notification
    *   [en]Using ons.notification utility functions.[/en]
    *   [ja]ons.notification[/ja]
    * @example
    * <ons-alert-dialog id="alert-dialog">
    *   <div class="alert-dialog-title">Warning!</div>
    *   <div class="alert-dialog-content">
    *     An error has occurred!
    *   </div>
    *   <div class="alert-dialog-footer">
    *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
    *   </div>
    * </ons-alert-dialog>
    * <script>
    *   document.getElementById('alert-dialog').show();
    * </script>
    */

   var AlertDialogElement = function (_BaseElement) {
     babelHelpers.inherits(AlertDialogElement, _BaseElement);

     function AlertDialogElement() {
       babelHelpers.classCallCheck(this, AlertDialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AlertDialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(AlertDialogElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           return _this2._compile();
         });

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._updateAnimatorFactory();
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict,
           baseClass: AlertDialogAnimator,
           baseClassName: 'AlertDialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.style.display = 'none';

         /**
          * Expected result after compile:
          *
          * <ons-alert-dialog style="none">
          *   <div class="alert-dialog-mask"></div>
          *   <div class="alert-dialog">
          *     <div class="alert-dialog-container">...</div>
          *   </div>
          * </ons-alert-dialog>
          */

         var content = document.createDocumentFragment();

         if (!this._mask && !this._dialog) {
           while (this.firstChild) {
             content.appendChild(this.firstChild);
           }
         }

         if (!this._mask) {
           var mask = document.createElement('div');
           mask.classList.add('alert-dialog-mask');
           this.insertBefore(mask, this.children[0]);
         }

         if (!this._dialog) {
           var dialog = document.createElement('div');
           dialog.classList.add('alert-dialog');
           this.insertBefore(dialog, null);
         }

         if (!util.findChild(this._dialog, '.alert-dialog-container')) {
           var container = document.createElement('div');
           container.classList.add('alert-dialog-container');
           this._dialog.appendChild(container);
         }

         this._dialog.children[0].appendChild(content);

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         if (this.getAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme);
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'show',


       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
        *   [ja]"fade", "none"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show the alert dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]A `Promise` object that resolves to the displayed element.[/en]
        *   [ja][/ja]
        */
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = function () {
             var tryShow = function tryShow() {
               var unlock = _this3._doorLock.lock();
               var animator = _this3._animatorFactory.newAnimator(options);

               _this3.style.display = 'block';
               _this3._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 contentReady(_this3, function () {
                   animator.show(_this3, function () {
                     _this3._visible = true;
                     unlock();

                     util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

                     callback();
                     resolve(_this3);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this3._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
        *   [ja]"fade", "none"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Hide the alert dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = function () {
             var tryHide = function tryHide() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 contentReady(_this4, function () {
                   animator.hide(_this4, function () {
                     _this4.style.display = 'none';
                     _this4._visible = false;
                     unlock();

                     util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

                     callback();
                     resolve(_this4);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           }();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this5 = this;

         if (this.cancelable && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this5._running = false;
               util.triggerElementEvent(_this5, 'dialog-cancel');
             }
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this6 = this;

         this.onDeviceBackButton = function (e) {
           return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
         };

         contentReady(this, function () {
           _this6._mask.addEventListener('click', _this6._boundCancel, false);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme);
         } else if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }
     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        *   [en]Fired just before the alert dialog is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from showing.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the alert dialog is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the alert dialog is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from hiding.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the alert dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]disabled[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
        *  [ja]"none""default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
        *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       /**
        * @return {Element}
        */
       get: function get() {
         return util.findChild(this, '.alert-dialog-mask');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.alert-dialog');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_titleElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-title');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-content');
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }
     }, {
       key: 'visible',
       get: function get() {
         return this._visible;
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }]);
     return AlertDialogElement;
   }(BaseElement);

   var OnsAlertDialogElement = window.OnsAlertDialogElement = document.registerElement('ons-alert-dialog', {
     prototype: AlertDialogElement.prototype
   });

   /**
    * @param {String} name
    * @param {DialogAnimator} Animator
    */
   OnsAlertDialogElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof AlertDialogAnimator)) {
       throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
     }
     _animatorDict[name] = Animator;
   };

   OnsAlertDialogElement.AlertDialogAnimator = AlertDialogAnimator;

   var scheme$1 = {
     '': 'back-button--*',
     '.back-button__icon': 'back-button--*__icon',
     '.back-button__label': 'back-button--*__label'
   };

   /**
    * @element ons-back-button
    * @category toolbar
    * @description
    *   [en]
    *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
    *
    *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
    *   [/en]
    *   [ja][/ja]
    * @codepen aHmGL
    * @tutorial vanilla/Reference/navigator
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar
    *   [en]ons-toolbar component[/en]
    *   [ja]ons-toolbar[/ja]
    * @seealso ons-navigator
    *   [en]ons-navigator component[/en]
    *   [ja]ons-navigator[/ja]
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @guide Returningfromapage
    *   [en]Returning from a page[/en]
    *   [ja][/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left">
    *     <ons-back-button>Back</ons-back-button>
    *   </div>
    *   <div class="center">
    *     Title
    *   <div>
    * </ons-toolbar>
    */

   var BackButtonElement = function (_BaseElement) {
     babelHelpers.inherits(BackButtonElement, _BaseElement);

     function BackButtonElement() {
       babelHelpers.classCallCheck(this, BackButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BackButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(BackButtonElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the back button.[/en]
        *  [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }
         });

         this._options = {};
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('back-button');

         if (!util.findChild(this, '.back-button__label')) {
           var label = util.create('span.back-button__label');

           while (this.childNodes[0]) {
             label.appendChild(this.childNodes[0]);
           }
           this.appendChild(label);
         }

         if (!util.findChild(this, '.back-button__icon')) {
           var icon = util.create('span.back-button__icon');

           this.insertBefore(icon, this.children[0]);
         }

         ModifierUtil.initModifier(this, scheme$1);

         this.setAttribute('_compiled', '');
       }

       /**
        * @property options
        * @type {Object}
        * @description
        *   [en]Options object.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animation
        * @type {String}
        * @description
        *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
        *     These are platform based animations. For fixed animations, add "-ios" or "-md"
        *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animationOptions
        * @type {String}
        * @description
        *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        */

       /**
        * @property options.callback
        * @type {String}
        * @description
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.refresh
        * @description
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPagetrue[/ja]
        */

     }, {
       key: '_onClick',


       /**
        * @property onClick
        * @type {Function}
        * @description
        *   [en]Used to override the default back button behavior.[/en]
        *   [ja][/ja]
        */
       value: function _onClick() {
         if (this.onClick) {
           this.onClick.apply(this);
         } else {
           var navigator = util.findParent(this, 'ons-navigator');
           if (navigator) {
             navigator.popPage(this.options);
           }
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$1);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'show',
       value: function show() {
         this.style.display = 'inline-block';
       }
     }, {
       key: 'hide',
       value: function hide() {
         this.style.display = 'none';
       }
     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }]);
     return BackButtonElement;
   }(BaseElement);

   window.OnsBackButtonElement = document.registerElement('ons-back-button', {
     prototype: BackButtonElement.prototype
   });

   var scheme$2 = { '': 'bottom-bar--*' };

   /**
    * @element ons-bottom-toolbar
    * @category toolbar
    * @description
    *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
    *   [ja][/ja]
    * @modifier transparent
    *   [en]Make the toolbar transparent.[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbar[/ja]
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @example
    * <ons-bottom-toolbar>
    *   Content
    * </ons-bottom-toolbar>
    */

   var BottomToolbarElement = function (_BaseElement) {
     babelHelpers.inherits(BottomToolbarElement, _BaseElement);

     function BottomToolbarElement() {
       babelHelpers.classCallCheck(this, BottomToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BottomToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(BottomToolbarElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this.classList.add('bottom-bar');

         ModifierUtil.initModifier(this, scheme$2);

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this2._tryToEnsureNodePosition();
         });
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this3._tryToEnsureNodePosition();
         });
       }
     }, {
       key: '_tryToEnsureNodePosition',
       value: function _tryToEnsureNodePosition() {
         var page = util.findParent(this, 'ons-page');

         if (page && page !== this.parentNode) {
           page._registerBottomToolbar(this);
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$2);
         }
       }
     }]);
     return BottomToolbarElement;
   }(BaseElement);

   window.OnsBottomToolbarElement = document.registerElement('ons-bottom-toolbar', {
     prototype: BottomToolbarElement.prototype
   });

   var scheme$3 = { '': 'button--*' };

   /**
    * @element ons-button
    * @category button
    * @modifier outline
    *   [en]Button with outline and transparent background[/en]
    *   [ja][/ja]
    * @modifier light
    *   [en]Button that doesn't stand out.[/en]
    *   [ja][/ja]
    * @modifier quiet
    *   [en]Button with no outline and or background..[/en]
    *   [ja][/ja]
    * @modifier cta
    *   [en]Button that really stands out.[/en]
    *   [ja][/ja]
    * @modifier large
    *   [en]Large button that covers the width of the screen.[/en]
    *   [ja][/ja]
    * @modifier large--quiet
    *   [en]Large quiet button.[/en]
    *   [ja]quiet[/ja]
    * @modifier large--cta
    *   [en]Large call to action button.[/en]
    *   [ja]cta[/ja]
    * @modifier material
    *   [en]Material Design button[/en]
    *   [ja][/ja]
    * @modifier material--flat
    *   [en]Material Design flat button[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
    *
    *     Will automatically display as a Material Design button with a ripple effect on Android.
    *   [/en]
    *   [ja]ons-toolbar-buttonons-back-button[/ja]
    * @codepen hLayx
    * @tutorial vanilla/Reference/button
    * @guide Button [en]Guide for `<ons-button>`[/en][ja]<ons-button>[/ja]
    * @guide OverridingCSSstyles [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @example
    * <ons-button modifier="large--cta">
    *   Tap Me
    * </ons-button>
    */

   var ButtonElement = function (_BaseElement) {
     babelHelpers.inherits(ButtonElement, _BaseElement);

     function ButtonElement() {
       babelHelpers.classCallCheck(this, ButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ButtonElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute ripple
        * @description
        *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$3);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the button is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('button');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$3);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return ButtonElement;
   }(BaseElement);

   window.OnsButtonElement = document.registerElement('ons-button', {
     prototype: ButtonElement.prototype
   });

   var scheme$4 = { '': 'carousel-item--*' };

   /**
    * @element ons-carousel-item
    * @category carousel
    * @description
    *   [en]
    *     Carousel item component. Used as a child of the `<ons-carousel>` element.
    *   [/en]
    *   [ja][/ja]
    * @codepen xbbzOQ
    * @tutorial vanilla/Reference/carousel
    * @seealso ons-carousel
    *   [en]`<ons-carousel>` components[/en]
    *   [ja]<ons-carousel>[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselItemElement = function (_BaseElement) {
     babelHelpers.inherits(CarouselItemElement, _BaseElement);

     function CarouselItemElement() {
       babelHelpers.classCallCheck(this, CarouselItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselItemElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this.style.width = '100%';
         ModifierUtil.initModifier(this, scheme$4);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$4);
         }
       }
     }]);
     return CarouselItemElement;
   }(BaseElement);

   window.OnsCarouselItemElement = document.registerElement('ons-carousel-item', {
     prototype: CarouselItemElement.prototype
   });

   var VerticalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaY;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityY;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().height;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(0px, ' + -scroll + 'px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.centered) {
         var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
         this._offset = -(height - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.height = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   var HorizontalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaX;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityX;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().width;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(' + -scroll + 'px, 0px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.centered) {
         var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
         this._offset = -(width - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.width = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   /**
    * @element ons-carousel
    * @category carousel
    * @description
    *   [en]
    *     Carousel component. A carousel can be used to display several items in the same space.
    *
    *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
    *   [/en]
    *   [ja][/ja]
    * @codepen xbbzOQ
    * @tutorial vanilla/Reference/carousel
    * @seealso ons-carousel-item
    *   [en]`<ons-carousel-item>` component[/en]
    *   [ja]ons-carousel-item[/ja]
    * @guide UsingCarousel
    *   [en]Learn how to use the carousel component.[/en]
    *   [ja]carousel[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselElement = function (_BaseElement) {
     babelHelpers.inherits(CarouselElement, _BaseElement);

     function CarouselElement() {
       babelHelpers.classCallCheck(this, CarouselElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselElement, [{
       key: 'createdCallback',


       /**
        * @event postchange
        * @description
        *   [en]Fired just after the current carousel item has changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]Carousel[/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja][/ja]
        * @param {Number} event.lastActiveIndex
        *   [en]Previous active index.[/en]
        *   [ja][/ja]
        */

       /**
        * @event refresh
        * @description
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]Carousel[/ja]
        */

       /**
        * @event overscroll
        * @description
        *   [en]Fired when the carousel has been overscrolled.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja][/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja][/ja]
        * @param {String} event.direction
        *   [en]Can be one of either "up", "down", "left" or "right".[/en]
        *   [ja]"up", "down", "left", "right"[/ja]
        * @param {Function} event.waitToReturn
        *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
        *   [ja]PromisePromiseresolvereject[/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
        *   [ja]"horizontal""vertical""horizontal"[/ja]
        */

       /**
        * @attribute fullscreen
        * @description
        *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
        *   [ja]absolute[/ja]
        */

       /**
        * @attribute overscrollable
        * @description
        *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute centered
        * @description
        *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
        *   [ja]ons-carousel-item[/ja]
        */

       /**
        * @attribute item-width
        * @type {String}
        * @description
        *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
        *    [ja]ons-carousel-itemdirection"horizontal"[/ja]
        */

       /**
        * @attribute item-height
        * @type {String}
        * @description
        *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
        *   [ja]ons-carousel-itemdirection"vertical"[/ja]
        */

       /**
        * @attribute auto-scroll
        * @description
        *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
        *   [ja]carousel-item[/ja]
        */

       /**
        * @attribute auto-scroll-ratio
        * @type {Number}
        * @description
        *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
        *    [ja]0.01.0[/ja]
        */

       /**
        * @attribute swipeable
        * @description
        *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the carousel is disabled.[/en]
        *   [ja]dragtouchswipe[/ja]
        */

       /**
        * @attribute initial-index
        * @initonly
        * @type {Number}
        * @description
        *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
        *   [ja]ons-carousel-item0 0 [/ja]
        */

       /**
        * @attribute auto-refresh
        * @description
        *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *   [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       value: function createdCallback() {
         this._doorLock = new DoorLock();
         this._scroll = 0;
         this._offset = 0;
         this._lastActiveIndex = 0;

         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnResize = this._onResize.bind(this);

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
       }
     }, {
       key: '_onResize',
       value: function _onResize() {
         var i = this._scroll / this._currentElementSize;
         delete this._currentElementSize;
         this.setActiveIndex(i);
       }
     }, {
       key: '_onDirectionChange',
       value: function _onDirectionChange() {
         if (this._isVertical()) {
           this.style.overflowX = 'auto';
           this.style.overflowY = '';
         } else {
           this.style.overflowX = '';
           this.style.overflowY = 'auto';
         }

         this.refresh();
       }
     }, {
       key: '_saveLastState',
       value: function _saveLastState() {
         this._lastState = {
           elementSize: this._getCarouselItemSize(),
           carouselElementCount: this.itemCount,
           width: this._getCarouselItemSize() * this.itemCount
         };
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getCarouselItemSize',
       value: function _getCarouselItemSize() {
         var sizeAttr = this._getCarouselItemSizeAttr();
         var sizeInfo = this._decomposeSizeString(sizeAttr);
         var elementSize = this._getElementSize();

         if (sizeInfo.unit === '%') {
           return Math.round(sizeInfo.number / 100 * elementSize);
         } else if (sizeInfo.unit === 'px') {
           return sizeInfo.number;
         } else {
           throw new Error('Invalid state');
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getInitialIndex',
       value: function _getInitialIndex() {
         var index = parseInt(this.getAttribute('initial-index'), 10);

         if (typeof index === 'number' && !isNaN(index)) {
           return Math.max(Math.min(index, this.itemCount - 1), 0);
         } else {
           return 0;
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: '_getCarouselItemSizeAttr',
       value: function _getCarouselItemSizeAttr() {
         var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
         var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

         return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_decomposeSizeString',
       value: function _decomposeSizeString(size) {
         var matches = size.match(/^(\d+)(px|%)/);

         return {
           number: parseInt(matches[1], 10),
           unit: matches[2]
         };
       }
     }, {
       key: '_setupInitialIndex',
       value: function _setupInitialIndex() {
         this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
         this._lastActiveIndex = this._getInitialIndex();
         this._scrollTo(this._scroll);
       }

       /**
        * @method setActiveIndex
        * @signature setActiveIndex(index, [options])
        * @param {Number} index
        *   [en]The index that the carousel should be set to.[/en]
        *   [ja]carousel[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be called after the animation is finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
        *   [ja]ons-carousel-itemindex[/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveIndex',
       value: function setActiveIndex(index) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

         index = Math.max(0, Math.min(index, this.itemCount - 1));
         var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
         var max = this._calculateMaxScroll();

         this._scroll = Math.max(0, Math.min(max, scroll));
         return this._scrollTo(this._scroll, options).then(function () {
           _this2._tryFirePostChangeEvent();
           return _this2;
         });
       }

       /**
        * @method getActiveIndex
        * @signature getActiveIndex()
        * @return {Number}
        *   [en]The current carousel item index.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'getActiveIndex',
       value: function getActiveIndex() {
         var scroll = this._scroll - (this._offset || 0);
         var count = this.itemCount;
         var size = this._getCarouselItemSize();

         if (scroll < 0) {
           return 0;
         }

         var i = void 0;
         for (i = 0; i < count; i++) {
           if (size * i <= scroll && size * (i + 1) > scroll) {
             return i;
           }
         }

         // max carousel index
         return i;
       }

       /**
        * @method next
        * @signature next([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show next `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'next',
       value: function next(options) {
         return this.setActiveIndex(this.getActiveIndex() + 1, options);
       }

       /**
        * @method prev
        * @signature prev([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show previous `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'prev',
       value: function prev(options) {
         return this.setActiveIndex(this.getActiveIndex() - 1, options);
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isEnabledChangeEvent',
       value: function _isEnabledChangeEvent() {
         var elementSize = this._getElementSize();
         var carouselItemSize = this._getCarouselItemSize();

         return this.autoScroll && elementSize === carouselItemSize;
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isVertical',
       value: function _isVertical() {
         return this.getAttribute('direction') === 'vertical';
       }
     }, {
       key: '_prepareEventListeners',
       value: function _prepareEventListeners() {
         var _this3 = this;

         this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1 });
         this._mutationObserver = new MutationObserver(function () {
           return _this3.refresh();
         });

         this._updateSwipeable();
         this._updateAutoRefresh();

         window.addEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._gestureDetector.dispose();
         this._gestureDetector = null;

         this._mutationObserver.disconnect();
         this._mutationObserver = null;

         window.removeEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         if (this._gestureDetector) {
           if (this.swipeable) {
             this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.on('dragend', this._boundOnDragEnd);
           } else {
             this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.off('dragend', this._boundOnDragEnd);
           }
         }
       }
     }, {
       key: '_updateAutoRefresh',
       value: function _updateAutoRefresh() {
         if (this._mutationObserver) {
           if (this.hasAttribute('auto-refresh')) {
             this._mutationObserver.observe(this, { childList: true });
           } else {
             this._mutationObserver.disconnect();
           }
         }
       }
     }, {
       key: '_tryFirePostChangeEvent',
       value: function _tryFirePostChangeEvent() {
         var currentIndex = this.getActiveIndex();

         if (this._lastActiveIndex !== currentIndex) {
           var lastActiveIndex = this._lastActiveIndex;
           this._lastActiveIndex = currentIndex;

           util.triggerElementEvent(this, 'postchange', {
             carousel: this,
             activeIndex: currentIndex,
             lastActiveIndex: lastActiveIndex
           });
         }
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var direction = event.gesture.direction;
         if (this._isVertical() && (direction === 'left' || direction === 'right') || !this._isVertical() && (direction === 'up' || direction === 'down')) {
           return;
         }

         event.stopPropagation();

         this._lastDragEvent = event;

         var scroll = this._scroll - this._getScrollDelta(event);
         this._scrollTo(scroll);
         event.gesture.preventDefault();

         this._tryFirePostChangeEvent();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var _this4 = this;

         this._currentElementSize = undefined;

         this._scroll = this._scroll - this._getScrollDelta(event);

         if (this._getScrollDelta(event) !== 0) {
           event.stopPropagation();
         }

         if (this._isOverScroll(this._scroll)) {
           var waitForAction = false;
           util.triggerElementEvent(this, 'overscroll', {
             carousel: this,
             activeIndex: this.getActiveIndex(),
             direction: this._getOverScrollDirection(),
             waitToReturn: function waitToReturn(promise) {
               waitForAction = true;
               promise.then(function () {
                 return _this4._scrollToKillOverScroll();
               });
             }
           });

           if (!waitForAction) {
             this._scrollToKillOverScroll();
           }
         } else {
           this._startMomentumScroll();
         }
         this._lastDragEvent = null;

         event.gesture.preventDefault();
       }

       /**
        * @param {Object} trait
        */

     }, {
       key: '_mixin',
       value: function _mixin(trait) {
         Object.keys(trait).forEach(function (key) {
           this[key] = trait[key];
         }.bind(this));
       }
     }, {
       key: '_startMomentumScroll',
       value: function _startMomentumScroll() {
         if (this._lastDragEvent) {
           var velocity = this._getScrollVelocity(this._lastDragEvent);
           var duration = 0.3;
           var scrollDelta = duration * 100 * velocity;
           var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

           this._scroll = scroll;

           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(this._scroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
         }
       }
     }, {
       key: '_normalizeScrollPosition',
       value: function _normalizeScrollPosition(scroll) {
         var max = this._calculateMaxScroll();

         if (!this.autoScroll) {
           return Math.max(0, Math.min(max, scroll));
         }
         var arr = [];
         var size = this._getCarouselItemSize();
         var nbrOfItems = this.itemCount;

         for (var i = 0; i < nbrOfItems; i++) {
           if (i * size + this._offset < max) {
             arr.push(i * size + this._offset);
           }
         }
         arr.push(max);

         arr.sort(function (left, right) {
           left = Math.abs(left - scroll);
           right = Math.abs(right - scroll);

           return left - right;
         });

         arr = arr.filter(function (item, pos) {
           return !pos || item != arr[pos - 1];
         });

         var lastScroll = this._lastActiveIndex * size + this._offset;
         var scrollRatio = Math.abs(scroll - lastScroll) / size;
         var result = arr[0];

         if (scrollRatio <= this.autoScrollRatio) {
           result = lastScroll;
         } else if (scrollRatio < 1.0) {
           if (arr[0] === lastScroll && arr.length > 1) {
             result = arr[1];
           }
         }

         return Math.max(0, Math.min(max, result));
       }

       /**
        * @return {Array}
        */

     }, {
       key: '_getCarouselItemElements',
       value: function _getCarouselItemElements() {
         return util.arrayFrom(this.children).filter(function (child) {
           return child.nodeName.toLowerCase() === 'ons-carousel-item';
         });
       }

       /**
        * @param {Number} scroll
        * @param {Object} [options]
        * @return {Promise} Resolves to the carousel element
        */

     }, {
       key: '_scrollTo',
       value: function _scrollTo(scroll) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isOverscrollable = this.overscrollable;

         var normalizeScroll = function normalizeScroll(scroll) {
           var ratio = 0.35;

           if (scroll < 0) {
             return isOverscrollable ? Math.round(scroll * ratio) : 0;
           }

           var maxScroll = _this5._calculateMaxScroll();
           if (maxScroll < scroll) {
             return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
           }

           return scroll;
         };

         return new Promise(function (resolve) {
           animit(_this5._getCarouselItemElements()).queue({
             transform: _this5._generateScrollTransform(normalizeScroll(scroll))
           }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
             if (options.callback instanceof Function) {
               options.callback();
             }
             resolve();
           });
         });
       }
     }, {
       key: '_calculateMaxScroll',
       value: function _calculateMaxScroll() {
         var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
         return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
       }
     }, {
       key: '_isOverScroll',
       value: function _isOverScroll(scroll) {
         if (scroll < 0 || scroll > this._calculateMaxScroll()) {
           return true;
         }
         return false;
       }
     }, {
       key: '_getOverScrollDirection',
       value: function _getOverScrollDirection() {
         if (this._isVertical()) {
           return this._scroll <= 0 ? 'up' : 'down';
         } else {
           return this._scroll <= 0 ? 'left' : 'right';
         }
       }
     }, {
       key: '_scrollToKillOverScroll',
       value: function _scrollToKillOverScroll() {
         var duration = 0.4;

         if (this._scroll < 0) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(0)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
           this._scroll = 0;
           return;
         }

         var maxScroll = this._calculateMaxScroll();

         if (maxScroll < this._scroll) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(maxScroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
           this._scroll = maxScroll;
           return;
         }

         return;
       }

       /**
        * @property itemCount
        * @readonly
        * @type {Number}
        * @description
        *   [en]The number of carousel items.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'refresh',


       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
        *   [ja]ons-carousel-itemons-carousel[/ja]
        */
       value: function refresh() {
         // Bug fix
         if (this._getCarouselItemSize() === 0) {
           return;
         }

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
         this._setup();

         if (this._lastState && this._lastState.width > 0) {
           var scroll = this._scroll; // - this._offset;

           if (this._isOverScroll(scroll)) {
             this._scrollToKillOverScroll();
           } else {
             if (this.autoScroll) {
               scroll = this._normalizeScrollPosition(scroll);
             }

             this._scrollTo(scroll);
           }
         }

         this._saveLastState();

         util.triggerElementEvent(this, 'refresh', { carousel: this });
       }

       /**
        * @method first
        * @signature first()
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show first `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'first',
       value: function first(options) {
         return this.setActiveIndex(0, options);
       }

       /**
        * @method last
        * @signature last()
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja]Resolves to the carousel element[/ja]
        * @description
        *   [en]Show last ons-carousel item.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'last',
       value: function last(options) {
         this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this6 = this;

         this._prepareEventListeners();

         this._setup();
         this._setupInitialIndex();

         this._saveLastState();

         // Fix rendering glitch on Android 4.1
         if (this.offsetHeight === 0) {
           setImmediate(function () {
             return _this6.refresh();
           });
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'swipeable':
             this._updateSwipeable();
             break;
           case 'auto-refresh':
             this._updateAutoRefresh();
             break;
           case 'direction':
             this._onDirectionChange();
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._removeEventListeners();
       }

       /**
        * @property autoScrollRatio
        * @type {Number}
        * @description
        *   [en]The current auto scroll ratio. [/en]
        *   [ja]ratio[/ja]
        */

     }, {
       key: 'itemCount',
       get: function get() {
         return this._getCarouselItemElements().length;
       }
     }, {
       key: 'autoScrollRatio',
       get: function get() {
         var attr = this.getAttribute('auto-scroll-ratio');

         if (!attr) {
           return 0.5;
         }

         var scrollRatio = parseFloat(attr);
         if (scrollRatio < 0.0 || scrollRatio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         return isNaN(scrollRatio) ? 0.5 : scrollRatio;
       },
       set: function set(ratio) {
         if (ratio < 0.0 || ratio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         this.setAttribute('auto-scroll-ratio', ratio);
       }

       /**
        * @property swipeable
        * @type {Boolean}
        * @description
        *   [en]true if the carousel is swipeable.[/en]
        *   [ja]swipeabletrue[/ja]
        */

     }, {
       key: 'swipeable',
       get: function get() {
         return this.hasAttribute('swipeable');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'swipeable', value);
       }

       /**
        * @property autoScroll
        * @type {Boolean}
        * @description
        *   [en]true if auto scroll is enabled.[/en]
        *   [ja]true[/ja]
        */

     }, {
       key: 'autoScroll',
       get: function get() {
         return this.hasAttribute('auto-scroll');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'auto-scroll', value);
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       get: function get() {
         return this.hasAttribute('disabled');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       }

       /**
        * @property overscrollable
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is overscrollable or not.[/en]
        *   [ja]overscrolltrue[/ja]
        */

     }, {
       key: 'overscrollable',
       get: function get() {
         return this.hasAttribute('overscrollable');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'overscrollable', value);
       }

       /**
        * @property centered
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is centered or not.[/en]
        *   [ja]centeredtrue[/ja]
        */

     }, {
       key: 'centered',
       get: function get() {
         return this.hasAttribute('centered');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'centered', value);
       }
     }]);
     return CarouselElement;
   }(BaseElement);

   window.OnsCarouselElement = document.registerElement('ons-carousel', {
     prototype: CarouselElement.prototype
   });

   /**
    * @element ons-col
    * @category grid
    * @description
    *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
    *   [ja]ons-row[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
    *   [ja]Android 4.3iOS 6OSons-rowons-column[/ja]
    * @codepen GgujC {wide}
    * @guide layouting [en]Layouting guide[/en][ja][/ja]
    * @seealso ons-row
    *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
    *   [ja]ons-row[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
    *   [ja]"top", "center", "bottom"[/ja]
    */

   /**
    * @attribute width
    * @type {String}
    * @description
    *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
    *   [ja]10%50px[/ja]
    */

   var ColumnElement = function (_BaseElement) {
     babelHelpers.inherits(ColumnElement, _BaseElement);

     function ColumnElement() {
       babelHelpers.classCallCheck(this, ColumnElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ColumnElement).apply(this, arguments));
     }

     babelHelpers.createClass(ColumnElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (this.getAttribute('width')) {
           this._updateWidth();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'width') {
           this._updateWidth();
         }
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         var width = this.getAttribute('width');
         if (typeof width === 'string') {
           width = ('' + width).trim();
           width = width.match(/^\d+$/) ? width + '%' : width;

           this.style.webkitBoxFlex = '0';
           this.style.webkitFlex = '0 0 ' + width;
           this.style.mozBoxFlex = '0';
           this.style.mozFlex = '0 0 ' + width;
           this.style.msFlex = '0 0 ' + width;
           this.style.flex = '0 0 ' + width;
           this.style.maxWidth = width;
         }
       }
     }]);
     return ColumnElement;
   }(BaseElement);

   window.OnsColElement = document.registerElement('ons-col', {
     prototype: ColumnElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var DialogAnimator = function () {
     function DialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, DialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */


     babelHelpers.createClass(DialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return DialogAnimator;
   }();

   /**
    * Android style animator for dialog.
    */
   var AndroidDialogAnimator = function (_DialogAnimator) {
     babelHelpers.inherits(AndroidDialogAnimator, _DialogAnimator);

     function AndroidDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;
       babelHelpers.classCallCheck(this, AndroidDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(AndroidDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidDialogAnimator;
   }(DialogAnimator);

   /**
    * iOS style animator for dialog.
    */
   var IOSDialogAnimator = function (_DialogAnimator2) {
     babelHelpers.inherits(IOSDialogAnimator, _DialogAnimator2);

     function IOSDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;
       babelHelpers.classCallCheck(this, IOSDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSDialogAnimator;
   }(DialogAnimator);

   /**
    * Slide animator for dialog.
    */
   var SlideDialogAnimator = function (_DialogAnimator3) {
     babelHelpers.inherits(SlideDialogAnimator, _DialogAnimator3);

     function SlideDialogAnimator() {
       var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref4$timing = _ref4.timing;
       var timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing;
       var _ref4$delay = _ref4.delay;
       var delay = _ref4$delay === undefined ? 0 : _ref4$delay;
       var _ref4$duration = _ref4.duration;
       var duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;
       babelHelpers.classCallCheck(this, SlideDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SlideDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(SlideDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return SlideDialogAnimator;
   }(DialogAnimator);

   var scheme$5 = {
     '.dialog': 'dialog--*',
     '.dialog-container': 'dialog-container--*',
     '.dialog-mask': 'dialog-mask--*'
   };

   var _animatorDict$1 = {
     'default': function _default() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'slide': SlideDialogAnimator,
     'none': DialogAnimator
   };

   /**
    * @element ons-dialog
    * @category dialog
    * @description
    *   [en]
    *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
    *
    *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `<ons.createDialog(template)` utility function and the `<ons-template>` tag.
    *
    *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
    *
    *     It will automatically be displayed as Material Design when running on an Android device.
    *   [/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Display a Material Design dialog.[/en]
    *   [ja][/ja]
    * @codepen zxxaGa
    * @tutorial vanilla/Reference/dialog
    * @guide UsingDialog
    *   [en]Learn how to use the dialog component.[/en]
    *   [ja][/ja]
    * @seealso ons-alert-dialog
    *   [en]`<ons-alert-dialog>` component[/en]
    *   [ja]ons-alert-dialog[/ja]
    * @seealso ons-popover
    *   [en]`<ons-popover>` component[/en]
    *   [ja]ons-popover[/ja]
    * @example
    * <ons-dialog id="dialog">
    *   <p>This is a dialog!</p>
    * </ons-dialog>
    *
    * <script>
    *   document.getElementById('dialog').show();
    * </script>
    */

   var DialogElement = function (_BaseElement) {
     babelHelpers.inherits(DialogElement, _BaseElement);

     function DialogElement() {
       babelHelpers.classCallCheck(this, DialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(DialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(DialogElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           return _this2._compile();
         });

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._updateAnimatorFactory();
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$1,
           baseClass: DialogAnimator,
           baseClassName: 'DialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.style.display = 'none';

         /* Expected result:
          *   <ons-dialog>
          *     <div class="dialog-mask"></div>
          *     <div class="dialog">
          *       <div class="dialog-container">...</div>
          *     </div>
          *   </ons-dialog>
          */

         if (!this._dialog) {
           var dialog = document.createElement('div');
           dialog.classList.add('dialog');

           var container = document.createElement('div');
           dialog.classList.add('dialog-container');

           dialog.appendChild(container);

           while (this.firstChild) {
             container.appendChild(this.firstChild);
           }

           this.appendChild(dialog);
         }

         if (!this._mask) {
           var mask = document.createElement('div');
           mask.classList.add('dialog-mask');
           this.insertBefore(mask, this.firstChild);
         }

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         this.setAttribute('status-bar-fill', '');

         ModifierUtil.initModifier(this, scheme$5);
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this3 = this;

         if (this.cancelable && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this3._running = false;
               util.triggerElementEvent(_this3, 'dialog-cancel');
             }
           });
         }
       }

       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
        *   [ja]"none", "fade", "slide"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the dialog has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *  [en]Show the dialog.[/en]
        *  [ja][/ja]
        * @return {Promise} Resolves to the displayed element.
        */

     }, {
       key: 'show',
       value: function show() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           dialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = function () {
             var tryShow = function tryShow() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               _this4.style.display = 'block';
               _this4._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 contentReady(_this4, function () {
                   animator.show(_this4, function () {
                     _this4._visible = true;
                     unlock();

                     util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

                     callback();
                     resolve(_this4);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
        *   [ja]"none", "fade", "slide"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the dialog has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Hide the dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this5 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           dialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = function () {
             var tryHide = function tryHide() {
               var unlock = _this5._doorLock.lock();
               var animator = _this5._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 contentReady(_this5, function () {
                   animator.hide(_this5, function () {
                     _this5.style.display = 'none';
                     _this5._visible = false;
                     unlock();

                     util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

                     callback();
                     resolve(_this5);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this5._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           }();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this6 = this;

         this.onDeviceBackButton = function (e) {
           return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
         };

         contentReady(this, function () {
           _this6._mask.addEventListener('click', _this6._boundCancel, false);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
         } else if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }
     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        * [en]Fired just before the dialog is displayed.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        * [en]Fired just after the dialog is displayed.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        * [en]Fired just before the dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]disabled[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
        *  [ja]"none""default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
        *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       get: function get() {
         return util.findChild(this, '.dialog-mask');
       }
     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.dialog');
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }, {
       key: 'visible',
       get: function get() {
         return this._visible;
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }
     }]);
     return DialogElement;
   }(BaseElement);

   var OnsDialogElement = window.OnsDialogElement = document.registerElement('ons-dialog', {
     prototype: DialogElement.prototype
   });

   /**
    * @param {String} name
    * @param {DialogAnimator} Animator
    */
   OnsDialogElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof DialogAnimator)) {
       throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
     }
     _animatorDict$1[name] = Animator;
   };

   OnsDialogElement.DialogAnimator = DialogAnimator;

   var scheme$6 = {
     '': 'fab--*'
   };

   /**
    * @element ons-fab
    * @category fab
    * @description
    *   [en]
    *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
    *
    *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
    *   [/en]
    *   [ja][/ja]
    * @tutorial vanilla/Reference/fab
    * @seealso ons-speed-dial
    *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
    *   [ja][/ja]
    */

   var FabElement = function (_BaseElement) {
     babelHelpers.inherits(FabElement, _BaseElement);

     function FabElement() {
       babelHelpers.classCallCheck(this, FabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FabElement).apply(this, arguments));
     }

     babelHelpers.createClass(FabElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute ripple
        * @description
        *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this3 = this;

         autoStyle.prepare(this);

         this.classList.add('fab');

         if (!util.findChild(this, '.fab__icon')) {
           (function () {
             var content = document.createElement('span');
             content.classList.add('fab__icon');

             util.arrayFrom(_this3.childNodes).forEach(function (element) {
               if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
                 content.appendChild(element);
               }
             });
             _this3.appendChild(content);
           })();
         }

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$6);

         this._updatePosition();

         this.show();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$6);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'position':
             this._updatePosition();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         this.show();
       }
     }, {
       key: '_hide',
       value: function _hide() {
         this.hide();
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *  [en]Show the floating action button.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(1)';
         this.style.webkitTransform = 'scale(1)';
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *  [en]Hide the floating action button.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(0)';
         this.style.webkitTransform = 'scale(0)';
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'toggle',


       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle the visibility of the button.[/en]
        *   [ja][/ja]
        */
       value: function toggle() {
         this.visible ? this.hide() : this.show();
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'visible',
       get: function get() {
         return this.style.transform === 'scale(1)' && this.style.display !== 'none';
       }
     }]);
     return FabElement;
   }(BaseElement);

   window.OnsFabElement = document.registerElement('ons-fab', {
     prototype: FabElement.prototype
   });

   /**
    * @element ons-gesture-detector
    * @category gesture
    * @description
    *   [en]Component to detect finger gestures within the wrapped element. See the guide for more details.[/en]
    *   [ja][/ja]
    * @guide DetectingFingerGestures
    *   [en]Detecting finger gestures[/en]
    *   [ja][/ja]
    * @example
    * <ons-gesture-detector style="height: 100%; width: 100%;">
    *   ...
    * </ons-gesture-detector>
    */

   var GestureDetectorElement = function (_BaseElement) {
     babelHelpers.inherits(GestureDetectorElement, _BaseElement);

     function GestureDetectorElement() {
       babelHelpers.classCallCheck(this, GestureDetectorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(GestureDetectorElement).apply(this, arguments));
     }

     babelHelpers.createClass(GestureDetectorElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._gestureDetector = new GestureDetector(this);
       }
     }]);
     return GestureDetectorElement;
   }(BaseElement);

   window.OnsGestureDetectorElement = document.registerElement('ons-gesture-detector', {
     prototype: GestureDetectorElement.prototype
   });

   /**
    * @element ons-icon
    * @category icon
    * @description
    *   [en]
    *     Displays an icon. The following icon suites are available:
    *
    *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
    *     * [Ionicons](http://ionicons.com/)
    *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
    *   [/en]
    *   [ja][/ja]
    * @codepen xAhvg
    * @tutorial vanilla/Reference/icon
    * @guide UsingIcons [en]Using icons[/en][ja][/ja]
    * @example
    * <ons-icon
    *   icon="md-car"
    *   size="20px"
    *   style="color: red">
    * </ons-icon>
    *
    * <ons-button>
    *   <ons-icon icon="md-car"></ons-icon>
    *   Car
    * </ons-button>
    */

   var IconElement = function (_BaseElement) {
     babelHelpers.inherits(IconElement, _BaseElement);

     function IconElement() {
       babelHelpers.classCallCheck(this, IconElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IconElement).apply(this, arguments));
     }

     babelHelpers.createClass(IconElement, [{
       key: 'createdCallback',


       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
        *
        *     See all available icons on their respective sites:
        *
        *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
        *     * [Ionicons](http://ionicons.com)
        *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
        *
        *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
        *
        *     The code:
        *
        *     ```
        *     <ons-icon
        *       icon="ion-edit, material:md-edit">
        *     </ons-icon>
        *     ```
        *
        *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute size
        * @type {String}
        * @description
        *   [en]
        *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
        *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
        *
        *     The code:
        *
        *     ```
        *     <ons-icon
        *       icon="ion-edit"
        *       size="32px, material:24px">
        *     </ons-icon>
        *     ```
        *
        *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute rotate
        * @type {Number}
        * @description
        *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
        *   [ja]90, 180, 270[/ja]
        */

       /**
        * @attribute fixed-width
        * @type {Boolean}
        * @default false
        * @description
        *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute spin
        * @description
        *   [en]Specify whether the icon should be spinning.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
           this._update();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this._update();
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_update',
       value: function _update() {
         var _this2 = this;

         this._cleanClassAttribute();

         var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size'));

         var classList = _buildClassAndStyle2.classList;
         var style = _buildClassAndStyle2.style;

         util.extend(this.style, style);

         classList.forEach(function (className) {
           return _this2.classList.add(className);
         });
       }
     }, {
       key: '_getAttribute',
       value: function _getAttribute(attr) {
         var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
         var def = parts[0];
         var md = parts[1];
         md = (md || '').split(/\s*:\s*/);
         return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
       }

       /**
        * Remove unneeded class value.
        */

     }, {
       key: '_cleanClassAttribute',
       value: function _cleanClassAttribute() {
         var _this3 = this;

         util.arrayFrom(this.classList).filter(function (className) {
           return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
           );
         }).forEach(function (className) {
           return _this3.classList.remove(className);
         });

         this.classList.remove('zmdi');
         this.classList.remove('ons-icon--ion');
       }
     }, {
       key: '_buildClassAndStyle',
       value: function _buildClassAndStyle(iconName, size) {
         var classList = ['ons-icon'];
         var style = {};

         // Icon
         if (iconName.indexOf('ion-') === 0) {
           classList.push(iconName);
           classList.push('ons-icon--ion');
         } else if (iconName.indexOf('fa-') === 0) {
           classList.push(iconName);
           classList.push('fa');
         } else if (iconName.indexOf('md-') === 0) {
           classList.push('zmdi');
           classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
         } else {
           classList.push('fa');
           classList.push('fa-' + iconName);
         }

         // Size
         if (size.match(/^[1-5]x|lg$/)) {
           classList.push('fa-' + size);
           this.style.removeProperty('font-size');
         } else {
           style.fontSize = size;
         }

         return {
           classList: classList,
           style: style
         };
       }
     }]);
     return IconElement;
   }(BaseElement);

   window.OnsIconElement = document.registerElement('ons-icon', {
     prototype: IconElement.prototype
   });

   /**
    * @element ons-lazy-repeat
    * @category lazy-repeat
    * @description
    *   [en]
    *     Using this component a list with millions of items can be rendered without a drop in performance.
    *     It does that by "lazily" loading elements into the DOM when they come into view and
    *     removing items from the DOM when they are not visible.
    *   [/en]
    *   [ja]
    *     DOM
    *     
    *     
    *   [/ja]
    * @codepen QwrGBm
    * @tutorial vanilla/Reference/lazy-repeat
    * @seealso ons-list
    *   [en]The `<ons-list>` element is used to render a list.[/en]
    *   [ja]`<ons-list>`[/ja]
    * @guide UsingLazyRepeat
    *   [en]How to use Lazy Repeat[/en]
    *   [ja][/ja]
    * @example
    * <script>
    *   window.addEventListener('load', function() {
    *     var lazyRepeat = document.querySelector('#list');
    *     lazyRepeat.delegate = {
    *      createItemContent: function(i, template) {
    *        var dom = template.cloneNode(true);
    *        dom.innerText = i;
    *
    *        return dom;
    *      },
    *      countItems: function() {
    *        return 10000000;
    *      },
    *      destroyItem: function(index, item) {
    *        console.log('Destroyed item with index: ' + index);
    *      }
    *     };
    *   });
    * </script>
    *
    * <ons-list id="list">
    *   <ons-lazy-repeat>
    *     <ons-list-item></ons-list-item>
    *   </ons-lazy-repeat>
    * </ons-list>
    */

   var LazyRepeatElement = function (_BaseElement) {
     babelHelpers.inherits(LazyRepeatElement, _BaseElement);

     function LazyRepeatElement() {
       babelHelpers.classCallCheck(this, LazyRepeatElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LazyRepeatElement).apply(this, arguments));
     }

     babelHelpers.createClass(LazyRepeatElement, [{
       key: 'attachedCallback',
       value: function attachedCallback() {
         util.updateParentPosition(this);

         // not very good idea and also not documented
         if (this.hasAttribute('delegate')) {
           this.delegate = window[this.getAttribute('delegate')];
         }
       }

       /**
        * @property delegate
        * @type {Object}
        * @description
        *  [en]Specify a delegate object to load and unload item elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @property delegate.createItemContent
        * @type {Function}
        * @description
        *   [en]
        *     This function should return a `HTMLElement`.
        *
        *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
        *   [/en]
        *   [ja]
        *     `HTMLElement`
        *     
        *     `<ons-lazy-repeat>`
        *   [/ja]
        */

       /**
        * @property delegate.countItems
        * @type {Function}
        * @description
        *   [en]Should return the number of items in the list.[/en]
        *   [ja][/ja]
        */

       /**
        * @property delegate.calculateItemHeight
        * @type {Function}
        * @description
        *   [en]
        *     Should return the height of an item. The index is provided as an argument.
        *
        *     This is important when rendering lists where the items have different height.
        *
        *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
        *   [/en]
        *   [ja]
        *     ()
        *     
        *     
        *     
        *   [/ja]
        */

       /**
        * @property delegate.destroyItem
        * @type {Function}
        * @description
        *   [en]
        *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
        *
        *     The function is optional but may be important in order to avoid memory leaks.
        *   [/en]
        *   [ja]
        *     DOM
        *     DOM
        *     
        *   [/ja]
        */

     }, {
       key: 'refresh',


       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Refresh the list. Use this method when the data has changed.[/en]
        *   [ja][/ja]
        */
       value: function refresh() {
         this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         if (this._lazyRepeatProvider) {
           this._lazyRepeatProvider.destroy();
           this._lazyRepeatProvider = null;
         }
       }
     }, {
       key: 'delegate',
       set: function set(userDelegate) {
         this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

         if (!this._templateElement && this.children[0]) {
           this._templateElement = this.removeChild(this.children[0]);
         }

         var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
         this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
       },
       get: function get() {
         throw new Error('This property can only be used to set the delegate object.');
       }
     }]);
     return LazyRepeatElement;
   }(BaseElement);

   window.OnsLazyRepeatElement = document.registerElement('ons-lazy-repeat', {
     prototype: LazyRepeatElement.prototype
   });

   var scheme$7 = { '': 'list__header--*' };

   /**
    * @element ons-list-header
    * @category list
    * @description
    *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list
    *   [en]The `<ons-list>` component[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list-item
    *   [en]The `<ons-list-item>` component[/en]
    *   [ja]ons-list-item[/ja]
    * @guide UsingList [en]Using lists[/en][ja][/ja]
    * @codepen yxcCt
    * @tutorial vanilla/Reference/list
    * @modifier material
    *   [en]Display a Material Design list header.[/en]
    *   [ja][/ja]
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListHeaderElement = function (_BaseElement) {
     babelHelpers.inherits(ListHeaderElement, _BaseElement);

     function ListHeaderElement() {
       babelHelpers.classCallCheck(this, ListHeaderElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListHeaderElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListHeaderElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list header.[/en]
        *   [ja][/ja]
        */
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list__header');
         ModifierUtil.initModifier(this, scheme$7);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$7);
         }
       }
     }]);
     return ListHeaderElement;
   }(BaseElement);

   window.OnsListHeaderElement = document.registerElement('ons-list-header', {
     prototype: ListHeaderElement.prototype
   });

   var scheme$8 = {
     '.list__item': 'list__item--*',
     '.list__item__left': 'list__item--*__left',
     '.list__item__center': 'list__item--*__center',
     '.list__item__right': 'list__item--*__right',
     '.list__item__label': 'list__item--*__label',
     '.list__item__title': 'list__item--*__title',
     '.list__item__subtitle': 'list__item--*__subtitle',
     '.list__item__thumbnail': 'list__item--*__thumbnail',
     '.list__item__icon': 'list__item--*__icon'
   };

   /**
    * @element ons-list-item
    * @category list
    * @modifier tappable
    *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
    *   [ja][/ja]
    * @modifier chevron
    *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
    *   [ja][/ja]
    * @modifier longdivider
    *   [en]Displays a long horizontal divider between items.[/en]
    *   [ja][/ja]
    * @modifier nodivider
    *   [en]Removes the divider between list items.[/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Display a Material Design list item.[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
    *
    *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
    *
    *     ```
    *     <ons-list-item>
    *       <div class="left">Left</div>
    *       <div class="center">Center</div>
    *       <div class="right">Right</div>
    *     </ons-list-item>
    *     ```
    *
    *     There is also a number of classes (prefixed with `list__item__*`) that help when putting things like icons and thumbnails into the list items.
    *   [/en]
    *   [ja][/ja]
    * @seealso ons-list
    *   [en]ons-list component[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-header[/ja]
    * @guide UsingList
    *   [en]Using lists[/en]
    *   [ja][/ja]
    * @codepen yxcCt
    * @tutorial vanilla/Reference/list
    * @example
    * <ons-list-item>
    *   <div class="left">
    *     <ons-icon icon="md-face" class="list__item__icon"></ons-icon>
    *   </div>
    *   <div class="center">
    *     <div class="list__item__title">Title</div>
    *     <div class="list__item__subtitle">Subtitle</div>
    *   </div>
    *   <div class="right">
    *     <ons-switch></ons-switch>
    *   </div>
    * </ons-list-item>
    */

   var ListItemElement = function (_BaseElement) {
     babelHelpers.inherits(ListItemElement, _BaseElement);

     function ListItemElement() {
       babelHelpers.classCallCheck(this, ListItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListItemElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list item.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute lock-on-drag
        * @type {String}
        * @description
        *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute tappable
        * @type {Boolean}
        * @description
        *   [en]Makes the element react to taps.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute tap-background-color
        * @type {Color}
        * @description
        *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this.classList.add('list__item');

         var left = void 0,
             center = void 0,
             right = void 0;

         for (var i = 0; i < this.children.length; i++) {
           var el = this.children[i];

           if (el.classList.contains('left')) {
             el.classList.add('list__item__left');
             left = el;
           } else if (el.classList.contains('center')) {
             center = el;
           } else if (el.classList.contains('right')) {
             el.classList.add('list__item__right');
             right = el;
           }
         }

         if (!center) {
           center = document.createElement('div');

           if (!left && !right) {
             while (this.childNodes[0]) {
               center.appendChild(this.childNodes[0]);
             }
           } else {
             for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
               var _el = this.childNodes[_i];
               if (_el !== left && _el !== right) {
                 center.insertBefore(_el, center.firstChild);
               }
             }
           }

           this.insertBefore(center, right || null);
         }

         center.classList.add('center');
         center.classList.add('list__item__center');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$8);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$8);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('drag', this._onDrag);
         this.addEventListener('touchstart', this._onTouch);
         this.addEventListener('mousedown', this._onTouch);
         this.addEventListener('touchend', this._onRelease);
         this.addEventListener('touchmove', this._onRelease);
         this.addEventListener('touchcancel', this._onRelease);
         this.addEventListener('mouseup', this._onRelease);
         this.addEventListener('mouseout', this._onRelease);
         this.addEventListener('touchleave', this._onRelease);

         this._originalBackgroundColor = this.style.backgroundColor;

         this.tapped = false;
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('drag', this._onDrag);
         this.removeEventListener('touchstart', this._onTouch);
         this.removeEventListener('mousedown', this._onTouch);
         this.removeEventListener('touchend', this._onRelease);
         this.removeEventListener('touchmove', this._onRelease);
         this.removeEventListener('touchcancel', this._onRelease);
         this.removeEventListener('mouseup', this._onRelease);
         this.removeEventListener('mouseout', this._onRelease);
         this.removeEventListener('touchleave', this._onRelease);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var gesture = event.gesture;
         // Prevent vertical scrolling if the users pans left or right.
         if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
           gesture.preventDefault();
         }
       }
     }, {
       key: '_onTouch',
       value: function _onTouch() {
         if (this.tapped) {
           return;
         }

         this.tapped = true;

         this.style.transition = this._transition;
         this.style.webkitTransition = this._transition;
         this.style.MozTransition = this._transition;

         if (this._tappable) {
           if (this.style.backgroundColor) {
             this._originalBackgroundColor = this.style.backgroundColor;
           }

           this.style.backgroundColor = this._tapBackgroundColor;
           this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease() {
         this.tapped = false;

         this.style.transition = '';
         this.style.webkitTransition = '';
         this.style.MozTransition = '';

         this.style.backgroundColor = this._originalBackgroundColor || '';
         this.style.boxShadow = '';
       }
     }, {
       key: '_shouldLockOnDrag',
       value: function _shouldLockOnDrag() {
         return this.hasAttribute('lock-on-drag');
       }
     }, {
       key: '_transition',
       get: function get() {
         return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
       }
     }, {
       key: '_tappable',
       get: function get() {
         return this.hasAttribute('tappable');
       }
     }, {
       key: '_tapBackgroundColor',
       get: function get() {
         return this.getAttribute('tap-background-color') || '#d9d9d9';
       }
     }]);
     return ListItemElement;
   }(BaseElement);

   window.OnsListItemElement = document.registerElement('ons-list-item', {
     prototype: ListItemElement.prototype
   });

   var scheme$9 = { '': 'list--*' };

   /**
    * @element ons-list
    * @category list
    * @modifier inset
    *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
    *   [ja][/ja]
    * @modifier noborder
    *   [en]A list with no borders at the top and bottom.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
    *   [ja]ons-list-item[/ja]
    * @seealso ons-list-item
    *   [en]ons-list-item component[/en]
    *   [ja]ons-list-item[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-header[/ja]
    * @guide UsingList
    *   [en]Using lists[/en]
    *   [ja][/ja]
    * @codepen yxcCt
    * @tutorial vanilla/Reference/list
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListElement = function (_BaseElement) {
     babelHelpers.inherits(ListElement, _BaseElement);

     function ListElement() {
       babelHelpers.classCallCheck(this, ListElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list');
         ModifierUtil.initModifier(this, scheme$9);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$9);
         }
       }
     }]);
     return ListElement;
   }(BaseElement);

   window.OnsListElement = document.registerElement('ons-list', {
     prototype: ListElement.prototype
   });

   var scheme$10 = {
     '.text-input': 'text-input--*',
     '.text-input__label': 'text-input--*__label',
     '.radio-button': 'radio-button--*',
     '.radio-button__input': 'radio-button--*__input',
     '.radio-button__checkmark': 'radio-button--*__checkmark',
     '.checkbox': 'checkbox--*',
     '.checkbox__input': 'checkbox--*__input',
     '.checkbox__checkmark': 'checkbox--*__checkmark'
   };

   var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

   /**
    * @element ons-input
    * @category input
    * @modifier material
    *  [en]Displays a Material Design input.[/en]
    *  [ja][/ja]
    * @modifier underbar
    *  [en]Displays a horizontal line underneath a text input.[/en]
    *  [ja][/ja]
    * @description
    *  [en]
    *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
    *
    *    The component will automatically render as a Material Design input on Android devices.
    *
    *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
    *  [/en]
    *  [ja][/ja]
    * @codepen ojQxLj
    * @tutorial vanilla/Reference/input
    * @seealso ons-range
    *   [en]The `<ons-range>` element is used to display a range slider.[/en]
    *   [ja][/ja]
    * @seealso ons-switch
    *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
    *   [ja][/ja]
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @example
    * <ons-input placeholder="Username" float></ons-input>
    * <ons-input type="checkbox" checked></ons-input>
    */

   var InputElement = function (_BaseElement) {
     babelHelpers.inherits(InputElement, _BaseElement);

     function InputElement() {
       babelHelpers.classCallCheck(this, InputElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(InputElement).apply(this, arguments));
     }

     babelHelpers.createClass(InputElement, [{
       key: 'createdCallback',


       /**
        * @attribute placeholder
        * @type {String}
        * @description
        *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute float
        * @description
        *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute type
        * @type {String}
        * @description
        *  [en]
        *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
        *
        *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
        *  [/en]
        *  [ja][/ja]
        */

       /**
        * @attribute input-id
        * @type {String}
        * @description
        *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using <label for="..."> elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute content-left
        * @description
        *  [en]The HTML content of `<ons-input>` is placed before the actual input as a label. Omit this to display it after the input.[/en]
        *  [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
           _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
         });

         this._boundOnInput = this._onInput.bind(this);
         this._boundOnFocusin = this._onFocusin.bind(this);
         this._boundOnFocusout = this._onFocusout.bind(this);
         this._boundDelegateEvent = this._delegateEvent.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.children.length !== 0) {
           return;
         }

         var helper = document.createElement('span');
         helper.classList.add('_helper');

         var container = document.createElement('label');
         container.appendChild(document.createElement('input'));
         container.appendChild(helper);

         var label = document.createElement('span');
         label.classList.add('input-label');

         util.arrayFrom(this.childNodes).forEach(function (element) {
           return label.appendChild(element);
         });
         this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

         this.appendChild(container);

         switch (this.getAttribute('type')) {
           case 'checkbox':
             this.classList.add('checkbox');
             this._input.classList.add('checkbox__input');
             this._helper.classList.add('checkbox__checkmark');
             this._updateBoundAttributes();
             break;

           case 'radio':
             this.classList.add('radio-button');
             this._input.classList.add('radio-button__input');
             this._helper.classList.add('radio-button__checkmark');
             this._updateBoundAttributes();
             break;

           default:
             this._input.classList.add('text-input');
             this._helper.classList.add('text-input__label');
             this._input.parentElement.classList.add('text-input__container');

             this._updateLabel();
             this._updateLabelColor();
             this._updateBoundAttributes();
             this._updateLabelClass();
             break;
         }

         if (this.hasAttribute('input-id')) {
           this._input.id = this.getAttribute('input-id');
         }

         ModifierUtil.initModifier(this, scheme$10);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         if (name === 'modifier') {
           return contentReady(this, function () {
             return ModifierUtil.onModifierChanged(last, current, _this3, scheme$10);
           });
         } else if (name === 'placeholder') {
           return contentReady(this, function () {
             return _this3._updateLabel();
           });
         }if (name === 'input-id') {
           contentReady(this, function () {
             return _this3._input.id = current;
           });
         }if (name === 'checked') {
           this.checked = current !== null;
         } else if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
           return contentReady(this, function () {
             return _this3._updateBoundAttributes();
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this4 = this;

         contentReady(this, function () {
           if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
             _this4._input.addEventListener('input', _this4._boundOnInput);
             _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
             _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
           }

           _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
           _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         var _this5 = this;

         contentReady(this, function () {
           _this5._input.removeEventListener('input', _this5._boundOnInput);
           _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
           _this5._input.removeEventListener('focusout', _this5._boundOnFocusout);
           _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
           _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
         });
       }
     }, {
       key: '_setLabel',
       value: function _setLabel(value) {
         if (typeof this._helper.textContent !== 'undefined') {
           this._helper.textContent = value;
         } else {
           this._helper.innerText = value;
         }
       }
     }, {
       key: '_updateLabel',
       value: function _updateLabel() {
         this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this6 = this;

         INPUT_ATTRIBUTES.forEach(function (attr) {
           if (_this6.hasAttribute(attr)) {
             _this6._input.setAttribute(attr, _this6.getAttribute(attr));
           } else {
             _this6._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_updateLabelColor',
       value: function _updateLabelColor() {
         if (this.value.length > 0 && this._input === document.activeElement) {
           this._helper.style.color = '';
         } else {
           this._helper.style.color = 'rgba(0, 0, 0, 0.5)';
         }
       }
     }, {
       key: '_updateLabelClass',
       value: function _updateLabelClass() {
         if (this.value === '') {
           this._helper.classList.remove('text-input__label--active');
         } else if (['checkbox', 'radio'].indexOf(this.getAttribute('type')) === -1) {
           this._helper.classList.add('text-input__label--active');
         }
       }
     }, {
       key: '_delegateEvent',
       value: function _delegateEvent(event) {
         var e = new CustomEvent(event.type, {
           bubbles: false,
           cancelable: true
         });

         return this.dispatchEvent(e);
       }
     }, {
       key: '_onInput',
       value: function _onInput(event) {
         this._updateLabelClass();
         this._updateLabelColor();
       }
     }, {
       key: '_onFocusin',
       value: function _onFocusin(event) {
         this._updateLabelClass();
         this._updateLabelColor();
       }
     }, {
       key: '_onFocusout',
       value: function _onFocusout(event) {
         this._updateLabelColor();
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_helper',
       get: function get() {
         return this.querySelector('._helper');
       }

       /**
        * @property value
        * @type {String}
        * @description
        *   [en]The current value of the input.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'value',
       get: function get() {
         return this._input === null ? this.getAttribute('value') : this._input.value;
       },
       set: function set(val) {
         var _this7 = this;

         this.setAttribute('value', val);

         contentReady(this, function () {
           _this7._input.value = val;
           _this7._onInput();
         });

         return val;
       }

       /**
        * @property checked
        * @type {Boolean}
        * @description
        *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'checked',
       get: function get() {
         return this._input.checked;
       },
       set: function set(val) {
         var _this8 = this;

         contentReady(this, function () {
           _this8._input.checked = val;
         });
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the input is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }, {
       key: '_isTextInput',
       get: function get() {
         return this.type !== 'radio' && this.type !== 'checkbox';
       }
     }, {
       key: 'type',
       get: function get() {
         return this.getAttribute('type');
       }
     }]);
     return InputElement;
   }(BaseElement);

   window.OnsInputElement = document.registerElement('ons-input', {
     prototype: InputElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModalAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function ModalAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, ModalAnimator);

       this.delay = 0;
       this.duration = 0.2;

       this.timing = options.timing || this.timing;
       this.duration = options.duration !== undefined ? options.duration : this.duration;
       this.delay = options.delay !== undefined ? options.delay : this.delay;
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */


     babelHelpers.createClass(ModalAnimator, [{
       key: "show",
       value: function show(modal, callback) {
         callback();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: "hide",
       value: function hide(modal, callback) {
         callback();
       }
     }]);
     return ModalAnimator;
   }();

   /**
    * iOS style animator for dialog.
    */

   var FadeModalAnimator = function (_ModalAnimator) {
     babelHelpers.inherits(FadeModalAnimator, _ModalAnimator);

     function FadeModalAnimator(options) {
       babelHelpers.classCallCheck(this, FadeModalAnimator);

       options.timing = options.timing || 'linear';
       options.duration = options.duration || '0.3';
       options.delay = options.delay || 0;

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FadeModalAnimator).call(this, options));
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */


     babelHelpers.createClass(FadeModalAnimator, [{
       key: 'show',
       value: function show(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 1
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }
     }]);
     return FadeModalAnimator;
   }(ModalAnimator);

   var scheme$11 = {
     '': 'modal--*',
     'modal__content': 'modal--*__content'
   };

   var _animatorDict$2 = {
     'default': ModalAnimator,
     'fade': FadeModalAnimator,
     'none': ModalAnimator
   };

   /**
    * @element ons-modal
    * @category modal
    * @description
    *   [en]
    *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
    *
    *     This component can be used to block user input while some operation is running or to show some information to the user.
    *   [/en]
    *   [ja]
    *     
    *     
    *   [/ja]
    * @guide UsingModal
    *   [en]Using ons-modal component[/en]
    *   [ja][/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @seealso ons-dialog
    *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
    *   [ja][/ja]
    * @codepen devIg
    * @example
    * <ons-modal id="modal">
    *   Modal content
    * </ons-modal>
    * <script>
    *   var modal = document.getElementById('modal');
    *   modal.show();
    * </script>
    */

   var ModalElement = function (_BaseElement) {
     babelHelpers.inherits(ModalElement, _BaseElement);

     function ModalElement() {
       babelHelpers.classCallCheck(this, ModalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ModalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ModalElement, [{
       key: 'createdCallback',


       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
        *  [ja]"none""fade"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });

         this._doorLock = new DoorLock();

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$2,
           baseClass: ModalAnimator,
           baseClassName: 'ModalAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this.style.display = 'none';
         this.classList.add('modal');

         if (!util.findChild(this, '.modal__content')) {
           var content = document.createElement('div');
           content.classList.add('modal__content');

           while (this.childNodes[0]) {
             var node = this.childNodes[0];
             this.removeChild(node);
             content.insertBefore(node, null);
           }

           this.appendChild(content);
         }

         ModifierUtil.initModifier(this, scheme$11);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         setImmediate(this._ensureNodePosition.bind(this));
         this.onDeviceBackButton = function () {
           return undefined;
         };
       }
     }, {
       key: '_ensureNodePosition',
       value: function _ensureNodePosition() {
         if (!this.parentNode || this.hasAttribute('inline')) {
           return;
         }

         if (this.parentNode.nodeName.toLowerCase() !== 'ons-page') {
           var page = this;
           for (;;) {
             page = page.parentNode;

             if (!page) {
               return;
             }

             if (page.nodeName.toLowerCase() === 'ons-page') {
               break;
             }
           }
           page._registerExtraElement(this);
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'show',


       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Show modal.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryShow = function tryShow() {
           var unlock = _this3._doorLock.lock();
           var animator = _this3._animatorFactory.newAnimator(options);

           _this3.style.display = 'table';
           return new Promise(function (resolve) {
             animator.show(_this3, function () {
               unlock();

               callback();
               resolve(_this3);
             });
           });
         };

         return new Promise(function (resolve) {
           _this3._doorLock.waitUnlock(function () {
             return resolve(tryShow());
           });
         });
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Toggle modal visibility.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         if (this.visible) {
           return this.hide.apply(this, arguments);
         } else {
           return this.show.apply(this, arguments);
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Hide modal.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryHide = function tryHide() {
           var unlock = _this4._doorLock.lock();
           var animator = _this4._animatorFactory.newAnimator(options);

           return new Promise(function (resolve) {
             animator.hide(_this4, function () {
               _this4.style.display = 'none';
               unlock();

               callback();
               resolve(_this4);
             });
           });
         };

         return new Promise(function (resolve) {
           _this4._doorLock.waitUnlock(function () {
             return resolve(tryHide());
           });
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
         }
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(handler) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
       }
     }, {
       key: 'visible',
       get: function get() {
         return this.style.display !== 'none';
       }
     }]);
     return ModalElement;
   }(BaseElement);

   window.OnsModalElement = document.registerElement('ons-modal', {
     prototype: ModalElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsModalElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof ModalAnimator)) {
       throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
     }
     _animatorDict$2[name] = Animator;
   };

   window.OnsModalElement.ModalAnimator = ModalAnimator;

   var NavigatorTransitionAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function NavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       this.timing = options.timing;
       this.duration = options.duration;
       this.delay = options.delay;
     }

     babelHelpers.createClass(NavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NavigatorTransitionAnimator;
   }();

   /**
    * Slide animator for navigator transition like iOS's screen slide transition.
    */

   var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');
       return _this;
     }

     babelHelpers.createClass(IOSSlideNavigatorTransitionAnimator, [{
       key: '_decompose',
       value: function _decompose(page) {
         CustomElements.upgrade(page);
         var toolbar = page._getToolbarElement();
         CustomElements.upgrade(toolbar);
         var left = toolbar._getToolbarLeftItemsElement();
         var right = toolbar._getToolbarRightItemsElement();

         var excludeBackButtonLabel = function excludeBackButtonLabel(elements) {
           var result = [];

           for (var i = 0; i < elements.length; i++) {
             if (elements[i].nodeName.toLowerCase() === 'ons-back-button') {
               var iconElement = elements[i].querySelector('.back-button__icon');
               if (iconElement) {
                 result.push(iconElement);
               }
             } else {
               result.push(elements[i]);
             }
           }

           return result;
         };

         var other = [].concat(left.children.length === 0 ? left : excludeBackButtonLabel(left.children)).concat(right.children.length === 0 ? right : excludeBackButtonLabel(right.children));

         var pageLabels = [toolbar._getToolbarCenterItemsElement(), toolbar._getToolbarBackButtonLabelElement()];

         return {
           pageLabels: pageLabels,
           other: other,
           content: page._getContentElement(),
           background: page._getBackgroundElement(),
           toolbar: toolbar,
           bottomToolbar: page._getBottomToolbarElement()
         };
       }
     }, {
       key: '_shouldAnimateToolbar',
       value: function _shouldAnimateToolbar(enterPage, leavePage) {
         var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

         var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

         return bothPageHasToolbar && noMaterialToolbar;
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = function () {
           var rect = leavePage.getBoundingClientRect();
           return Math.round((rect.right - rect.left) / 2 * 0.6);
         }();

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0.1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle().queue(function (done) {
             callback();
             done();
           }), animit(leavePageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(-' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePageDecomposition.other).saveStyle().queue({
             css: { opacity: 1 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 0 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle());
         } else {

           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).saveStyle().queue({
             css: {
               transform: 'translate3D(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle().queue(function (done) {
             callback();
             done();
           }));
         }
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = function () {
           var rect = leavePage.getBoundingClientRect();
           return Math.round((rect.right - rect.left) / 2 * 0.6);
         }();

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0.1,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(-' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.toolbar).saveStyle().queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).wait(0).queue(function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }.bind(this)), animit(leavePageDecomposition.other).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }), animit(leavePageDecomposition.toolbar).queue({
             css: {
               background: 'none',
               backgroundColor: 'rgba(0, 0, 0, 0)',
               borderColor: 'rgba(0, 0, 0, 0)'
             },
             duration: 0
           }), animit(leavePageDecomposition.pageLabels).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }));
         } else {
           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).queue(function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }.bind(this)));
         }
       }
     }]);
     return IOSSlideNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSLiftNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Fade-in screen transition.
    */

   var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(enterPage._getToolbarElement()).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle());
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage._getToolbarElement()).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSFadeNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Slide animator for navigator transition.
    */

   var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.3,
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
       _this.blackMaskOpacity = 0.4;
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDSlideNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: this.blackMaskOpacity
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(100%, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().wait(0.2).queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: this.blackMaskOpacity,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(100%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.2).queue(function (finish) {
           done();
           finish();
         }));
       }
     }]);
     return MDSlideNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0.05
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).queue({
           css: {
             opacity: 0.4
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0.4
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDLiftNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Fade-in + Lift screen transition.
    */

   var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'ease-out',
         duration: '0.25',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 42px, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(0.15).queue({
           css: {
             transform: 'translate3D(0, 38px, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1
           },
           duration: 0
         }).wait(0.04).queue({
           css: {
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDFadeNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

     function NoneNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NoneNavigatorTransitionAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NoneNavigatorTransitionAnimator).call(this, options));
     }

     babelHelpers.createClass(NoneNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NoneNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   var _animatorDict$3 = {
     'default': function _default() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'slide': function slide() {
       return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'lift': function lift() {
       return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
     },
     'slide-ios': IOSSlideNavigatorTransitionAnimator,
     'slide-md': MDSlideNavigatorTransitionAnimator,
     'lift-ios': IOSLiftNavigatorTransitionAnimator,
     'lift-md': MDLiftNavigatorTransitionAnimator,
     'fade-ios': IOSFadeNavigatorTransitionAnimator,
     'fade-md': MDFadeNavigatorTransitionAnimator,
     'none': NoneNavigatorTransitionAnimator
   };

   var rewritables = {
     /**
      * @param {Element} navigatorSideElement
      * @param {Function} callback
      */

     ready: function ready(navigatorElement, callback) {
       callback();
     },


     /**
      * @param {Element} navigatorElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(navigatorElement, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-navigator
    * @category navigation
    * @description
    *   [en]
    *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
    *
    *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
    *   [/en]
    *   [ja][/ja]
    * @codepen yrhtv
    * @tutorial vanilla/Reference/navigator
    * @guide PageNavigation
    *   [en]Guide for page navigation[/en]
    *   [ja][/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-toolbar
    *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
    *   [ja][/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
    *   [ja][/ja]
    * @example
    * <ons-navigator id="navigator">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="center">
    *         Title
    *       </div>
    *     </ons-toolbar>
    *     <p>
    *       <ons-button
    *         onclick="document.getElementById('navigator').pushPage('page.html')">
    *         Push page
    *       </ons-button>
    *     </p>
    *   </ons-page>
    * </ons-navigator>
    *
    * <ons-template id="page.html">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="left">
    *         <ons-back-button>Back</ons-back-button>
    *       </div>
    *       <div class="center">
    *         Another page
    *       </div>
    *     </ons-toolbar>
    *   </ons-page>
    * </ons-template>
    */

   var NavigatorElement = function (_BaseElement) {
     babelHelpers.inherits(NavigatorElement, _BaseElement);

     function NavigatorElement() {
       babelHelpers.classCallCheck(this, NavigatorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NavigatorElement).apply(this, arguments));
     }

     babelHelpers.createClass(NavigatorElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._isRunning = false;

         this._updateAnimatorFactory();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this2 = this;

         this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

         rewritables.ready(this, function () {
           if (_this2.pages.length === 0 && _this2.hasAttribute('page')) {
             _this2.pushPage(_this2.getAttribute('page'), { animation: 'none' });
           } else {
             for (var i = 0; i < _this2.pages.length; i++) {
               if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
                 throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
               }
             }

             if (_this2.topPage) {
               setTimeout(function () {
                 _this2.topPage._show();
                 _this2._updateLastPageBackButton();
               }, 0);
             }
           }
         });
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$3,
           baseClass: NavigatorTransitionAnimator,
           baseClassName: 'NavigatorTransitionAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }

       /**
        * @method popPage
        * @signature popPage([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Boolean} [options.refresh]
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPagetrue[/ja]
        * @param {Function} [options.callback]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the revealed page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'popPage',
       value: function popPage() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var popUpdate = function popUpdate() {
           return new Promise(function (resolve) {
             _this3.pages[_this3.pages.length - 1]._destroy();
             resolve();
           });
         };
         options = this._prepareOptions(options);

         if (!options.refresh) {
           return this._popPage(options, popUpdate);
         }
         var index = this.pages.length - 2;

         if (!this.pages[index].name) {
           throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
         }

         return new Promise(function (resolve) {
           internal.getPageHTMLAsync(_this3.pages[index].name).then(function (templateHTML) {
             var element = util.extend(_this3._createPageElement(templateHTML), {
               name: _this3.pages[index].name,
               data: _this3.pages[index].data,
               pushedOptions: _this3.pages[index].pushedOptions
             });

             rewritables.link(_this3, element, _this3.pages[index].options, function (element) {
               _this3.insertBefore(element, _this3.pages[index] ? _this3.pages[index] : null);
               _this3.pages[index + 1]._destroy();
               resolve();
             });
           });
         }).then(function () {
           return _this3._popPage(options, popUpdate);
         });
       }
     }, {
       key: '_popPage',
       value: function _popPage(options) {
         var _this4 = this;

         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];
         var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

         if (this._isRunning) {
           return Promise.reject('popPage is already running.');
         }

         if (this.pages.length <= 1) {
           return Promise.reject('ons-navigator\'s page stack is empty.');
         }

         if (this._emitPrePopEvent()) {
           return Promise.reject('Canceled in prepop event.');
         }

         var l = this.pages.length;

         this._isRunning = true;

         this.pages[l - 2].updateBackButton(l - 2 > 0);

         return new Promise(function (resolve) {
           var leavePage = _this4.pages[l - 1];
           var enterPage = _this4.pages[l - 2];
           enterPage.style.display = 'block';

           options.animation = leavePage.pushedOptions.animation || options.animation;
           options.animationOptions = util.extend({}, leavePage.pushedOptions.animationOptions, options.animationOptions || {});

           var callback = function callback() {
             pages.pop();
             update(pages, _this4).then(function () {
               _this4._isRunning = false;

               enterPage._show();
               util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

               if (typeof options.callback === 'function') {
                 options.callback();
               }

               resolve(enterPage);
             });
           };

           leavePage._hide();
           var animator = _this4._animatorFactory.newAnimator(options);
           animator.pop(_this4.pages[l - 2], _this4.pages[l - 1], callback);
         }).catch(function () {
           return _this4._isRunning = false;
         });
       }

       /**
        * @method pushPage
        * @signature pushPage(page, [options])
        * @param {String} [page]
        *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.page]
        *   [en]Page URL. Only necessary if `page` parameter is omitted.[/en]
        *   [ja][/ja]
        * @param {String} [options.pageHTML]
        *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        * @param {Function} [options.callback]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]pushPage()[/ja]
        * @param {Any} [options.data]
        *   [en]Custom data that will be stored in the new page element.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the pushed page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Pushes the specified page into the stack.[/en]
        *   [ja]page[/ja]
        */

     }, {
       key: 'pushPage',
       value: function pushPage(page) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         options = this._prepareOptions(options, page);
         var run = function run(templateHTML) {
           return new Promise(function (resolve) {
             var element = util.extend(_this5._createPageElement(templateHTML), {
               name: options.page,
               data: options.data
             });
             element.style.display = 'none';
             _this5.appendChild(element);
             resolve();
           });
         };

         if (options.pageHTML) {
           return this._pushPage(options, function () {
             return run(options.pageHTML);
           });
         }
         return this._pushPage(options, function () {
           return internal.getPageHTMLAsync(options.page).then(run);
         });
       }
     }, {
       key: '_pushPage',
       value: function _pushPage() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];

         var _this6 = this;

         var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
         var page = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }

         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         this._isRunning = true;

         var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
         options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

         var animator = this._animatorFactory.newAnimator(options);

         pages.push(page);

         return update(pages, this).then(function () {
           var pageLength = _this6.pages.length;

           var enterPage = _this6.pages[pageLength - 1];
           var leavePage = _this6.pages[pageLength - 2];

           if (enterPage.nodeName !== 'ONS-PAGE') {
             throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
           }

           enterPage.updateBackButton(pageLength - 1);

           enterPage.pushedOptions = options;
           enterPage.data = enterPage.data || options.data;
           enterPage.name = enterPage.name || options.page;

           return new Promise(function (resolve) {
             var done = function done() {
               _this6._isRunning = false;

               if (leavePage) {
                 leavePage.style.display = 'none';
               }

               enterPage._show();
               util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

               if (typeof options.callback === 'function') {
                 options.callback();
               }

               resolve(enterPage);
             };

             enterPage.style.display = 'none';

             var push = function push() {
               enterPage.style.display = 'block';
               if (leavePage) {
                 leavePage._hide();
                 animator.push(enterPage, leavePage, done);
               } else {
                 done();
               }
             };

             options._linked ? push() : rewritables.link(_this6, enterPage, options, push);
           });
         }).catch(function (error) {
           _this6._isRunning = false;
           throw error;
         });
       }

       /**
        * @method replacePage
        * @signature replacePage(page, [options])
        * @return {Promise}
        *   [en]Promise which resolves to the new page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'replacePage',
       value: function replacePage(page) {
         var _this7 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         options = this._prepareOptions(options, page);
         var callback = options.callback;

         options.callback = function () {
           if (_this7.pages.length > 1) {
             _this7.pages[_this7.pages.length - 2]._destroy();
           }
           _this7._updateLastPageBackButton();
           callback && callback();
         };

         return this.pushPage(options);
       }

       /**
        * @method insertPage
        * @signature insertPage(index, page, [options])
        * @param {Number} index
        *   [en]The index where it should be inserted.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the inserted page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
        *   [ja]pageindex[/ja]
        */

     }, {
       key: 'insertPage',
       value: function insertPage(index, page) {
         var _this8 = this;

         var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

         options = this._prepareOptions(options, page);
         index = this._normalizeIndex(index);

         if (index >= this.pages.length) {
           return this.pushPage(options);
         }

         var run = function run(templateHTML) {
           var element = util.extend(_this8._createPageElement(templateHTML), {
             name: options.page,
             data: options.data,
             pushedOptions: options
           });

           options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

           return new Promise(function (resolve) {
             element.style.display = 'none';
             _this8.insertBefore(element, _this8.pages[index]);
             _this8.topPage.updateBackButton(true);

             rewritables.link(_this8, element, options, function (element) {
               setTimeout(function () {
                 element = null;
                 resolve(_this8.pages[index]);
               }, 1000 / 60);
             });
           });
         };

         if (options.pageHTML) {
           return run(options.pageHTML);
         } else {
           return internal.getPageHTMLAsync(options.page).then(run);
         }
       }

       /**
        * @method resetToPage
        * @signature resetToPage(page, [options])
        * @return {Promise}
        *   [en]Promise which resolves to the new top page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'resetToPage',
       value: function resetToPage(page) {
         var _this9 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         options = this._prepareOptions(options, page);

         if (!options.animator && !options.animation) {
           options.animation = 'none';
         }

         var callback = options.callback;

         options.callback = function () {
           while (_this9.pages.length > 1) {
             _this9.pages[0]._destroy();
           }

           _this9.pages[0].updateBackButton(false);
           callback && callback();
         };

         if (!options.page && !options.pageHTML && this.hasAttribute('page')) {
           options.page = this.getAttribute('page');
         }

         return this.pushPage(options);
       }

       /**
        * @method bringPageTop
        * @signature bringPageTop(item, [options])
        * @param {String|Number} item
        *   [en]Page URL or index of an existing page in navigator's stack.[/en]
        *   [ja]URLons-navigator[/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the new top page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
        *   [ja]push[/ja]
        */

     }, {
       key: 'bringPageTop',
       value: function bringPageTop(item) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : babelHelpers.typeof(item)) === -1) {
           throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
         }
         var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
         var page = this.pages[index];

         if (index < 0) {
           return this.pushPage(item, options);
         }
         options = this._prepareOptions(options);

         if (index === this.pages.length - 1) {
           return Promise.resolve(page);
         }
         if (!page) {
           throw new Error('Failed to find item ' + item);
         }
         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }
         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         util.extend(options, {
           page: page.name,
           _linked: true
         });
         page.style.display = 'none';
         page.setAttribute('_skipinit', '');
         page.parentNode.appendChild(page);
         return this._pushPage(options);
       }
     }, {
       key: '_prepareOptions',
       value: function _prepareOptions() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var page = arguments[1];

         if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
           options = page;
           page = options.page;
         }
         if ((typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }
         page = page || options.page;

         return util.extend({}, this.options || {}, options, { page: page });
       }
     }, {
       key: '_updateLastPageBackButton',
       value: function _updateLastPageBackButton() {
         var index = this.pages.length - 1;
         if (index >= 0) {
           this.pages[index].updateBackButton(index > 0);
         }
       }
     }, {
       key: '_normalizeIndex',
       value: function _normalizeIndex(index) {
         return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.pages.length > 1) {
           this.popPage();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_lastIndexOfPage',
       value: function _lastIndexOfPage(pageName) {
         var index = void 0;
         for (index = this.pages.length - 1; index >= 0; index--) {
           if (this.pages[index].name === pageName) {
             break;
           }
         }
         return index;
       }
     }, {
       key: '_emitPreEvent',
       value: function _emitPreEvent(name) {
         var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isCanceled = false;

         util.triggerElementEvent(this, 'pre' + name, util.extend({
           navigator: this,
           currentPage: this.pages[this.pages.length - 1],
           cancel: function cancel() {
             return isCanceled = true;
           }
         }, data));

         return isCanceled;
       }
     }, {
       key: '_emitPrePushEvent',
       value: function _emitPrePushEvent() {
         return this._emitPreEvent('push');
       }
     }, {
       key: '_emitPrePopEvent',
       value: function _emitPrePopEvent() {
         var l = this.pages.length;
         return this._emitPreEvent('pop', {
           leavePage: this.pages[l - 1],
           enterPage: this.pages[l - 2]
         });
       }
     }, {
       key: '_createPageElement',
       value: function _createPageElement(templateHTML) {
         var pageElement = util.createElement(internal.normalizePageHTML(templateHTML));

         if (pageElement.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('You must supply an "ons-page" element to "ons-navigator".');
         }

         CustomElements.upgrade(pageElement);

         return pageElement;
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_show',
       value: function _show() {
         if (this.topPage) {
           this.topPage._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this.topPage) {
           this.topPage._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         for (var i = this.pages.length - 1; i >= 0; i--) {
           this.pages[i]._destroy();
         }

         this.remove();
       }
     }, {
       key: 'animatorFactory',


       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]First page to show when navigator is initialized.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
        *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
        */

       /**
        * @event prepush
        * @description
        *   [en]Fired just before a page is pushed.[/en]
        *   [ja]pagepush[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]page[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the push.[/en]
        *   [ja]push[/ja]
        */

       /**
        * @event prepop
        * @description
        *   [en]Fired just before a page is popped.[/en]
        *   [ja]pagepop[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]page[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the pop.[/en]
        *   [ja]pagepop[/ja]
        */

       /**
        * @event postpush
        * @description
        *   [en]Fired just after a page is pushed.[/en]
        *   [ja]pagepush[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pushpage[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]page[/ja]
        */

       /**
        * @event postpop
        * @description
        *   [en]Fired just after a page is popped.[/en]
        *   [ja]pagepop[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pop[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]pop[/ja]
        */

       get: function get() {
         return this._animatorFactory;
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }

       /**
        * @property topPage
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
        *   [ja]pushPage()resetToPage()[/ja]
        */

     }, {
       key: 'topPage',
       get: function get() {
         return this.pages[this.pages.length - 1] || null;
       }

       /**
        * @property pages
        * @readonly
        * @type {HTMLCollection}
        * @description
        *   [en]Navigator's page stack.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'pages',
       get: function get() {
         return this.children;
       }

       /**
        * @property options
        * @type {Object}
        * @description
        *   [en]Default options object. Attributes have priority over this property.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animation
        * @type {String}
        * @description
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animationOptions
        * @type {String}
        * @description
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        */

       /**
        * @property options.callback
        * @type {String}
        * @description
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.refresh
        * @default  false
        * @type {Boolean}
        * @description
        *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
        *   [ja]popPagetrue[/ja]
        */

     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }, {
       key: '_isRunning',
       set: function set(value) {
         this.setAttribute('_is-running', value ? 'true' : 'false');
       },
       get: function get() {
         return JSON.parse(this.getAttribute('_is-running'));
       }
     }]);
     return NavigatorElement;
   }(BaseElement);

   window.OnsNavigatorElement = document.registerElement('ons-navigator', {
     prototype: NavigatorElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsNavigatorElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
       throw new Error('"Animator" param must inherit OnsNavigatorElement.NavigatorTransitionAnimator');
     }

     _animatorDict$3[name] = Animator;
   };

   window.OnsNavigatorElement.rewritables = rewritables;
   window.OnsNavigatorElement.NavigatorTransitionAnimator = NavigatorTransitionAnimator;

   var scheme$12 = {
     '': 'page--*',
     '.page__content': 'page--*__content',
     '.page__background': 'page--*__background'
   };

   var nullToolbarElement = document.createElement('ons-toolbar');

   /**
    * @element ons-page
    * @category page
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     This component defines the root of each page. If the content is large it will become scrollable.
    *
    *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
    *   [/en]
    *   [ja][/ja]
    * @tutorial vanilla/Reference/page
    * @guide ManagingMultiplePages
    *   [en]Managing multiple pages[/en]
    *   [ja][/ja]
    * @guide Pagelifecycle
    *   [en]Page life cycle events[/en]
    *   [ja][/ja]
    * @guide HandlingBackButton
    *   [en]Handling back button[/en]
    *   [ja][/ja]
    * @guide OverridingCSSstyles
    *   [en]Overriding CSS styles[/en]
    *   [ja]CSS[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-toolbar
    *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
    *   [ja][/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left">
    *       <ons-back-button>Back</ons-back-button>
    *     </div>
    *     <div class="center">Title</div>
    *     <div class="right">
    *       <ons-toolbar-button>
    *         <ons-icon icon="md-menu"></ons-icon>
    *       </ons-toolbar-button>
    *     </div>
    *   </ons-toolbar>
    *
    *   <p>Page content</p>
    * </ons-page>
    *
    * // Infinite Scroll handler
    * page.onInfiniteScroll = function(done) {
    *   loadMore().then(done);
    * };
    */

   var PageElement = function (_BaseElement) {
     babelHelpers.inherits(PageElement, _BaseElement);

     function PageElement() {
       babelHelpers.classCallCheck(this, PageElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PageElement).apply(this, arguments));
     }

     babelHelpers.createClass(PageElement, [{
       key: 'createdCallback',


       /**
        * @event init
        * @description
        *   [en]Fired right after the page is attached.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event show
        * @description
        *   [en]Fired right after the page is shown.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event hide
        * @description
        *   [en]Fired right after the page is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event destroy
        * @description
        *   [en]Fired right before the page is destroyed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Specify modifier name to specify custom styles.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute on-infinite-scroll
        * @type {String}
        * @description
        *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this.classList.add('page');

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           _this2._isShown = false;
           _this2._contentElement = _this2._getContentElement();
           _this2._isMuted = _this2.hasAttribute('_muted');
           _this2._skipInit = _this2.hasAttribute('_skipinit');
           _this2.pushedOptions = {};
         });
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         contentReady(this, function () {
           if (!_this3._isMuted) {
             if (_this3._skipInit) {
               _this3.removeAttribute('_skipinit');
             } else {
               setImmediate(function () {
                 return util.triggerElementEvent(_this3, 'init');
               });
             }
           }

           if (!util.hasAnyComponentAsParent(_this3)) {
             setImmediate(function () {
               return _this3._show();
             });
           }

           _this3._tryToFillStatusBar();

           if (_this3.hasAttribute('on-infinite-scroll')) {
             _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
           }
         });
       }
     }, {
       key: 'updateBackButton',
       value: function updateBackButton(show) {
         if (this.backButton) {
           show ? this.backButton.show() : this.backButton.hide();
         }
       }
     }, {
       key: '_tryToFillStatusBar',
       value: function _tryToFillStatusBar() {
         var _this4 = this;

         internal.autoStatusBarFill(function () {
           var filled = util.findParent(_this4, function (e) {
             return e.hasAttribute('status-bar-fill');
           });
           util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
         });
       }
     }, {
       key: '_hasAPageControlChild',
       value: function _hasAPageControlChild() {
         return util.findChild(this._contentElement, function (e) {
           return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
         });
       }

       /**
        * @property onInfiniteScroll
        * @description
        *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
        *  [ja][/ja]
        */

     }, {
       key: '_onScroll',
       value: function _onScroll() {
         var _this5 = this;

         var c = this._contentElement,
             overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

         if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
           this._loadingContent = true;
           this._onInfiniteScroll(function () {
             return _this5._loadingContent = false;
           });
         }
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_getContentElement',


       /**
        * @return {HTMLElement}
        */
       value: function _getContentElement() {
         var result = util.findChild(this, '.page__content');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__content" element.');
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_canAnimateToolbar',
       value: function _canAnimateToolbar() {
         if (util.findChild(this, 'ons-toolbar')) {
           return true;
         }
         return !!util.findChild(this._contentElement, function (el) {
           return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
         });
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBackgroundElement',
       value: function _getBackgroundElement() {
         var result = util.findChild(this, '.page__background');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__background" element.');
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBottomToolbarElement',
       value: function _getBottomToolbarElement() {
         return util.findChild(this, 'ons-bottom-toolbar') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarElement',
       value: function _getToolbarElement() {
         return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
       }

       /**
        * Register toolbar element to this page.
        *
        * @param {HTMLElement} element
        */

     }, {
       key: '_registerToolbar',
       value: function _registerToolbar(element) {
         this.insertBefore(element, this.children[0]);
       }

       /**
        * Register toolbar element to this page.
        *
        * @param {HTMLElement} element
        */

     }, {
       key: '_registerBottomToolbar',
       value: function _registerBottomToolbar(element) {
         this.classList.add('page-with-bottom-toolbar');
         this.appendChild(element);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this6 = this;

         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$12);
         } else if (name === '_muted') {
           this._isMuted = this.hasAttribute('_muted');
         } else if (name === '_skipinit') {
           this._skipInit = this.hasAttribute('_skipinit');
         } else if (name === 'on-infinite-scroll') {
           if (current === null) {
             this.onInfiniteScroll = null;
           } else {
             this.onInfiniteScroll = function (done) {
               var f = util.findFromPath(current);
               _this6.onInfiniteScroll = f;
               f(done);
             };
           }
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this7 = this;

         autoStyle.prepare(this);

         if (!util.findChild(this, '.page__content')) {
           (function () {
             var content = util.create('.page__content');

             util.arrayFrom(_this7.childNodes).forEach(function (node) {
               if (!node.classList || !node.classList.contains('page__background')) {
                 content.appendChild(node);
               }
             });

             _this7.appendChild(content);
           })();
         }

         if (!util.findChild(this, '.page__background')) {
           var background = util.create('.page__background');
           this.insertBefore(background, util.findChild(this, '.page__content'));
         }

         ModifierUtil.initModifier(this, scheme$12);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_registerExtraElement',
       value: function _registerExtraElement(element) {
         var extra = util.findChild(this, '.page__extra');
         if (!extra) {
           extra = util.create('.page__extra', { zIndex: 10001 });
           this.appendChild(extra);
         }

         extra.appendChild(element);
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this._isShown && util.isAttached(this)) {
           this._isShown = true;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'show');
           }

           util.propagateAction(this._contentElement, '_show');
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this._isShown) {
           this._isShown = false;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'hide');
           }

           util.propagateAction(this._contentElement, '_hide');
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         this._hide();

         if (!this._isMuted) {
           util.triggerElementEvent(this, 'destroy');
         }

         if (this.onDeviceBackButton) {
           this.onDeviceBackButton.destroy();
         }

         util.propagateAction(this._contentElement, '_destroy');

         this.remove();
       }

       /**
        * @property data
        * @type {*}
        * @description
        *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'name',
       set: function set(str) {
         this.setAttribute('name', str);
       },
       get: function get() {
         return this.getAttribute('name');
       }
     }, {
       key: 'backButton',
       get: function get() {
         return this.querySelector('ons-back-button');
       }
     }, {
       key: 'onInfiniteScroll',
       set: function set(value) {
         if (value === null) {
           this._onInfiniteScroll = null;
           this._contentElement.removeEventListener('scroll', this._boundOnScroll);
           return;
         }
         if (!(value instanceof Function)) {
           throw new Error('onInfiniteScroll must be a function or null');
         }
         if (!this._onInfiniteScroll) {
           this._infiniteScrollLimit = 0.9;
           this._boundOnScroll = this._onScroll.bind(this);
           this._contentElement.addEventListener('scroll', this._boundOnScroll);
         }
         this._onInfiniteScroll = value;
       },
       get: function get() {
         return this._onInfiniteScroll;
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }]);
     return PageElement;
   }(BaseElement);

   window.OnsPageElement = document.registerElement('ons-page', {
     prototype: PageElement.prototype
   });

   var PopoverAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function PopoverAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, PopoverAnimator);

       this.options = util.extend({
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         duration: 0.2,
         delay: 0
       }, options);
     }

     babelHelpers.createClass(PopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         callback();
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         callback();
       }
     }, {
       key: '_animate',
       value: function _animate(element, _ref) {
         var from = _ref.from;
         var to = _ref.to;
         var options = _ref.options;
         var callback = _ref.callback;
         var _ref$restore = _ref.restore;
         var restore = _ref$restore === undefined ? false : _ref$restore;
         var animation = _ref.animation;

         options = util.extend({}, this.options, options);

         if (animation) {
           from = animation.from;
           to = animation.to;
         }

         animation = animit(element);
         if (restore) {
           animation = animation.saveStyle();
         }
         animation = animation.queue(from).wait(options.delay).queue({
           css: to,
           duration: options.duration,
           timing: options.timing
         });
         if (restore) {
           animation = animation.restoreStyle();
         }
         if (callback) {
           animation = animation.queue(function (done) {
             callback();
             done();
           });
         }
         return animation;
       }
     }, {
       key: '_animateAll',
       value: function _animateAll(element, animations) {
         var _this = this;

         Object.keys(animations).forEach(function (key) {
           return _this._animate(element[key], animations[key]).play();
         });
       }
     }]);
     return PopoverAnimator;
   }();

   var fade = {
     out: {
       from: { opacity: 1.0 },
       to: { opacity: 0 }
     },
     in: {
       from: { opacity: 0 },
       to: { opacity: 1.0 }
     }
   };

   var MDFadePopoverAnimator = function (_PopoverAnimator) {
     babelHelpers.inherits(MDFadePopoverAnimator, _PopoverAnimator);

     function MDFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, MDFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(MDFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: { animation: fade.in, restore: true, callback: callback }
         });
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.out,
           _popover: { animation: fade.out, restore: true, callback: callback }
         });
       }
     }]);
     return MDFadePopoverAnimator;
   }(PopoverAnimator);

   var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
     babelHelpers.inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

     function IOSFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, IOSFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(IOSFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: {
             from: {
               transform: 'scale3d(1.3, 1.3, 1.0)',
               opacity: 0
             },
             to: {
               transform: 'scale3d(1.0, 1.0,  1.0)',
               opacity: 1.0
             },
             restore: true,
             callback: callback
           }
         });
       }
     }]);
     return IOSFadePopoverAnimator;
   }(MDFadePopoverAnimator);

   var animators = { PopoverAnimator: PopoverAnimator, IOSFadePopoverAnimator: IOSFadePopoverAnimator, MDFadePopoverAnimator: MDFadePopoverAnimator };

   var scheme$13 = {
     '.popover': 'popover--*',
     '.popover-mask': 'popover-mask--*',
     '.popover__container': 'popover__container--*',
     '.popover__content': 'popover__content--*',
     '.popover__arrow': 'popover__arrow--*'
   };

   var _animatorDict$4 = {
     'default': function _default() {
       return platform.isAndroid() ? animators.MDFadePopoverAnimator : animators.IOSFadePopoverAnimator;
     },
     'none': animators.PopoverAnimator,
     'fade-ios': animators.IOSFadePopoverAnimator,
     'fade-md': animators.MDFadePopoverAnimator
   };

   var templateSource = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

   var positions = {
     up: 'bottom',
     left: 'right',
     down: 'top',
     right: 'left'
   };

   var directions = Object.keys(positions);
   /**
    * @element ons-popover
    * @category popover
    * @description
    *  [en]
    *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
    *
    *    Another common way to use the popover is to display a menu when a button on the screen is tapped.
    *  [/en]
    *  [ja][/ja]
    * @codepen ZYYRKo
    * @tutorial vanilla/Reference/popover
    * @example
    * <ons-button onclick="showPopover(this)">
    *   Click me!
    * </ons-button>
    *
    * <ons-popover direction="down" id="popover">
    *   <p>This is a popover!</p>
    * </ons-popover>
    *
    * <script>
    *   var showPopover = function(element) {
    *     var popover = document.getElementById('popover');
    *     popover.show(element);
    *   };
    * </script>
    */

   var PopoverElement = function (_BaseElement) {
     babelHelpers.inherits(PopoverElement, _BaseElement);

     function PopoverElement() {
       babelHelpers.classCallCheck(this, PopoverElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PopoverElement).apply(this, arguments));
     }

     babelHelpers.createClass(PopoverElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
           _this2._initAnimatorFactory();
         });

         this._doorLock = new DoorLock();
         this._boundOnChange = this._onChange.bind(this);
         this._boundCancel = this._cancel.bind(this);
       }
     }, {
       key: '_initAnimatorFactory',
       value: function _initAnimatorFactory() {
         var factory = new AnimatorFactory({
           animators: _animatorDict$4,
           baseClass: animators.PopoverAnimator,
           baseClassName: 'PopoverAnimator',
           defaultAnimation: this.getAttribute('animation') || 'default'
         });
         this._animator = function (options) {
           return factory.newAnimator(options);
         };
       }
     }, {
       key: '_positionPopover',
       value: function _positionPopover(target) {
         var radius = this._radius;
         var el = this._content;
         var margin = this._margin;

         var pos = target.getBoundingClientRect();
         var isMD = util.hasModifier(this, 'material');
         var cover = isMD && this.hasAttribute('cover-target');

         var distance = {
           top: pos.top - margin,
           left: pos.left - margin,
           right: window.innerWidth - pos.right - margin,
           bottom: window.innerHeight - pos.bottom - margin
         };

         var _calculateDirections2 = this._calculateDirections(distance);

         var vertical = _calculateDirections2.vertical;
         var primary = _calculateDirections2.primary;
         var secondary = _calculateDirections2.secondary;

         this._popover.classList.add('popover--' + primary);

         var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
         this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
         el.style[primary] = 0;

         var l = vertical ? 'width' : 'height';
         var sizes = function (style) {
           return {
             width: parseInt(style.getPropertyValue('width')),
             height: parseInt(style.getPropertyValue('height'))
           };
         }(window.getComputedStyle(el));

         el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
         this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

         this._setTransformOrigin(distance, sizes, pos, primary);

         // Prevent animit from restoring the style.
         el.removeAttribute('data-animit-orig-style');
       }
     }, {
       key: '_setTransformOrigin',
       value: function _setTransformOrigin(distance, sizes, pos, primary) {
         var calc = function calc(a, o, l) {
           return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
         };
         var x = calc('left', 'right', 'width') + 'px';
         var y = calc('top', 'bottom', 'height') + 'px';

         util.extend(this._popover.style, {
           transformOrigin: x + ' ' + y,
           webkitTransformOriginX: x,
           webkitTransformOriginY: y
         });
       }
     }, {
       key: '_calculateDirections',
       value: function _calculateDirections(distance) {
         var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
           return positions[e];
         });
         var primary = options.sort(function (a, b) {
           return distance[a] - distance[b];
         })[0];
         var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
         var secondary = void 0;

         if (vertical) {
           secondary = distance.left < distance.right ? 'left' : 'right';
         } else {
           secondary = distance.top < distance.bottom ? 'top' : 'bottom';
         }

         return { vertical: vertical, primary: primary, secondary: secondary };
       }
     }, {
       key: '_clearStyles',
       value: function _clearStyles() {
         var _this3 = this;

         ['top', 'bottom', 'left', 'right'].forEach(function (e) {
           _this3._arrow.style[e] = _this3._content.style[e] = _this3.style[e] = '';
           _this3._popover.classList.remove('popover--' + e);
         });
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         var _this4 = this;

         setImmediate(function () {
           if (_this4._currentTarget) {
             _this4._positionPopover(_this4._currentTarget);
           }
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.classList.contains('popover')) {
           return;
         }

         this.classList.add('popover');

         var hasDefaultContainer = this._popover && this._content;

         if (hasDefaultContainer) {

           if (!this._mask) {
             var mask = document.createElement('div');
             mask.classList.add('popover-mask');
             this.insertBefore(mask, this.firstChild);
           }

           if (!this._arrow) {
             var arrow = document.createElement('div');
             arrow.classList.add('popover__arrow');
             this._popover.appendChild(arrow);
           }
         } else {

           var template = templateSource.cloneNode(true);
           var content = template.querySelector('.popover__content');

           while (this.childNodes[0]) {
             content.appendChild(this.childNodes[0]);
           }

           this.appendChild(template);
         }

         if (this.hasAttribute('style')) {
           this._popover.setAttribute('style', this.getAttribute('style'));
           this.removeAttribute('style');
         }

         if (this.hasAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme$13);
       }
     }, {
       key: '_prepareAnimationOptions',
       value: function _prepareAnimationOptions(options) {
         if (options.animation && !(options.animation in _animatorDict$4)) {
           throw new Error('Animator ' + options.animation + ' is not registered.');
         }

         options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
       }
     }, {
       key: '_executeAction',
       value: function _executeAction(actions) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var callback = options.callback;
         var action = actions.action;
         var before = actions.before;
         var after = actions.after;


         this._prepareAnimationOptions(options);

         var canceled = false;
         util.triggerElementEvent(this, 'pre' + action, { // synchronous
           popover: this,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           return Promise.reject('Canceled in pre' + action + ' event.');
         }

         return new Promise(function (resolve) {
           _this5._doorLock.waitUnlock(function () {
             var unlock = _this5._doorLock.lock();

             before && before();

             contentReady(_this5, function () {
               _this5._animator(options)[action](_this5, function () {
                 after && after();

                 unlock();

                 util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

                 callback && callback();
                 resolve(_this5);
               });
             });
           });
         });
       }

       /**
        * @method show
        * @signature show(target, [options])
        * @param {String|Event|HTMLElement} target
        *   [en]Target element. Can be either a CSS selector, an event object or a DOM element.[/en]
        *   [ja]CSSeventDOM[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
        *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the popover has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
        *   [ja]target$eventDOMCSS[/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show(target) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (typeof target === 'string') {
           target = document.querySelector(target);
         } else if (target instanceof Event) {
           target = target.target;
         }
         if (!(target instanceof HTMLElement)) {
           throw new Error('Invalid target');
         }

         return this._executeAction({
           action: 'show',
           before: function before() {
             _this6.style.display = 'block';
             _this6._currentTarget = target;
             _this6._positionPopover(target);
           }
         }, options);
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
        *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the popover has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Close the popover.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this7 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._executeAction({
           action: 'hide',
           after: function after() {
             _this7.style.display = 'none';
             _this7._clearStyles();
           }
         }, options);
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_resetBackButtonHandler',
       value: function _resetBackButtonHandler() {
         var _this8 = this;

         // do we need this twice?
         this.onDeviceBackButton = function (e) {
           return _this8.cancelable ? _this8._cancel() : e.callParentHandler();
         };
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this9 = this;

         this._resetBackButtonHandler();

         contentReady(this, function () {
           _this9._margin = _this9._margin || parseInt(window.getComputedStyle(_this9).getPropertyValue('top'));
           _this9._radius = parseInt(window.getComputedStyle(_this9._content).getPropertyValue('border-top-left-radius'));

           _this9._mask.addEventListener('click', _this9._boundCancel, false);

           _this9._resetBackButtonHandler();

           window.addEventListener('resize', _this9._boundOnChange, false);
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         var _this10 = this;

         contentReady(this, function () {
           _this10._mask.removeEventListener('click', _this10._boundCancel, false);

           _this10._backButtonHandler.destroy();
           _this10._backButtonHandler = null;

           window.removeEventListener('resize', _this10._boundOnChange, false);
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$13);
         }
         if (name === 'direction') {
           return this._boundOnChange();
         }
         if (name === 'animation') {
           this._initAnimatorFactory();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this11 = this;

         if (this.cancelable) {
           this.hide({
             callback: function callback() {
               util.triggerElementEvent(_this11, 'dialog-cancel');
             }
           });
         }
       }
     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        *   [en]Fired just before the popover is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the popover is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the popover is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        *   [en]Fired just after the popover is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the popover.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *  [en]
        *    A space separated list of directions. If more than one direction is specified,
        *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
        *  [/en]
        *  [ja]
        *    
        *    "up", "down", "left", "right"4
        *    
        *  [/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute cover-target
        * @description
        *   [en]If set the popover will cover the target on the screen.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @description
        *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute mask-color
        * @type {Color}
        * @description
        *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
        *   [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       get: function get() {
         return util.findChild(this, '.popover-mask');
       }
     }, {
       key: '_popover',
       get: function get() {
         return util.findChild(this, '.popover__container');
       }
     }, {
       key: '_content',
       get: function get() {
         return util.findChild(this._popover, '.popover__content');
       }
     }, {
       key: '_arrow',
       get: function get() {
         return util.findChild(this._popover, '.popover__arrow');
       }
     }, {
       key: 'visible',
       get: function get() {
         return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]
        *     A boolean value that specifies whether the popover is cancelable or not.
        *
        *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
        *   [/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }]);
     return PopoverElement;
   }(BaseElement);

   window.OnsPopoverElement = document.registerElement('ons-popover', {
     prototype: PopoverElement.prototype
   });

   /**
    * @param {String} name
    * @param {PopoverAnimator} Animator
    */
   window.OnsPopoverElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof animators.PopoverAnimator)) {
       throw new Error('"Animator" param must inherit PopoverAnimator');
     }
     _animatorDict$4[name] = Animator;
   };

   window.OnsPopoverElement.PopoverAnimator = animators.PopoverAnimator;

   var scheme$14 = {
     '.progress-bar': 'progress-bar--*',
     '.progress-bar__primary': 'progress-bar__primary--*',
     '.progress-bar__secondary': 'progress-bar__secondary--*'
   };

   var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

   /**
    * @element ons-progress-bar
    * @category progress
    * @description
    *   [en]
    *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
    *   [/en]
    *   [ja][/ja]
    * @codepen zvQbGj
    * @tutorial vanilla/Reference/progress
    * @seealso ons-progress-circular
    *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
    *   [ja][/ja]
    * @example
    * <ons-progress-bar
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-bar>
    *
    * <ons-progress-bar
    *  indeterminate>
    * </ons-progress-bar>
    */

   var ProgressBarElement = function (_BaseElement) {
     babelHelpers.inherits(ProgressBarElement, _BaseElement);

     function ProgressBarElement() {
       babelHelpers.classCallCheck(this, ProgressBarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressBarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressBarElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$14);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-bar--indeterminate');
           this._template.classList.remove('progress-bar--determinate');
         } else {
           this._template.classList.add('progress-bar--determinate');
           this._template.classList.remove('progress-bar--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         this._primary.style.width = this.hasAttribute('value') ? this.getAttribute('value') + '%' : '0%';
         this._secondary.style.width = this.hasAttribute('secondary-value') ? this.getAttribute('secondary-value') + '%' : '0%';
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$14);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'value',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('value') || '0');
       }

       /**
        * @property secondaryValue
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: 'secondaryValue',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('secondary-value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('secondary-value') || '0');
       }

       /**
        * @property indeterminate
        * @type {Boolean}
        * @description
        *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'indeterminate',
       set: function set(value) {
         if (value) {
           this.setAttribute('indeterminate', '');
         } else {
           this.removeAttribute('indeterminate');
         }
       },
       get: function get() {
         return this.hasAttribute('indeterminate');
       }
     }]);
     return ProgressBarElement;
   }(BaseElement);

   window.OnsProgressBarElement = document.registerElement('ons-progress-bar', {
     prototype: ProgressBarElement.prototype
   });

   var scheme$15 = {
     '.progress-circular': 'progress-circular--*',
     '.progress-circular__primary': 'progress-circular__primary--*',
     '.progress-circular__secondary': 'progress-circular__secondary--*'
   };

   var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

   /**
    * @element ons-progress-circular
    * @category progress
    * @description
    *   [en]
    *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
    *   [/en]
    *   [ja][/ja]
    * @codepen EVzMjR
    * @tutorial vanilla/Reference/progress
    * @example
    * <ons-progress-circular
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-circular>
    *
    * <ons-progress-circular
    *  indeterminate>
    * </ons-progress-circular>
    */

   var ProgressCircularElement = function (_BaseElement) {
     babelHelpers.inherits(ProgressCircularElement, _BaseElement);

     function ProgressCircularElement() {
       babelHelpers.classCallCheck(this, ProgressCircularElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressCircularElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressCircularElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-circular--indeterminate');
           this._template.classList.remove('progress-circular--determinate');
         } else {
           this._template.classList.add('progress-circular--determinate');
           this._template.classList.remove('progress-circular--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         if (this.hasAttribute('value')) {
           var per = Math.ceil(this.getAttribute('value') * 251.32 * 0.01);
           this._primary.style['stroke-dasharray'] = per + '%, 251.32%';
         }
         if (this.hasAttribute('secondary-value')) {
           var _per = Math.ceil(this.getAttribute('secondary-value') * 251.32 * 0.01);
           this._secondary.style['stroke-dasharray'] = _per + '%, 251.32%';
         }
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template$1.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$15);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'value',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('value') || '0');
       }

       /**
        * @property secondaryValue
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: 'secondaryValue',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('secondary-value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('secondary-value') || '0');
       }

       /**
        * @property indeterminate
        * @type {Boolean}
        * @description
        *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'indeterminate',
       set: function set(value) {
         if (value) {
           this.setAttribute('indeterminate', '');
         } else {
           this.removeAttribute('indeterminate');
         }
       },
       get: function get() {
         return this.hasAttribute('indeterminate');
       }
     }]);
     return ProgressCircularElement;
   }(BaseElement);

   window.OnsProgressCircularElement = document.registerElement('ons-progress-circular', {
     prototype: ProgressCircularElement.prototype
   });

   var STATE_INITIAL = 'initial';
   var STATE_PREACTION = 'preaction';
   var STATE_ACTION = 'action';

   /**
    * @element ons-pull-hook
    * @category pull-hook
    * @description
    *   [en]
    *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
    *
    *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
    *   [/en]
    *   [ja][/ja]
    * @codepen WbJogM
    * @tutorial vanilla/Reference/pull-hook
    * @guide UsingPullHook
    *   [en]How to use Pull Hook[/en]
    *   [ja][/ja]
    * @example
    * <ons-page>
    *   <ons-pull-hook>
    *     Release to refresh
    *   </ons-pull-hook>
    * </ons-page>
    *
    * <script>
    *   document.querySelector('ons-pull-hook').onAction = function(done) {
    *     setTimeout(done, 1000);
    *   };
    * </script>
    */

   var PullHookElement = function (_BaseElement) {
     babelHelpers.inherits(PullHookElement, _BaseElement);

     function PullHookElement() {
       babelHelpers.classCallCheck(this, PullHookElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PullHookElement).apply(this, arguments));
     }

     babelHelpers.createClass(PullHookElement, [{
       key: 'createdCallback',


       /**
        * @event changestate
        * @description
        *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
        *   [ja]"initial", "preaction", "action"[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.pullHook
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {String} event.state
        *   [en]Current state.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
        *   [ja]disabled[/ja]
        */

       /**
        * @attribute height
        * @type {String}
        * @description
        *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
        *   [ja]pull down"preaction""64px"[/ja]
        */

       /**
        * @attribute threshold-height
        * @type {String}
        * @description
        *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
        *   [ja]pull down"action"[/ja]
        */

       /**
        * @attribute fixed-content
        * @description
        *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnScroll = this._onScroll.bind(this);

         this._currentTranslation = 0;

         this._ensureScrollElement();

         this._setState(STATE_INITIAL, true);
         this._setStyle();
       }
     }, {
       key: '_createScrollElement',
       value: function _createScrollElement() {
         if (this.parentElement.classList.contains('scroll')) {
           return this.parentElement;
         }

         var scrollElement = util.createElement('<div class="scroll"><div>');

         var pageElement = this.parentElement;

         scrollElement.appendChild(this);
         while (pageElement.firstChild) {
           scrollElement.appendChild(pageElement.firstChild);
         }
         pageElement.appendChild(scrollElement);

         return scrollElement;
       }
     }, {
       key: '_ensureScrollElement',
       value: function _ensureScrollElement() {
         if (this.parentElement && !this._scrollElement) {
           this._scrollElement = this._createScrollElement();
         }
       }
     }, {
       key: '_setStyle',
       value: function _setStyle() {
         var height = this.height;

         this.style.top = '-' + height + 'px';
         this.style.height = height + 'px';
         this.style.lineHeight = height + 'px';
       }
     }, {
       key: '_onScroll',
       value: function _onScroll(event) {
         var element = this._pageElement;

         if (element.scrollTop < 0) {
           element.scrollTop = 0;
         }
       }
     }, {
       key: '_generateTranslationTransform',
       value: function _generateTranslationTransform(scroll) {
         return 'translate3d(0px, ' + scroll + 'px, 0px)';
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var _this2 = this;

         if (this.disabled) {
           return;
         }

         // Ignore when dragging left and right.
         if (event.gesture.direction === 'left' || event.gesture.direction === 'right') {
           return;
         }

         // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
         // there will be no inertial scroll when scrolling down. Allowing default scrolling will
         // kill all 'touchmove' events.
         var element = this._pageElement;
         element.scrollTop = this._startScroll - event.gesture.deltaY;
         if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
           event.gesture.preventDefault();
         }

         if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
           this._transitionDragLength = event.gesture.deltaY;

           var direction = event.gesture.interimDirection;
           if (direction === 'down') {
             this._transitionDragLength -= 1;
           } else {
             this._transitionDragLength += 1;
           }
         }

         var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

         if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
           event.gesture.stopDetect();

           setImmediate(function () {
             return _this2._finish();
           });
         } else if (scroll >= this.height) {
           this._setState(STATE_PREACTION);
         } else {
           this._setState(STATE_INITIAL);
         }

         event.stopPropagation();
         this._translateTo(scroll);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         if (this.disabled) {
           return;
         }

         this._startScroll = this._getCurrentScroll();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         if (this.disabled) {
           return;
         }

         if (this._currentTranslation > 0) {
           var scroll = this._currentTranslation;

           if (scroll > this.height) {
             this._finish();
           } else {
             this._translateTo(0, { animate: true });
           }
         }
       }

       /**
        * @property onAction
        * @type {Function}
        * @description
        *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_finish',
       value: function _finish() {
         var _this3 = this;

         this._setState(STATE_ACTION);
         this._translateTo(this.height, { animate: true });
         var action = this.onAction || function (done) {
           return done();
         };
         action(function () {
           _this3._translateTo(0, { animate: true });
           _this3._setState(STATE_INITIAL);
         });
       }

       /**
        * @property height
        * @type {Number}
        * @description
        *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_thresholdHeightEnabled',
       value: function _thresholdHeightEnabled() {
         var th = this.thresholdHeight;
         return th > 0 && th >= this.height;
       }
     }, {
       key: '_setState',
       value: function _setState(state, noEvent) {
         var lastState = this._getState();

         this.setAttribute('state', state);

         if (!noEvent && lastState !== this._getState()) {
           util.triggerElementEvent(this, 'changestate', {
             pullHook: this,
             state: state,
             lastState: lastState
           });
         }
       }
     }, {
       key: '_getState',
       value: function _getState() {
         return this.getAttribute('state');
       }

       /**
        * @property state
        * @readonly
        * @type {String}
        * @description
        *   [en]Current state of the element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_getCurrentScroll',
       value: function _getCurrentScroll() {
         return this._pageElement.scrollTop;
       }

       /**
        * @property pullDistance
        * @readonly
        * @type {Number}
        * @description
        *   [en]The current number of pixels the pull hook has moved.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_isContentFixed',
       value: function _isContentFixed() {
         return this.hasAttribute('fixed-content');
       }
     }, {
       key: '_getScrollableElement',
       value: function _getScrollableElement() {
         if (this._isContentFixed()) {
           return this;
         } else {
           return this._scrollElement;
         }
       }

       /**
        * @param {Number} scroll
        * @param {Object} options
        * @param {Function} [options.callback]
        */

     }, {
       key: '_translateTo',
       value: function _translateTo(scroll) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (this._currentTranslation == 0 && scroll == 0) {
           return;
         }

         var done = function done() {
           if (scroll === 0 && !_this4._isContentFixed()) {
             _this4._getScrollableElement().removeAttribute('style');
           }

           if (options.callback) {
             options.callback();
           }
         };

         this._currentTranslation = scroll;

         if (options.animate) {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }, {
             duration: 0.3,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).play(done);
         } else {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }).play(done);
         }
       }
     }, {
       key: '_getMinimumScroll',
       value: function _getMinimumScroll() {
         var scrollHeight = this._scrollElement.getBoundingClientRect().height;
         var pageHeight = this._pageElement.getBoundingClientRect().height;

         return scrollHeight > pageHeight ? -(scrollHeight - pageHeight) : 0;
       }
     }, {
       key: '_createEventListeners',
       value: function _createEventListeners() {
         this._gestureDetector = new GestureDetector(this._pageElement, {
           dragMinDistance: 1,
           dragDistanceCorrection: false
         });

         // Bind listeners
         this._gestureDetector.on('drag', this._boundOnDrag);
         this._gestureDetector.on('dragstart', this._boundOnDragStart);
         this._gestureDetector.on('dragend', this._boundOnDragEnd);

         this._scrollElement.parentElement.addEventListener('scroll', this._boundOnScroll, false);
       }
     }, {
       key: '_destroyEventListeners',
       value: function _destroyEventListeners() {
         if (this._gestureDetector) {
           this._gestureDetector.off('drag', this._boundOnDrag);
           this._gestureDetector.off('dragstart', this._boundOnDragStart);
           this._gestureDetector.off('dragend', this._boundOnDragEnd);

           this._gestureDetector.dispose();
           this._gestureDetector = null;
         }

         if (this._scrollElement && this._scrollElement.parentElement) {
           this._scrollElement.parentElement.removeEventListener('scroll', this._boundOnScroll, false);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._ensureScrollElement();

         this._pageElement = this._scrollElement.parentElement;

         if (!this._pageElement.classList.contains('page__content')) {
           throw new Error('<ons-pull-hook> must be a direct descendant of an <ons-page> element.');
         }

         this._createEventListeners();
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._destroyEventListeners();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'height',
       set: function set(value) {
         if (!util.isInteger(value)) {
           throw new Error('The height must be an integer');
         }

         this.setAttribute('height', value + 'px');
       },
       get: function get() {
         return parseInt(this.getAttribute('height') || '64', 10);
       }

       /**
        * @property thresholdHeight
        * @type {Number}
        * @description
        *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'thresholdHeight',
       set: function set(value) {
         if (!util.isInteger(value)) {
           throw new Error('The threshold height must be an integer');
         }

         this.setAttribute('threshold-height', value + 'px');
       },
       get: function get() {
         return parseInt(this.getAttribute('threshold-height') || '96', 10);
       }
     }, {
       key: 'state',
       get: function get() {
         return this._getState();
       }
     }, {
       key: 'pullDistance',
       get: function get() {
         return this._currentTranslation;
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return PullHookElement;
   }(BaseElement);

   window.OnsPullHookElement = document.registerElement('ons-pull-hook', {
     prototype: PullHookElement.prototype
   });

   window.OnsPullHookElement.STATE_ACTION = STATE_ACTION;
   window.OnsPullHookElement.STATE_INITIAL = STATE_INITIAL;
   window.OnsPullHookElement.STATE_PREACTION = STATE_PREACTION;

   /**
    * @class AnimatorCSS - implementation of Animator class using css transitions
    */

   var AnimatorCSS = function () {
     babelHelpers.createClass(AnimatorCSS, [{
       key: 'animate',


       /**
        * @method animate
        * @desc main animation function
        * @param {Element} element
        * @param {Object} finalCSS
        * @param {number} [duration=200] - duration in milliseconds
        * @return {Object} result
        * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
        * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
        * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
        * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
        * @example
        * ````
        *  var result = animator.animate(el, {opacity: 0.5}, 1000);
        *
        *  el.addEventListener('click', function(e){
        *    result.speed(200).then(function(){
        *      console.log('done');
        *    });
        *  }, 300);
        * ````
        */
       value: function animate(el, final) {
         var duration = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];

         var start = new Date().getTime(),
             initial = {},
             stopped = false,
             next = false,
             timeout = false,
             properties = Object.keys(final);

         var updateStyles = function updateStyles() {
           var s = window.getComputedStyle(el);
           properties.forEach(s.getPropertyValue.bind(s));
           s = el.offsetHeight;
         };

         var result = {
           stop: function stop() {
             var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

             timeout && clearTimeout(timeout);
             var k = Math.min(1, (new Date().getTime() - start) / duration);
             properties.forEach(function (i) {
               el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
             });
             el.style.transitionDuration = '0s';

             if (options.stopNext) {
               next = false;
             } else if (!stopped) {
               stopped = true;
               next && next();
             }
             return result;
           },
           then: function then(cb) {
             next = cb;
             if (stopped) {
               next && next();
             }
             return result;
           },
           speed: function speed(newDuration) {
             if (internal.config.animationsDisabled) {
               newDuration = 0;
             }
             if (!stopped) {
               (function () {
                 timeout && clearTimeout(timeout);

                 var passed = new Date().getTime() - start;
                 var k = passed / duration;
                 var remaining = newDuration * (1 - k);

                 properties.forEach(function (i) {
                   el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 updateStyles();

                 start = el.speedUpTime;
                 duration = remaining;

                 el.style.transitionDuration = duration / 1000 + 's';

                 properties.forEach(function (i) {
                   el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 timeout = setTimeout(result.stop, remaining);
               })();
             }
             return result;
           },
           finish: function finish() {
             var milliseconds = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

             var k = (new Date().getTime() - start) / duration;

             result.speed(milliseconds / (1 - k));
             return result;
           }
         };

         if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {
           return result;
         }

         var style = window.getComputedStyle(el);
         properties.forEach(function (e) {
           var v = parseFloat(style.getPropertyValue(e));
           initial[e] = isNaN(v) ? 0 : v;
         });

         if (!stopped) {
           el.style.transitionProperty = properties.join(',');
           el.style.transitionDuration = duration / 1000 + 's';

           properties.forEach(function (e) {
             el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
           });
         }

         timeout = setTimeout(result.stop, duration);
         this._onStopAnimations(el, result.stop);

         return result;
       }
     }]);

     function AnimatorCSS() {
       babelHelpers.classCallCheck(this, AnimatorCSS);

       this._queue = [];
       this._index = 0;
     }

     babelHelpers.createClass(AnimatorCSS, [{
       key: '_onStopAnimations',
       value: function _onStopAnimations(el, listener) {
         var queue = this._queue;
         var i = this._index++;
         queue[el] = queue[el] || [];
         queue[el][i] = function (options) {
           delete queue[el][i];
           if (queue[el] && queue[el].length == 0) {
             delete queue[el];
           }
           return listener(options);
         };
       }

       /**
       * @method stopAnimations
       * @desc stops active animations on a specified element
       * @param {Element|Array} element - element or array of elements
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAnimations',
       value: function stopAnimations(el) {
         var _this = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (Array.isArray(el)) {
           return el.forEach(function (el) {
             _this.stopAnimations(el, options);
           });
         }

         (this._queue[el] || []).forEach(function (e) {
           e(options || {});
         });
       }

       /**
       * @method stopAll
       * @desc stops all active animations
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAll',
       value: function stopAll() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.stopAnimations(Object.keys(this._queue), options);
       }

       /**
       * @method fade
       * @desc fades the element (short version for animate(el, {opacity: 0}))
       * @param {Element} element
       * @param {number} [duration=200]
       */

     }, {
       key: 'fade',
       value: function fade(el) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];

         return this.animate(el, { opacity: 0 }, duration);
       }
     }]);
     return AnimatorCSS;
   }();

   /**
    * @element ons-ripple
    * @category ripple
    * @description
    *   [en]
    *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
    *
    *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
    *   [/en]
    *   [ja]DOM[/ja]
    * @codepen wKQWdZ
    * @tutorial vanilla/Reference/ripple
    * @example
    * <div class="my-div">
    *  <ons-ripple></ons-ripple>
    * </div>
    *
    * <ons-button ripple>Click me!</ons-button>
    */

   var RippleElement = function (_BaseElement) {
     babelHelpers.inherits(RippleElement, _BaseElement);

     function RippleElement() {
       babelHelpers.classCallCheck(this, RippleElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RippleElement).apply(this, arguments));
     }

     babelHelpers.createClass(RippleElement, [{
       key: 'createdCallback',


       /**
        * @attribute color
        * @type {String}
        * @description
        *   [en]Color of the ripple effect.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute background
        * @type {String}
        * @description
        *   [en]Color of the background.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this.classList.add('ripple');
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         } else {
           this._background = this.getElementsByClassName('ripple__background')[0];
           this._wave = this.getElementsByClassName('ripple__wave')[0];
         }

         this._animator = new AnimatorCSS();

         ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this3 = this;

         ['_wave', '_background'].forEach(function (e) {
           _this3[e] = document.createElement('div');
           _this3[e].classList.add('ripple_' + e);
           _this3.appendChild(_this3[e]);
         });
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_calculateCoords',
       value: function _calculateCoords(e) {
         var x, y, h, w, r;
         var b = this.getBoundingClientRect();
         if (this._center) {
           x = b.width / 2;
           y = b.height / 2;
           r = Math.sqrt(x * x + y * y);
         } else {
           x = (e.clientX || e.changedTouches[0].clientX) - b.left;
           y = (e.clientY || e.changedTouches[0].clientY) - b.top;
           h = Math.max(y, b.height - y);
           w = Math.max(x, b.width - x);
           r = Math.sqrt(h * h + w * w);
         }
         return { x: x, y: y, r: r };
       }
     }, {
       key: '_rippleAnimation',
       value: function _rippleAnimation(e) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 300 : arguments[1];
         var _animator = this._animator;
         var _wave = this._wave;
         var _background = this._background;

         var _minR = this._minR;

         var _calculateCoords2 = this._calculateCoords(e);

         var x = _calculateCoords2.x;
         var y = _calculateCoords2.y;
         var r = _calculateCoords2.r;


         _animator.stopAll({ stopNext: 1 });
         _animator.animate(_background, { opacity: 1 }, duration);

         util.extend(_wave.style, {
           opacity: 1,
           top: y - _minR + 'px',
           left: x - _minR + 'px',
           width: 2 * _minR + 'px',
           height: 2 * _minR + 'px'
         });

         return _animator.animate(_wave, {
           top: y - r,
           left: x - r,
           height: 2 * r,
           width: 2 * r
         }, duration);
       }
     }, {
       key: '_updateParent',
       value: function _updateParent() {
         if (!this._parentUpdated && this.parentNode) {
           var computedStyle = window.getComputedStyle(this.parentNode);
           if (computedStyle.getPropertyValue('position') === 'static') {
             this.parentNode.style.position = 'relative';
           }
           this._parentUpdated = true;
         }
       }
     }, {
       key: '_onTap',
       value: function _onTap(e) {
         var _this4 = this;

         if (!this.disabled) {
           this._updateParent();
           this._rippleAnimation(e.gesture.srcEvent).then(function () {
             _this4._animator.fade(_this4._wave);
             _this4._animator.fade(_this4._background);
           });
         }
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this._updateParent();
           this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var _this5 = this;

         if (this._holding) {
           this._holding.speed(300).then(function () {
             _this5._animator.stopAll({ stopNext: true });
             _this5._animator.fade(_this5._wave);
             _this5._animator.fade(_this5._background);
           });

           this._holding = false;
         }

         document.removeEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this._holding) {
           return this._onRelease(e);
         }
         if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
           this._onTap(e);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._parentNode = this.parentNode;
         this._boundOnTap = this._onTap.bind(this);
         this._boundOnHold = this._onHold.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnRelease = this._onRelease.bind(this);

         if (internal.config.animationsDisabled) {
           this.disabled = true;
         } else {
           this._parentNode.addEventListener('tap', this._boundOnTap);
           this._parentNode.addEventListener('hold', this._boundOnHold);
           this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._parentNode.removeEventListener('tap', this._boundOnTap);
         this._parentNode.removeEventListener('hold', this._boundOnHold);
         this._parentNode.removeEventListener('dragstart', this._boundOnDragStart);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'start-radius') {
           this._minR = Math.max(0, parseFloat(current) || 0);
         }
         if (name === 'color' && current) {
           this._wave.style.background = current;
           if (!this.hasAttribute('background')) {
             this._background.style.background = current;
           }
         }
         if (name === 'background' && (current || last)) {
           if (current === 'none') {
             this._background.setAttribute('disabled', 'disabled');
             this._background.style.background = 'transparent';
           } else {
             if (this._background.hasAttribute('disabled')) {
               this._background.removeAttribute('disabled');
             }
             this._background.style.background = current;
           }
         }
         if (name === 'center') {
           this._center = current != null && current != 'false';
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return RippleElement;
   }(BaseElement);

   window.OnsRippleElement = document.registerElement('ons-ripple', {
     prototype: RippleElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @element ons-row
    * @category grid
    * @description
    *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
    *   [ja]ons-col[/ja]
    * @codepen GgujC {wide}
    * @guide Layouting
    *   [en]Layouting guide[/en]
    *   [ja][/ja]
    * @seealso ons-col
    *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
    *   [ja]ons-col[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
    *   [ja]Android 4.3iOS 6OSons-rowons-colons-colvertical-alignvertical-align[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
    *   [ja]topbottomcenter[/ja]
    */
   window.OnsRowElement = window.OnsRowElement ? window.OnsRowElement : document.registerElement('ons-row');

   var scheme$16 = {
     '': 'speed-dial__item--*'
   };

   /**
    * @element ons-speed-dial-item
    * @category speed-dial
    * @description
    *   [en]
    *     This component displays the child elements of the Material Design Speed dial component.
    *   [/en]
    *   [ja]
    *     Material DesignSpeed dial
    *   [/ja]
    * @codepen dYQYLg
    * @tutorial vanilla/Reference/speed-dial
    * @seealso ons-speed-dial
    *   [en]The `<ons-speed-dial>` component.[/en]
    *   [ja]ons-speed-dial[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-fab>
    *     <ons-icon icon="fa-twitter"></ons-icon>
    *   </ons-fab>
    *   <ons-speed-dial-item>A</ons-speed-dial-item>
    *   <ons-speed-dial-item>B</ons-speed-dial-item>
    *   <ons-speed-dial-item>C</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialItemElement = function (_BaseElement) {
     babelHelpers.inherits(SpeedDialItemElement, _BaseElement);

     function SpeedDialItemElement() {
       babelHelpers.classCallCheck(this, SpeedDialItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialItemElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         this._compile();

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$16);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         e.stopPropagation();
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('fab');
         this.classList.add('fab--mini');
         this.classList.add('speed-dial__item');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$16);
       }
     }]);
     return SpeedDialItemElement;
   }(BaseElement);

   window.OnsSpeedDialItemElement = document.registerElement('ons-speed-dial-item', {
     prototype: SpeedDialItemElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * Minimal utility library for manipulating element's style.
    */
   var styler = function styler(element, style) {
     return styler.css.apply(styler, arguments);
   };

   /**
    * Set element's style.
    *
    * @param {Element} element
    * @param {Object} styles
    * @return {Element}
    */
   styler.css = function (element, styles) {
     var keys = Object.keys(styles);
     keys.forEach(function (key) {
       if (key in element.style) {
         element.style[key] = styles[key];
       } else if (styler._prefix(key) in element.style) {
         element.style[styler._prefix(key)] = styles[key];
       } else {
         console.warn('No such style property: ' + key);
       }
     });
     return element;
   };

   /**
    * Add vendor prefix.
    *
    * @param {String} name
    * @return {String}
    */
   styler._prefix = function () {
     var styles = window.getComputedStyle(document.documentElement, '');
     var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

     return function (name) {
       return prefix + name.substr(0, 1).toUpperCase() + name.substr(1);
     };
   }();

   /**
    * @param {Element} element
    */
   styler.clear = function (element) {
     styler._clear(element);
   };

   /**
    * @param {Element} element
    */
   styler._clear = function (element) {
     var len = element.style.length;
     var style = element.style;
     var keys = [];
     for (var i = 0; i < len; i++) {
       keys.push(style[i]);
     }

     keys.forEach(function (key) {
       style[key] = '';
     });
   };

   var scheme$17 = {
     '': 'speed-dial--*'
   };

   /**
    * @element ons-speed-dial
    * @category speed-dial
    * @description
    *   [en]
    *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
    *
    *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
    *   [/en]
    *   [ja][/ja]
    * @codepen dYQYLg
    * @tutorial vanilla/Reference/speed-dial
    * @seealso ons-speed-dial-item
    *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
    *   [ja]ons-speed-dial-item[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-fab>
    *     <ons-icon icon="fa-twitter"></ons-icon>
    *   </ons-fab>
    *   <ons-speed-dial-item>A</ons-speed-dial-item>
    *   <ons-speed-dial-item>B</ons-speed-dial-item>
    *   <ons-speed-dial-item>C</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialElement = function (_BaseElement) {
     babelHelpers.inherits(SpeedDialElement, _BaseElement);

     function SpeedDialElement() {
       babelHelpers.classCallCheck(this, SpeedDialElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialElement, [{
       key: 'createdCallback',


       /**
        * @event open
        * @description
        *   [en]Fired when the menu items are shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event close
        * @description
        *   [en]Fired when the menu items are hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *   [en]
        *     Specify the vertical and horizontal position of the component.
        *     I.e. to display it in the top right corner specify "right top".
        *     Choose from "right", "left", "top" and "bottom".
        *   [/en]
        *   [ja]
        *     
        *     "right top"
        *     rightlefttopbottom
        *   [/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
        *   [ja]
        *     up, down, left, right
        *   [/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });

         this._shown = true;
         this._itemShown = false;
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (!this.classList.contains('speed__dial')) {
           this.classList.add('speed__dial');
           autoStyle.prepare(this);
           this._updateRipple();
           ModifierUtil.initModifier(this, scheme$17);

           if (this.hasAttribute('direction')) {
             this._updateDirection(this.getAttribute('direction'));
           } else {
             this._updateDirection('up');
           }
         }

         this._updatePosition();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$17);
             break;
           case 'ripple':
             contentReady(this, function () {
               return _this3._updateRipple();
             });
             break;
           case 'direction':
             contentReady(this, function () {
               return _this3._updateDirection(current);
             });
             break;
           case 'position':
             contentReady(this, function () {
               return _this3._updatePosition();
             });
             break;
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         if (!this.disabled && this._shown) {
           this.toggleItems();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this.inline) {
           this.show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (!this.inline) {
           this.hide();
         }
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         var fab = util.findChild(this, 'ons-fab');

         if (fab) {
           this.hasAttribute('ripple') ? fab.setAttribute('ripple', '') : fab.removeAttribute('ripple');
         }
       }
     }, {
       key: '_updateDirection',
       value: function _updateDirection(direction) {
         var children = this.items;
         for (var i = 0; i < children.length; i++) {
           styler(children[i], {
             transitionDelay: 25 * i + 'ms',
             bottom: 'auto',
             right: 'auto',
             top: 'auto',
             left: 'auto'
           });
         }
         switch (direction) {
           case 'up':
             for (var _i = 0; _i < children.length; _i++) {
               children[_i].style.bottom = 72 + 56 * _i + 'px';
               children[_i].style.right = '8px';
             }
             break;
           case 'down':
             for (var _i2 = 0; _i2 < children.length; _i2++) {
               children[_i2].style.top = 72 + 56 * _i2 + 'px';
               children[_i2].style.left = '8px';
             }
             break;
           case 'left':
             for (var _i3 = 0; _i3 < children.length; _i3++) {
               children[_i3].style.top = '8px';
               children[_i3].style.right = 72 + 56 * _i3 + 'px';
             }
             break;
           case 'right':
             for (var _i4 = 0; _i4 < children.length; _i4++) {
               children[_i4].style.top = '8px';
               children[_i4].style.left = 72 + 56 * _i4 + 'px';
             }
             break;
           default:
             throw new Error('Argument must be one of up, down, left or right.');
         }
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *   [en]Show the speed dial.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.querySelector('ons-fab').show();
         this._shown = true;
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *   [en]Hide the speed dial.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.hideItems();
         setTimeout(function () {
           _this4.querySelector('ons-fab').hide();
         }, 200);
         this._shown = false;
       }

       /**
        * @method showItems
        * @signature showItems()
        * @description
        *   [en]Show the speed dial items.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'showItems',
       value: function showItems() {

         if (this.hasAttribute('direction')) {
           this._updateDirection(this.getAttribute('direction'));
         } else {
           this._updateDirection('up');
         }

         if (!this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             styler(children[i], {
               transform: 'scale(1)',
               transitionDelay: 25 * i + 'ms'
             });
           }
         }
         this._itemShown = true;

         util.triggerElementEvent(this, 'open');
       }

       /**
        * @method hideItems
        * @signature hideItems()
        * @description
        *   [en]Hide the speed dial items.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'hideItems',
       value: function hideItems() {
         if (this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             styler(children[i], {
               transform: 'scale(0)',
               transitionDelay: 25 * (children.length - i) + 'ms'
             });
           }
         }
         this._itemShown = false;
         util.triggerElementEvent(this, 'close');
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'isOpen',


       /**
        * @method isOpen
        * @signature isOpen()
        * @description
        *   [en]Returns whether the menu is open or not.[/en]
        *   [ja][/ja]
        */
       value: function isOpen() {
         return this._itemShown;
       }

       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle visibility.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         this.visible ? this.hide() : this.show();
       }

       /**
        * @method toggleItems
        * @signature toggleItems()
        * @description
        *   [en]Toggle item visibility.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'toggleItems',
       value: function toggleItems() {
         if (this.isOpen()) {
           this.hideItems();
         } else {
           this.showItems();
         }
       }
     }, {
       key: 'items',
       get: function get() {
         return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         if (value) {
           this.hideItems();
         }
         util.arrayFrom(this.children).forEach(function (e) {
           util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
         });

         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property inline
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is inline or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'inline',
       get: function get() {
         return this.hasAttribute('inline');
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'visible',
       get: function get() {
         return this._shown && this.style.display !== 'none';
       }
     }]);
     return SpeedDialElement;
   }(BaseElement);

   window.OnsSpeedDialElement = document.registerElement('ons-speed-dial', {
     prototype: SpeedDialElement.prototype
   });

   var rewritables$1 = {
     /**
      * @param {Element} element
      * @param {Function} callback
      */

     ready: function ready(element, callback) {
       setImmediate(callback);
     },


     /**
      * @param {Element} element
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(element, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-splitter-content
    * @category splitter
    * @description
    *  [en]
    *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
    *
    *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
    *  [/en]
    *  [ja]ons-splitter-contentons-splitter[/ja]
    * @codepen rOQOML
    * @tutorial vanilla/Reference/splitter
    * @seealso ons-splitter
    *  [en]The `<ons-splitter>` component is the parent element.[/en]
    *  [ja]ons-splitter[/ja]
    * @seealso ons-splitter-side
    *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
    *  [ja]ons-splitter-side[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */

   var SplitterContentElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterContentElement, _BaseElement);

     function SplitterContentElement() {
       babelHelpers.classCallCheck(this, SplitterContentElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterContentElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterContentElement, [{
       key: 'createdCallback',


       /**
        * @attribute page
        * @type {String}
        * @description
        *   [en]
        *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
        *
        *     It is also possible to put `<ons-page>` element as a child of the element.
        *   [/en]
        *   [ja]ons-splitter-contentURL[/ja]
        */
       value: function createdCallback() {
         this._page = null;
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         if (!util.match(this.parentNode, 'ons-splitter')) {
           throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
         }
         this.attributeChangedCallback('page', null, this.getAttribute('page'));
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {}
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this2 = this;

         if (name === 'page' && current !== null) {
           rewritables$1.ready(this, function () {
             return _this2.load(current);
           });
         }
       }

       /**
        * @property page
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Page element loaded in the splitter content.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',


       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page, [options]
        *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in `page` in the content.[/en]
        *   [ja]URL[/ja]
        * @return {Promise}
        *   [en]Resolves to the new `<ons-page>` element[/en]
        *   [ja][/ja]
        */
       value: function load(page) {
         var _this3 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;
         var callback = options.callback;

         return internal.getPageHTMLAsync(page).then(function (html) {
           return new Promise(function (resolve) {
             rewritables$1.link(_this3, util.createFragment(html), options, function (fragment) {
               _this3._hide();
               _this3.innerHTML = '';

               _this3.appendChild(fragment);

               _this3._show();
               callback && callback();
               resolve(_this3.firstChild);
             });
           });
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       }
     }]);
     return SplitterContentElement;
   }(BaseElement);

   window.OnsSplitterContentElement = document.registerElement('ons-splitter-content', {
     prototype: SplitterContentElement.prototype
   });

   window.OnsSplitterContentElement.rewritables = rewritables$1;

   var SplitterMaskElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterMaskElement, _BaseElement);

     function SplitterMaskElement() {
       babelHelpers.classCallCheck(this, SplitterMaskElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterMaskElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterMaskElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(event) {
         if (util.match(this.parentNode, 'ons-splitter')) {
           this.parentNode._sides.forEach(function (side) {
             return side.close('left').catch(function () {});
           });
         }
         event.stopPropagation();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick);
       }
     }]);
     return SplitterMaskElement;
   }(BaseElement);

   window.OnsSplitterMaskElement = document.registerElement('ons-splitter-mask', {
     prototype: SplitterMaskElement.prototype
   });

   var SplitterAnimator = function () {
     function SplitterAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, SplitterAnimator);

       this._options = {
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         duration: '0.3',
         delay: '0'
       };
       this.updateOptions(options);
     }

     babelHelpers.createClass(SplitterAnimator, [{
       key: 'updateOptions',
       value: function updateOptions() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         util.extend(this._options, options);
         this._timing = this._options.timing;
         this._duration = this._options.duration;
         this._delay = this._options.delay;
       }

       /**
        * @param {Element} sideElement
        */

     }, {
       key: 'activate',
       value: function activate(sideElement) {
         var _this = this;

         var splitter = sideElement.parentNode;

         contentReady(splitter, function () {
           _this._side = sideElement;
           _this._content = splitter.content;
           _this._mask = splitter.mask;
         });
       }
     }, {
       key: 'inactivate',
       value: function inactivate() {
         this._content = this._side = this._mask = null;
       }
     }, {
       key: 'translate',
       value: function translate(distance) {
         animit(this._side).queue({
           transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
         }).play();
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'open',
       value: function open(done) {
         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           callback();
           done && done();
         }), animit(this._mask).wait(this._delay).queue({
           display: 'block'
         }).queue({
           opacity: '1'
         }, {
           duration: this._duration,
           timing: 'linear'
         }));
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'close',
       value: function close(done) {
         var _this2 = this;

         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(0px, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           _this2._side.style.webkitTransition = '';
           done && done();
           callback();
         }), animit(this._mask).wait(this._delay).queue({
           opacity: '0'
         }, {
           duration: this._duration,
           timing: 'linear'
         }).queue({
           display: 'none'
         }));
       }
     }, {
       key: 'minus',
       get: function get() {
         return this._side._side === 'right' ? '-' : '';
       }
     }]);
     return SplitterAnimator;
   }();

   /**
    * @element ons-splitter
    * @category splitter
    * @description
    *  [en]
    *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
    *
    *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
    *  [/en]
    *  [ja][/ja]
    * @codepen rOQOML
    * @tutorial vanilla/Reference/splitter
    * @seealso ons-splitter-content
    *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
    *  [ja]ons-splitter-content[/ja]
    * @seealso ons-splitter-side
    *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
    *  [ja]ons-splitter-side[/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using components from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @example
    * <ons-splitter id="splitter">
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse swipeable>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    *
    * <script>
    *   var splitter = document.getElementById('splitter');
    *   splitter.left.open();
    * </script>
    */

   var SplitterElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterElement, _BaseElement);

     function SplitterElement() {
       babelHelpers.classCallCheck(this, SplitterElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterElement, [{
       key: '_getSide',
       value: function _getSide(side) {
         var element = util.findChild(this, function (e) {
           return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
         });
         element && CustomElements.upgrade(element);
         return element;
       }

       /**
        * @property left
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Left `<ons-splitter-side>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         this._sides.some(function (s) {
           return s.isOpen ? s.close() : false;
         }) || event.callParentHandler();
       }
     }, {
       key: '_onModeChange',
       value: function _onModeChange(e) {
         var _this2 = this;

         if (e.target.parentNode) {
           contentReady(this, function () {
             _this2._layout();
           });
         }
       }
     }, {
       key: '_layout',
       value: function _layout() {
         var _this3 = this;

         this._sides.forEach(function (side) {
           _this3.content.style[side._side] = side.mode === 'split' ? side._width : 0;
         });
       }
     }, {
       key: 'createdCallback',
       value: function createdCallback() {
         var _this4 = this;

         this._boundOnModeChange = this._onModeChange.bind(this);

         contentReady(this, function () {
           _this4._compile();
           _this4._layout();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (!this.mask) {
           this.appendChild(document.createElement('ons-splitter-mask'));
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
         this.addEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;
         this.removeEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'left',
       get: function get() {
         return this._getSide('left');
       }
       /**
        * @property right
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Right `<ons-splitter-side>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'right',
       get: function get() {
         return this._getSide('right');
       }
     }, {
       key: '_sides',
       get: function get() {
         return [this.left, this.right].filter(function (e) {
           return e;
         });
       }
       /**
        * @property content
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]The `<ons-splitter-content>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'content',
       get: function get() {
         return util.findChild(this, 'ons-splitter-content');
       }
     }, {
       key: 'mask',
       get: function get() {
         return util.findChild(this, 'ons-splitter-mask');
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }]);
     return SplitterElement;
   }(BaseElement);

   window.OnsSplitterElement = document.registerElement('ons-splitter', {
     prototype: SplitterElement.prototype
   });

   window.OnsSplitterElement._animatorDict = {
     default: SplitterAnimator,
     overlay: SplitterAnimator
   };

   window.OnsSplitterElement.registerAnimator = function (name, Animator) {
     if (!(Animator instanceof SplitterAnimator)) {
       throw new Error('Animator parameter must be an instance of SplitterAnimator.');
     }
     window.OnsSplitterElement._animatorDict[name] = Animator;
   };

   window.OnsSplitterElement.SplitterAnimator = SplitterAnimator;

   var OnsSplitterElement$1 = OnsSplitterElement;

   var SPLIT_MODE = 'split';
   var COLLAPSE_MODE = 'collapse';
   var CLOSED_STATE = 'closed';
   var OPEN_STATE = 'open';
   var CHANGING_STATE = 'changing';

   var rewritables$2 = {
     /**
      * @param {Element} splitterSideElement
      * @param {Function} callback
      */

     ready: function ready(splitterSideElement, callback) {
       setImmediate(callback);
     },


     /**
      * @param {Element} splitterSideElement
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(splitterSideElement, target, options, callback) {
       callback(target);
     }
   };

   var CollapseDetection = function () {
     function CollapseDetection(element, target) {
       babelHelpers.classCallCheck(this, CollapseDetection);

       this._element = element;
       this._boundOnChange = this._onChange.bind(this);
       target && this.changeTarget(target);
     }

     babelHelpers.createClass(CollapseDetection, [{
       key: 'changeTarget',
       value: function changeTarget(target) {
         this.disable();
         this._target = target;
         if (target) {
           this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
           this.activate();
         }
       }
     }, {
       key: '_match',
       value: function _match(value) {
         if (this._orientation) {
           return this._target === (value.isPortrait ? 'portrait' : 'landscape');
         }
         return value.matches;
       }
     }, {
       key: '_onChange',
       value: function _onChange(value) {
         this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
       }
     }, {
       key: 'activate',
       value: function activate() {
         if (this._orientation) {
           orientation.on('change', this._boundOnChange);
           this._onChange({ isPortrait: orientation.isPortrait() });
         } else {
           this._queryResult = window.matchMedia(this._target);
           this._queryResult.addListener(this._boundOnChange);
           this._onChange(this._queryResult);
         }
       }
     }, {
       key: 'disable',
       value: function disable() {
         if (this._orientation) {
           orientation.off('change', this._boundOnChange);
         } else if (this._queryResult) {
           this._queryResult.removeListener(this._boundOnChange);
           this._queryResult = null;
         }
       }
     }]);
     return CollapseDetection;
   }();

   var widthToPx = function widthToPx(width, parent) {
     var value = parseInt(width, 10);
     var px = /px/.test(width);

     return px ? value : Math.round(parent.offsetWidth * value / 100);
   };

   var CollapseMode = function () {
     babelHelpers.createClass(CollapseMode, [{
       key: '_animator',
       get: function get() {
         return this._element._animator;
       }
     }]);

     function CollapseMode(element) {
       babelHelpers.classCallCheck(this, CollapseMode);

       this._active = false;
       this._state = CLOSED_STATE;
       this._element = element;
       this._lock = new DoorLock();
     }

     babelHelpers.createClass(CollapseMode, [{
       key: 'isOpen',
       value: function isOpen() {
         return this._active && this._state !== CLOSED_STATE;
       }
     }, {
       key: 'handleGesture',
       value: function handleGesture(e) {
         if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
           return;
         }
         if (e.type === 'dragstart') {
           this._onDragStart(e);
         } else if (!this._ignoreDrag) {
           e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         var scrolling = !/left|right/.test(event.gesture.direction);
         var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
         var area = this._element._swipeTargetWidth;
         var isOpen = this.isOpen();
         this._ignoreDrag = scrolling || area && distance > area && !isOpen;

         this._width = widthToPx(this._element._width, this._element.parentNode);
         this._startDistance = this._distance = isOpen ? this._width : 0;
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         event.gesture.preventDefault();
         var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
         var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
         if (distance !== this._distance) {
           this._animator.translate(distance);
           this._distance = distance;
           this._state = CHANGING_STATE;
         }
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var distance = this._distance;
         var width = this._width;
         var el = this._element;

         var direction = event.gesture.interimDirection;
         var shouldOpen = el._side !== direction && distance > width * el._threshold;
         this.executeAction(shouldOpen ? 'open' : 'close');
         this._ignoreDrag = true;
       }
     }, {
       key: 'layout',
       value: function layout() {
         if (this._active && this._state === OPEN_STATE) {
           this._animator.open();
         }
       }

       // enter collapse mode

     }, {
       key: 'enterMode',
       value: function enterMode() {
         if (!this._active) {
           this._active = true;
           this.layout();
         }
       }

       // exit collapse mode

     }, {
       key: 'exitMode',
       value: function exitMode() {
         this._active = false;
       }
     }, {
       key: '_isOpenOtherSideMenu',
       value: function _isOpenOtherSideMenu() {
         var _this = this;

         return util.arrayFrom(this._element.parentElement.children).some(function (e) {
           return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
         });
       }

       /**
        * @param {String} name - 'open' or 'close'
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @param {Boolean} [options.withoutAnimation]
        * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
        */

     }, {
       key: 'executeAction',
       value: function executeAction(name) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

         if (!this._active) {
           return Promise.resolve(false);
         }

         if (this._state === FINAL_STATE) {
           return Promise.resolve(this._element);
         }
         if (this._lock.isLocked()) {
           return Promise.reject('Splitter side is locked.');
         }
         if (name === 'open' && this._isOpenOtherSideMenu()) {
           return Promise.reject('Another menu is already open.');
         }
         if (this._element._emitEvent('pre' + name)) {
           return Promise.reject('Canceled in pre' + name + ' event.');
         }

         var callback = options.callback;
         var unlock = this._lock.lock();
         var done = function done() {
           _this2._state = FINAL_STATE;
           _this2.layout();
           unlock();
           _this2._element._emitEvent('post' + name);
           callback && callback();
         };

         if (options.withoutAnimation) {
           done();
           return Promise.resolve(this._element);
         }
         this._state = CHANGING_STATE;
         return new Promise(function (resolve) {
           _this2._animator[name](function () {
             done();
             resolve(_this2._element);
           });
         });
       }
     }]);
     return CollapseMode;
   }();

   /**
    * @element ons-splitter-side
    * @category splitter
    * @description
    *  [en]
    *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
    *
    *    It will be displayed on either the left or right side of the `<ons-splitte-content>` element.
    *
    *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
    *  [/en]
    *  [ja]ons-splitter-sideons-splitter[/ja]
    * @codepen rOQOML
    * @tutorial vanilla/Reference/splitter
    * @seealso ons-splitter
    *  [en]The `<ons-splitter>` is the parent component.[/en]
    *  [ja]ons-splitter[/ja]
    * @seealso ons-splitter-content
    *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
    *  [ja]ons-splitter-content[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */


   var SplitterSideElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterSideElement, _BaseElement);

     function SplitterSideElement() {
       babelHelpers.classCallCheck(this, SplitterSideElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterSideElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterSideElement, [{
       key: 'createdCallback',


       /**
        * @event modechange
        * @description
        *   [en]Fired just after the component's mode changes.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {String} event.mode
        *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
        *   [ja][/ja]
        */

       /**
        * @event preopen
        * @description
        *   [en]Fired just before the sliding menu is opened.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding menu.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postopen
        * @description
        *   [en]Fired just after the sliding menu is opened.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event preclose
        * @description
        *   [en]Fired just before the sliding menu is closed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding-menu.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postclose
        * @description
        *   [en]Fired just after the sliding menu is closed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default  default
        * @description
        *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
        *  [ja]"overlay", "default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute open-threshold
        * @type {Number}
        * @default  0.3
        * @description
        *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
        *  [ja]010.3[/ja]
        */

       /**
        * @attribute collapse
        * @type {String}
        * @description
        *   [en]
        *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
        *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
        *     If the value is a media query, the view will collapse when the media query resolves to `true`.
        *     If the value is not defined, the view always be in `"collapse"` mode.
        *   [/en]
        *   [ja]
        *     portrait, landscapewidth #px
        *     portraitlandscape
        *     
        *     collapse
        *   [/ja]
        */

       /**
        * @attribute swipe-target-width
        * @type {String}
        * @description
        *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute width
        * @type {String}
        * @description
        *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
        *   [ja]px%eg. 90%, 200px[/ja]
        */

       /**
        * @attribute side
        * @type {String}
        * @default left
        * @description
        *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
        *   [ja]"left""right"[/ja]
        */

       /**
        * @attribute mode
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
        *   [ja]"collapse""split"[/ja]
        */

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The URL of the menu page.[/en]
        *   [ja]ons-splitter-sideURL[/ja]
        */

       /**
        * @attribute swipeable
        * @type {Boolean}
        * @description
        *   [en]Whether to enable swipe interaction on collapse mode.[/en]
        *   [ja]collapse[/ja]
        */

       value: function createdCallback() {
         var _this4 = this;

         this._collapseMode = new CollapseMode(this);
         this._collapseDetection = new CollapseDetection(this);

         this._animatorFactory = new AnimatorFactory({
           animators: OnsSplitterElement$1._animatorDict,
           baseClass: SplitterAnimator,
           baseClassName: 'SplitterAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
         this._boundHandleGesture = function (e) {
           return _this4._collapseMode.handleGesture(e);
         };
         this._watchedAttributes = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold', 'page'];
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this5 = this;

         if (!util.match(this.parentNode, 'ons-splitter')) {
           throw new Error('Parent must be an ons-splitter element.');
         }

         this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

         if (!this.hasAttribute('side')) {
           this.setAttribute('side', 'left');
         }

         contentReady(this, function () {
           _this5._watchedAttributes.forEach(function (e) {
             return _this5._update(e);
           });
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._collapseDetection.disable();
         this._gestureDetector.dispose();
         this._gestureDetector = null;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (this._watchedAttributes.indexOf(name) !== -1) {
           this._update(name, current);
         }
       }
     }, {
       key: '_update',
       value: function _update(name, value) {
         name = '_update' + name.split('-').map(function (e) {
           return e[0].toUpperCase() + e.slice(1);
         }).join('');
         return this[name](value);
       }
     }, {
       key: '_emitEvent',
       value: function _emitEvent(name) {
         if (name.slice(0, 3) !== 'pre') {
           return util.triggerElementEvent(this, name, { side: this });
         }
         var isCanceled = false;

         util.triggerElementEvent(this, name, {
           side: this,
           cancel: function cancel() {
             return isCanceled = true;
           }
         });

         return isCanceled;
       }
     }, {
       key: '_updateCollapse',
       value: function _updateCollapse() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('collapse') : arguments[0];

         if (value === null || value === 'split') {
           this._collapseDetection.disable();
           return this._updateMode(SPLIT_MODE);
         }
         if (value === '' || value === 'collapse') {
           this._collapseDetection.disable();
           return this._updateMode(COLLAPSE_MODE);
         }

         this._collapseDetection.changeTarget(value);
       }

       // readonly attribute for the users

     }, {
       key: '_updateMode',
       value: function _updateMode(mode) {
         if (mode !== this._mode) {
           this._mode = mode;
           this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
           this.setAttribute('mode', mode);

           util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
         }
       }
     }, {
       key: '_updatePage',
       value: function _updatePage() {
         var _this6 = this;

         var page = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('page') : arguments[0];

         if (page !== null) {
           rewritables$2.ready(this, function () {
             return _this6.load(page);
           });
         }
       }
     }, {
       key: '_updateOpenThreshold',
       value: function _updateOpenThreshold() {
         var threshold = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('open-threshold') : arguments[0];

         this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         var swipeable = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipeable') : arguments[0];

         var action = swipeable === null ? 'off' : 'on';

         if (this._gestureDetector) {
           this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
         }
       }
     }, {
       key: '_updateSwipeTargetWidth',
       value: function _updateSwipeTargetWidth() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipe-target-width') : arguments[0];

         this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         this.style.width = this._width;
       }
     }, {
       key: '_updateSide',
       value: function _updateSide() {
         var side = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('side') : arguments[0];

         this._side = side === 'right' ? side : 'left';
       }
     }, {
       key: '_updateAnimation',
       value: function _updateAnimation() {
         var animation = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation') : arguments[0];

         this._animator = this._animatorFactory.newAnimator({ animation: animation });
         this._animator.activate(this);
       }
     }, {
       key: '_updateAnimationOptions',
       value: function _updateAnimationOptions() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation-options') : arguments[0];

         this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
       }

       /**
        * @property page
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Page element loaded in the splitter side.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'open',


       /**
        * @method open
        * @signature open([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been opened.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Open menu in collapse mode.[/en]
        *   [ja]collapseons-splitter-side[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */
       value: function open() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._collapseMode.executeAction('open', options);
       }

       /**
        * @method close
        * @signature close([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been closed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Close menu in collapse mode.[/en]
        *   [ja]collapseons-splitter-side[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'close',
       value: function close() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._collapseMode.executeAction('close', options);
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        * @description
        *   [en]Opens if it's closed. Closes if it's open.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this.isOpen ? this.close(options) : this.open(options);
       }

       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page
        *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in pageUrl in the right section[/en]
        *   [ja]URL[/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',
       value: function load(page) {
         var _this7 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;
         var callback = options.callback;

         return internal.getPageHTMLAsync(page).then(function (html) {
           return new Promise(function (resolve) {
             rewritables$2.link(_this7, util.createFragment(html), options, function (fragment) {
               _this7._hide();

               _this7.innerHTML = '';
               _this7.appendChild(fragment);

               _this7._show();
               callback && callback();
               resolve(_this7.firstChild);
             });
           });
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: '_width',
       get: function get() {
         var width = this.getAttribute('width');
         return (/^\d+(px|%)$/.test(width) ? width : '80%'
         );
       },
       set: function set(value) {
         this.setAttribute('width', value);
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       }

       /**
        * @property mode
        * @readonly
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'mode',
       get: function get() {
         return this._mode;
       }

       /**
        * @property isOpen
        * @type {Boolean}
        * @readonly
        * @description
        *   [en]This value is `true` when the menu is open..[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'isOpen',
       get: function get() {
         return this._collapseMode.isOpen();
       }
     }]);
     return SplitterSideElement;
   }(BaseElement);

   window.OnsSplitterSideElement = document.registerElement('ons-splitter-side', {
     prototype: SplitterSideElement.prototype
   });

   window.OnsSplitterSideElement.rewritables = rewritables$2;

   var scheme$18 = {
     '': 'switch--*',
     '.switch__input': 'switch--*__input',
     '.switch__handle': 'switch--*__handle',
     '.switch__toggle': 'switch--*__toggle'
   };

   var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

   var locations = {
     ios: [1, 21],
     material: [0, 16]
   };

   /**
    * @element ons-switch
    * @category switch
    * @description
    *   [en]
    *     Switch component. The switch can be toggled both by dragging and tapping.
    *
    *     Will automatically displays a Material Design switch on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Material Design switch[/en]
    *   [ja][/ja]
    * @codepen LpXZQQ
    * @tutorial vanilla/Reference/switch
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @example
    * <ons-switch checked></ons-switch>
    * <ons-switch disabled></ons-switch>
    * <ons-switch modifier="material"></ons-switch>
    */

   var SwitchElement = function (_BaseElement) {
     babelHelpers.inherits(SwitchElement, _BaseElement);

     function SwitchElement() {
       babelHelpers.classCallCheck(this, SwitchElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SwitchElement).apply(this, arguments));
     }

     babelHelpers.createClass(SwitchElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._checkbox = this.querySelector('.switch__input');
         this._handle = this.querySelector('.switch__handle');

         ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('switch');

         this.appendChild(template$2.cloneNode(true));

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._checkbox.removeEventListener('change', this._onChange);
         this.removeEventListener('dragstart', this._onDragStart);
         this.removeEventListener('hold', this._onHold);
         this.removeEventListener('tap', this.click);
         this.removeEventListener('click', this._onClick);
         this._gestureDetector.dispose();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._checkbox.addEventListener('change', this._onChange);
         this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });
         this.addEventListener('dragstart', this._onDragStart);
         this.addEventListener('hold', this._onHold);
         this.addEventListener('tap', this.click);
         this._boundOnRelease = this._onRelease.bind(this);
         this.addEventListener('click', this._onClick);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         if (this.checked) {
           this.parentNode.setAttribute('checked', '');
         } else {
           this.parentNode.removeAttribute('checked');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick(ev) {
         if (ev.target.classList.contains('switch__touch')) {
           ev.preventDefault();
         }
       }
     }, {
       key: 'click',
       value: function click() {
         if (!this.disabled) {
           this.checked = !this.checked;
         }
       }
     }, {
       key: '_getPosition',
       value: function _getPosition(e) {
         var l = this._locations;
         return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this.classList.add('switch--active');
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
           this.classList.remove('switch--active');
           return;
         }

         e.stopPropagation();

         this.classList.add('switch--active');
         this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

         this.addEventListener('drag', this._onDrag);
         document.addEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(e) {
         e.gesture.srcEvent.preventDefault();
         this._handle.style.left = this._getPosition(e) + 'px';
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var l = this._locations;
         var position = this._getPosition(e);

         this.checked = position >= (l[0] + l[1]) / 2;

         this.removeEventListener('drag', this._onDrag);
         document.removeEventListener('release', this._boundOnRelease);

         this._handle.style.left = '';
         this.classList.remove('switch--active');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             this._isMaterial = (current || '').indexOf('material') !== -1;
             this._locations = locations[this._isMaterial ? 'material' : 'ios'];
             ModifierUtil.onModifierChanged(last, current, this, scheme$18);
             break;
           case 'input-id':
             this._checkbox.id = current;
             break;
           case 'checked':
             this._checkbox.checked = current !== null;
             util.toggleAttribute(this._checkbox, name, current !== null);
             break;
           case 'disabled':
             util.toggleAttribute(this._checkbox, name, current !== null);
         }
       }
     }, {
       key: 'checked',


       /**
        * @event change
        * @description
        *   [en]Fired when the switch is toggled.[/en]
        *   [ja]ON/OFF[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.switch
        *   [en]Switch object.[/en]
        *   [ja]Switch[/ja]
        * @param {Boolean} event.value
        *   [en]Current value.[/en]
        *   [ja][/ja]
        * @param {Boolean} event.isInteractive
        *   [en]True if the change was triggered by the user clicking on the switch.[/en]
        *   [ja]true[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the switch.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Whether the switch is be disabled.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute checked
        * @description
        *   [en]Whether the switch is checked.[/en]
        *   [ja]ON[/ja]
        */

       /**
        * @attribute input-id
        * @type {String}
        * @description
        *  [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @property checked
        * @type {Boolean}
        * @description
        *   [en]This value is `true` if the switch is checked.[/en]
        *   [ja]ON`true`[/ja]
        */

       get: function get() {
         return this._checkbox.checked;
       },
       set: function set(value) {
         if (!!value !== this._checkbox.checked) {
           this._checkbox.click();
           this._checkbox.checked = !!value;
           return util.toggleAttribute(this, 'checked', this.checked);
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       get: function get() {
         return this._checkbox.disabled;
       },
       set: function set(value) {
         this._checkbox.disabled = value;
         return util.toggleAttribute(this, 'disabled', this.disabled);
       }

       /**
        * @property checkbox
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]The underlying checkbox element.[/en]
        *   [ja]checkbox[/ja]
        */

     }, {
       key: 'checkbox',
       get: function get() {
         return this._checkbox;
       }
     }]);
     return SwitchElement;
   }(BaseElement);

   window.OnsSwitchElement = document.registerElement('ons-switch', {
     prototype: SwitchElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var TabbarAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function TabbarAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, TabbarAnimator);

       this.timing = options.timing || 'linear';
       this.duration = options.duration !== undefined ? options.duration : '0.4';
       this.delay = options.delay !== undefined ? options.delay : '0';
     }

     /**
      * @param {Element} enterPage ons-page element
      * @param {Element} leavePage ons-page element
      * @param {Number} enterPageIndex
      * @param {Number} leavePageIndex
      * @param {Function} done
      */


     babelHelpers.createClass(TabbarAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         throw new Error('This method must be implemented.');
       }
     }]);
     return TabbarAnimator;
   }();

   var TabbarNoneAnimator = function (_TabbarAnimator) {
     babelHelpers.inherits(TabbarNoneAnimator, _TabbarAnimator);

     function TabbarNoneAnimator() {
       babelHelpers.classCallCheck(this, TabbarNoneAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarNoneAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarNoneAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         setTimeout(done, 1000 / 60);
       }
     }]);
     return TabbarNoneAnimator;
   }(TabbarAnimator);

   var TabbarFadeAnimator = function (_TabbarAnimator2) {
     babelHelpers.inherits(TabbarFadeAnimator, _TabbarAnimator2);

     function TabbarFadeAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarFadeAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'linear';
       options.duration = options.duration !== undefined ? options.duration : '0.4';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarFadeAnimator).call(this, options));
     }

     babelHelpers.createClass(TabbarFadeAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarFadeAnimator;
   }(TabbarAnimator);

   var TabbarSlideAnimator = function (_TabbarAnimator3) {
     babelHelpers.inherits(TabbarSlideAnimator, _TabbarAnimator3);

     function TabbarSlideAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarSlideAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'ease-in';
       options.duration = options.duration !== undefined ? options.duration : '0.15';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarSlideAnimator).call(this, options));
     }

     /**
      * @param {jqLite} enterPage
      * @param {jqLite} leavePage
      */


     babelHelpers.createClass(TabbarSlideAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         var sgn = enterIndex > leaveIndex;

         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarSlideAnimator;
   }(TabbarAnimator);

   var scheme$20 = {
     '.tab-bar__content': 'tab-bar--*__content',
     '.tab-bar': 'tab-bar--*'
   };

   var _animatorDict$5 = {
     'default': TabbarNoneAnimator,
     'fade': TabbarFadeAnimator,
     'slide': TabbarSlideAnimator,
     'none': TabbarNoneAnimator
   };

   var rewritables$3 = {
     /**
      * @param {Element} tabbarElement
      * @param {Function} callback
      */

     ready: function ready(tabbarElement, callback) {
       callback();
     },


     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(tabbarElement, target, options, callback) {
       callback(target);
     },


     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Function} callback
      */
     unlink: function unlink(tabbarElement, target, callback) {
       callback(target);
     }
   };

   var generateId$1 = function () {
     var i = 0;
     return function () {
       return 'ons-tabbar-gen-' + i++;
     };
   }();

   /**
    * @element ons-tabbar
    * @category tabbar
    * @description
    *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
    *   [ja]ons-tab[/ja]
    * @codepen pGuDL
    * @tutorial vanilla/Reference/tabbar
    * @guide UsingTabBar
    *   [en]Using tab bar[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScript[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-tab
    *   [en]The `<ons-tab>` component.[/en]
    *   [ja]ons-tab[/ja]
    * @seealso ons-page
    *   [en]The `<ons-page>` component.[/en]
    *   [ja]ons-page[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab
    *     page="home.html"
    *     label="Home"
    *     active>
    *   </ons-tab>
    *   <ons-tab
    *     page="settings.html"
    *     label="Settings"
    *     active>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>
    */

   var TabbarElement = function (_BaseElement) {
     babelHelpers.inherits(TabbarElement, _BaseElement);

     function TabbarElement() {
       babelHelpers.classCallCheck(this, TabbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarElement, [{
       key: 'createdCallback',


       /**
        * @event prechange
        * @description
        *   [en]Fires just before the tab is changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the change event.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postchange
        * @description
        *   [en]Fires just after the tab is changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        */

       /**
        * @event reactive
        * @description
        *   [en]Fires if the already open tab is tapped again.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default none
        * @description
        *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
        *   [ja]"none""fade""slide""none"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute position
        * @initonly
        * @type {String}
        * @default bottom
        * @description
        *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
        *   [ja]"bottom""top""bottom"[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this._tabbarId = generateId$1();

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           for (var i = 0; i < _this2.firstChild.children.length; i++) {
             _this2.firstChild.children[i].style.display = 'none';
           }

           var activeIndex = _this2.getAttribute('activeIndex');

           if (activeIndex && _this2.children[1].children.length > activeIndex) {
             _this2.children[1].children[activeIndex].setAttribute('active', 'true');
           }

           autoStyle.prepare(_this2);
           ModifierUtil.initModifier(_this2, scheme$20);

           _this2._animatorFactory = new AnimatorFactory({
             animators: _animatorDict$5,
             baseClass: TabbarAnimator,
             baseClassName: 'TabbarAnimator',
             defaultAnimation: _this2.getAttribute('animation')
           });
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var content = util.create('.ons-tab-bar__content.tab-bar__content');
         var tabbar = util.create('.tab-bar.ons-tab-bar__footer.ons-tabbar-inner');

         while (this.firstChild) {
           tabbar.appendChild(this.firstChild);
         }

         this.appendChild(content);
         this.appendChild(tabbar);

         this._updatePosition();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var _this3 = this;

         var position = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('position') : arguments[0];

         var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
         var action = top ? util.addModifier : util.removeModifier;

         action(this, 'top');

         var page = util.findParent(this, 'ons-page');
         if (page) {
           this.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

           if (util.match(page.firstChild, 'ons-toolbar')) {
             action(page.firstChild, 'noshadow');
           }
         }

         internal.autoStatusBarFill(function () {
           var filled = util.findParent(_this3, function (e) {
             return e.hasAttribute('status-bar-fill');
           });
           util.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
         });
       }
     }, {
       key: '_getTabbarElement',
       value: function _getTabbarElement() {
         return util.findChild(this, '.tab-bar');
       }

       /**
        * @method loadPage
        * @signature loadPage(url, [options])
        * @param {String} url
        *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @description
        *   [en]Displays a new page without changing the active index.[/en]
        *   [ja][/ja]
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'loadPage',
       value: function loadPage(page) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           OnsTabElement.prototype._createPageElement(page, function (pageElement) {
             resolve(_this4._loadPageDOMAsync(pageElement, options));
           });
         });
       }

       /**
        * @param {Element} pageElement
        * @param {Object} [options]
        * @param {Object} [options.animation]
        * @param {Object} [options.callback]
        * @return {Promise} Resolves to the new page element.
        */

     }, {
       key: '_loadPageDOMAsync',
       value: function _loadPageDOMAsync(pageElement) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           rewritables$3.link(_this5, pageElement, options, function (pageElement) {
             _this5._contentElement.appendChild(pageElement);

             if (_this5.getActiveTabIndex() !== -1) {
               resolve(_this5._switchPage(pageElement, options));
             } else {
               if (options.callback instanceof Function) {
                 options.callback();
               }

               _this5._oldPageElement = pageElement;
               resolve(pageElement);
             }
           });
         });
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getTabbarId',
       value: function getTabbarId() {
         return this._tabbarId;
       }

       /**
        * @return {Element/null}
        */

     }, {
       key: '_getCurrentPageElement',
       value: function _getCurrentPageElement() {
         var pages = this._contentElement.children;
         var page = null;
         for (var i = 0; i < pages.length; i++) {
           if (pages[i].style.display !== 'none') {
             page = pages[i];
             break;
           }
         }

         if (page && page.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('Invalid state: page element must be a "ons-page" element.');
         }

         return page;
       }
     }, {
       key: '_switchPage',


       /**
        * @param {Element} element
        * @param {Object} options
        * @param {String} [options.animation]
        * @param {Function} [options.callback]
        * @param {Object} [options.animationOptions]
        * @param {Number} options.selectedTabIndex
        * @param {Number} options.previousTabIndex
        * @return {Promise} Resolves to the new page element.
        */
       value: function _switchPage(element, options) {
         var oldPageElement = this._oldPageElement || internal.nullElement;
         this._oldPageElement = element;
         var animator = this._animatorFactory.newAnimator(options);

         return new Promise(function (resolve) {
           if (oldPageElement !== internal.nullElement) {
             oldPageElement._hide();
           }

           animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
             if (oldPageElement !== internal.nullElement) {
               oldPageElement.style.display = 'none';
             }

             element.style.display = 'block';
             element._show();

             if (options.callback instanceof Function) {
               options.callback();
             }

             resolve(element);
           });
         });
       }

       /**
        * @method setActiveTab
        * @signature setActiveTab(index, [options])
        * @param {Number} index
        *   [en]Tab index.[/en]
        *   [ja][/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Boolean} [options.keepPage]
        *   [en]If true the page will not be changed.[/en]
        *   [ja]pagetrue[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
        *   [ja]`"fade"``"slide"``"none"`[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveTab',
       value: function setActiveTab(index) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         if (!options.animation && this.hasAttribute('animation')) {
           options.animation = this.getAttribute('animation');
         }

         var previousTab = this._getActiveTabElement(),
             selectedTab = this._getTabElement(index),
             previousTabIndex = this.getActiveTabIndex(),
             selectedTabIndex = index,
             previousPageElement = this._getCurrentPageElement();

         if (!selectedTab) {
           return Promise.reject('Specified index does not match any tab.');
         }

         if (selectedTabIndex === previousTabIndex) {
           util.triggerElementEvent(this, 'reactive', {
             index: selectedTabIndex,
             tabItem: selectedTab
           });

           return Promise.resolve(previousPageElement);
         }

         var canceled = false;

         util.triggerElementEvent(this, 'prechange', {
           index: selectedTabIndex,
           tabItem: selectedTab,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           selectedTab.setInactive();
           if (previousTab) {
             previousTab.setActive();
           }
           return Promise.reject('Canceled in prechange event.');
         }

         selectedTab.setActive();

         var needLoad = !selectedTab.isLoaded() && !options.keepPage;

         util.arrayFrom(this._getTabbarElement().children).forEach(function (tab) {
           if (tab != selectedTab) {
             tab.setInactive();
           } else {
             if (!needLoad) {
               util.triggerElementEvent(_this6, 'postchange', {
                 index: selectedTabIndex,
                 tabItem: selectedTab
               });
             }
           }
         });

         if (needLoad) {
           var removeElement;
           var params;

           var _ret = function () {
             removeElement = false;


             if (!previousTab && previousPageElement || previousTab && previousTab._pageElement !== previousPageElement) {
               removeElement = true;
             }

             params = {
               callback: function callback() {
                 util.triggerElementEvent(_this6, 'postchange', {
                   index: selectedTabIndex,
                   tabItem: selectedTab
                 });

                 if (options.callback instanceof Function) {
                   options.callback();
                 }
               },
               previousTabIndex: previousTabIndex,
               selectedTabIndex: selectedTabIndex
             };


             if (options.animation) {
               params.animation = options.animation;
             }

             params.animationOptions = options.animationOptions || {};

             var link = function link(element, callback) {
               rewritables$3.link(_this6, element, options, callback);
             };

             return {
               v: new Promise(function (resolve) {
                 selectedTab._loadPageElement(function (pageElement) {
                   resolve(_this6._loadPersistentPageDOM(pageElement, params));
                 }, link);
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         }

         return Promise.resolve(previousPageElement);
       }

       /**
        * @param {Element} element
        * @param {Object} options
        * @param {Object} options.animation
        */

     }, {
       key: '_loadPersistentPageDOM',
       value: function _loadPersistentPageDOM(element) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


         if (!util.isAttached(element)) {
           this._contentElement.appendChild(element);
         }

         element.removeAttribute('style');
         return this._switchPage(element, options);
       }

       /**
        * @method setTabbarVisibility
        * @signature setTabbarVisibility(visible)
        * @param {Boolean} visible
        * @description
        *   [en]Used to hide or show the tab bar.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setTabbarVisibility',
       value: function setTabbarVisibility(visible) {
         this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
         this._getTabbarElement().style.display = visible ? '' : 'none';
       }

       /**
        * @method getActiveTabIndex
        * @signature getActiveTabIndex()
        * @return {Number}
        *   [en]The index of the currently active tab.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
        *   [ja]-1[/ja]
        */

     }, {
       key: 'getActiveTabIndex',
       value: function getActiveTabIndex() {
         var tabs = this._getTabbarElement().children;

         for (var i = 0; i < tabs.length; i++) {
           if (tabs[i] instanceof window.OnsTabElement && tabs[i].isActive && tabs[i].isActive()) {
             return i;
           }
         }

         return -1;
       }

       /**
        * @return {Number} When active tab is not found, returns -1.
        */

     }, {
       key: '_getActiveTabElement',
       value: function _getActiveTabElement() {
         return this._getTabElement(this.getActiveTabIndex());
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_getTabElement',
       value: function _getTabElement(index) {
         return this._getTabbarElement().children[index];
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {}
     }, {
       key: '_show',
       value: function _show() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         var pages = this._contentElement.children;
         for (var i = pages.length - 1; i >= 0; i--) {
           pages[i]._destroy();
         }
         this.remove();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$20);
         }
       }
     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this, '.tab-bar__content');
       }
     }, {
       key: 'pages',
       get: function get() {
         return util.arrayFrom(this._contentElement.children);
       }
     }]);
     return TabbarElement;
   }(BaseElement);

   window.OnsTabbarElement = document.registerElement('ons-tabbar', {
     prototype: TabbarElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsTabbarElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof TabbarAnimator)) {
       throw new Error('"Animator" param must inherit OnsTabbarElement.TabbarAnimator');
     }
     _animatorDict$5[name] = Animator;
   };

   window.OnsTabbarElement.rewritables = rewritables$3;
   window.OnsTabbarElement.TabbarAnimator = TabbarAnimator;

   var OnsTabbarElement$1 = OnsTabbarElement;

   var scheme$19 = {
     '': 'tab-bar--*__item',
     '.tab-bar__button': 'tab-bar--*__button'
   };
   var templateSource$1 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button tab-bar-inner"></button>\n  </div>\n');
   var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n  </div>\n');

   /**
    * @element ons-tab
    * @category tabbar
    * @description
    *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
    *   [ja]
    *     ons-tab
    *     ons-tab
    *   [/ja]
    * @codepen pGuDL
    * @tutorial vanilla/Reference/tabbar
    * @guide UsingTabBar
    *   [en]Using tab bar[/en]
    *   [ja][/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-tabbar
    *   [en]ons-tabbar component[/en]
    *   [ja]ons-tabbar[/ja]
    * @seealso ons-page
    *   [en]ons-page component[/en]
    *   [ja]ons-page[/ja]
    * @seealso ons-icon
    *   [en]ons-icon component[/en]
    *   [ja]ons-icon[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab
    *     page="home.html"
    *     label="Home"
    *     active>
    *   </ons-tab>
    *   <ons-tab
    *     page="settings.html"
    *     label="Settings"
    *     active>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>

    */

   var TabElement = function (_BaseElement) {
     babelHelpers.inherits(TabElement, _BaseElement);

     function TabElement() {
       babelHelpers.classCallCheck(this, TabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabElement, [{
       key: 'createdCallback',


       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The page that is displayed when the tab is tapped.[/en]
        *   [ja]ons-tabURL[/ja]
        */

       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
        *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
        *   [/en]
        *   [ja]
        *     ons-icon
        *     background-imageCSS
        *   [/ja]
        */

       /**
        * @attribute active-icon
        * @type {String}
        * @description
        *   [en]The name of the icon when the tab is active.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute label
        * @type {String}
        * @description
        *   [en]The label of the tab item.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute active
        * @description
        *   [en]This attribute should be set to the tab that is active by default.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         if (this.hasAttribute('label') || this.hasAttribute('icon')) {
           if (!this.hasAttribute('_compiled')) {
             this._compile();
           }
         } else {
           contentReady(this, function () {
             if (!_this2.hasAttribute('_compiled')) {
               _this2._compile();
             }
           });
         }

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var fragment = document.createDocumentFragment();
         var hasChildren = false;

         while (this.childNodes[0]) {
           var node = this.childNodes[0];
           this.removeChild(node);
           fragment.appendChild(node);

           if (node.nodeType == Node.ELEMENT_NODE) {
             hasChildren = true;
           }
         }

         var template = templateSource$1.cloneNode(true);
         while (template.children[0]) {
           this.appendChild(template.children[0]);
         }
         this.classList.add('tab-bar__item');

         var button = util.findChild(this, '.tab-bar__button');

         if (hasChildren) {
           button.appendChild(fragment);
           this._hasDefaultTemplate = false;
         } else {
           this._hasDefaultTemplate = true;
           this._updateDefaultTemplate();
         }

         ModifierUtil.initModifier(this, scheme$19);
         this._updateRipple();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         // util.updateRipple(this.querySelector('.tab-bar__button'), this);
       }
     }, {
       key: '_updateDefaultTemplate',
       value: function _updateDefaultTemplate() {
         if (!this._hasDefaultTemplate) {
           return;
         }

         var button = util.findChild(this, '.tab-bar__button');

         if (button.children.length == 0) {
           var template = defaultInnerTemplateSource.cloneNode(true);
           while (template.children[0]) {
             button.appendChild(template.children[0]);
           }

           if (!button.querySelector('.tab-bar__icon')) {
             button.insertBefore(template.querySelector('.tab-bar__icon'), button.firstChild);
           }

           if (!button.querySelector('.tab-bar__label')) {
             button.appendChild(template.querySelector('.tab-bar__label'));
           }
         }

         var self = this;
         var icon = this.getAttribute('icon');
         var label = this.getAttribute('label');

         if (typeof icon === 'string') {
           getIconElement().setAttribute('icon', icon);
         } else {
           var wrapper = button.querySelector('.tab-bar__icon');
           if (wrapper) {
             wrapper.remove();
           }
         }

         if (typeof label === 'string') {
           getLabelElement().textContent = label;
         } else {
           var _label = getLabelElement();
           if (_label) {
             _label.remove();
           }
         }

         function getLabelElement() {
           return self.querySelector('.tab-bar__label');
         }

         function getIconElement() {
           return self.querySelector('ons-icon');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick() {
         var tabbar = this._findTabbarElement();
         if (tabbar) {
           tabbar.setActiveTab(this._findTabIndex());
         }
       }
     }, {
       key: 'setActive',
       value: function setActive() {
         var radio = util.findChild(this, 'input');
         radio.checked = true;
         this.classList.add('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'none';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
       }
     }, {
       key: 'setInactive',
       value: function setInactive() {
         var radio = util.findChild(this, 'input');
         radio.checked = false;
         this.classList.remove('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'none';
         });
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLoaded',
       value: function isLoaded() {
         return false;
       }

       /**
        * @param {Function} callback
        * @param {Function} link
        */

     }, {
       key: '_loadPageElement',
       value: function _loadPageElement(callback, link) {
         var _this3 = this;

         if (!this.pageElement) {
           this._createPageElement(this.getAttribute('page'), function (element) {
             link(element, function (element) {
               _this3.pageElement = element;
               callback(element);
             });
           });
         } else {
           callback(this.pageElement);
         }
       }
     }, {
       key: '_createPageElement',


       /**
        * @param {String} page
        * @param {Function} callback
        */
       value: function _createPageElement(page, callback) {
         internal.getPageHTMLAsync(page).then(function (html) {
           callback(util.createElement(html.trim()));
         });
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isActive',
       value: function isActive() {
         return this.classList.contains('active');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this4 = this;

         contentReady(this, function () {
           _this4._ensureElementPosition();

           var tabbar = _this4._findTabbarElement();

           if (tabbar.hasAttribute('modifier')) {
             var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
             _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
           }

           if (_this4.hasAttribute('active')) {
             (function () {
               var tabIndex = _this4._findTabIndex();

               OnsTabbarElement$1.rewritables.ready(tabbar, function () {
                 setImmediate(function () {
                   return tabbar.setActiveTab(tabIndex, { animation: 'none' });
                 });
               });
             })();
           } else {
             OnsTabbarElement$1.rewritables.ready(tabbar, function () {
               setImmediate(function () {
                 if (_this4.hasAttribute('page')) {
                   _this4._createPageElement(_this4.getAttribute('page'), function (pageElement) {
                     OnsTabbarElement$1.rewritables.link(tabbar, pageElement, {}, function (pageElement) {
                       _this4.pageElement = pageElement;
                       _this4.pageElement.style.display = 'none';
                       tabbar._contentElement.appendChild(_this4.pageElement);
                     });
                   });
                 }
               });
             });
           }

           _this4.addEventListener('click', _this4._boundOnClick, false);
         });
       }
     }, {
       key: '_findTabbarElement',
       value: function _findTabbarElement() {
         if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode;
         }

         if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode.parentNode;
         }

         return null;
       }
     }, {
       key: '_findTabIndex',
       value: function _findTabIndex() {
         var elements = this.parentNode.children;
         for (var i = 0; i < elements.length; i++) {
           if (this === elements[i]) {
             return i;
           }
         }
       }
     }, {
       key: '_ensureElementPosition',
       value: function _ensureElementPosition() {
         if (!this._findTabbarElement()) {
           throw new Error('This ons-tab element is must be child of ons-tabbar element.');
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this5 = this;

         switch (name) {
           case 'modifier':
             contentReady(this, function () {
               return ModifierUtil.onModifierChanged(last, current, _this5, scheme$19);
             });
             break;
           case 'ripple':
             contentReady(this, function () {
               return _this5._updateRipple();
             });
             break;
           case 'icon':
           case 'label':
             contentReady(this, function () {
               return _this5._updateDefaultTemplate();
             });
             break;
         }
       }
     }, {
       key: 'pageElement',
       set: function set(el) {
         this._pageElement = el;
       },
       get: function get() {
         if (typeof this._pageElement !== 'undefined') {
           return this._pageElement;
         }

         var tabbar = this._findTabbarElement();
         var index = this._findTabIndex();

         return tabbar._contentElement.children[index];
       }
     }]);
     return TabElement;
   }(BaseElement);

   window.OnsTabElement = document.registerElement('ons-tab', {
     prototype: TabElement.prototype
   });

   document.registerElement('ons-tabbar-item', {
     prototype: Object.create(TabElement.prototype)
   });

   var scheme$21 = { '': 'toolbar-button--*' };

   /**
    * @element ons-toolbar-button
    * @category toolbar
    * @modifier material
    *   [en]Material Design toolbar button.[/en]
    *   [ja][/ja]
    * @modifier outline
    *   [en]A button with an outline.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
    *   [ja]ons-toolbarons-bottom-toolbar[/ja]
    * @codepen aHmGL
    * @tutorial vanilla/Reference/button
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar
    *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
    *   [ja]ons-toolbar[/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
    *   [ja]ons-back-button[/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left">
    *     <ons-toolbar-button>
    *       Button
    *     </ons-toolbar-button>
    *   </div>
    *   <div class="center">
    *     Title
    *   </div>
    *   <div class="right">
    *     <ons-toolbar-button>
    *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
    *     </ons-toolbar-button>
    *   </div>
    * </ons-toolbar>
    */

   var ToolbarButtonElement = function (_BaseElement) {
     babelHelpers.inherits(ToolbarButtonElement, _BaseElement);

     function ToolbarButtonElement() {
       babelHelpers.classCallCheck(this, ToolbarButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarButtonElement, [{
       key: 'createdCallback',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the button.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('toolbar-button');

         ModifierUtil.initModifier(this, scheme$21);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$21);
         }
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }]);
     return ToolbarButtonElement;
   }(BaseElement);

   window.OnsToolbarButton = document.registerElement('ons-toolbar-button', {
     prototype: ToolbarButtonElement.prototype
   });

   var scheme$22 = {
     '': 'navigation-bar--*',
     '.navigation-bar__left': 'navigation-bar--*__left',
     '.navigation-bar__center': 'navigation-bar--*__center',
     '.navigation-bar__right': 'navigation-bar--*__right'
   };

   /**
    * @element ons-toolbar
    * @category toolbar
    * @modifier material
    *   [en]Material Design toolbar.[/en]
    *   [ja][/ja]
    * @modifier transparent
    *   [en]Transparent toolbar[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Toolbar component that can be used with navigation.
    *
    *     Left, center and right container can be specified by class names.
    *
    *     This component will automatically displays as a Material Design toolbar when running on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @codepen aHmGL
    * @tutorial vanilla/Reference/button
    * @guide Addingatoolbar [en]Adding a toolbar[/en][ja][/ja]
    * @seealso ons-bottom-toolbar
    *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
    *   [ja]ons-bottom-toolbar[/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
    *   [ja]ons-back-button[/ja]
    * @seealso ons-toolbar-button
    *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
    *   [ja]ons-toolbar-button[/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left">
    *       <ons-back-button>
    *         Back
    *       </ons-back-button>
    *     </div>
    *     <div class="center">
    *       Title
    *     </div>
    *     <div class="right">
    *       <ons-toolbar-button>
    *         <ons-icon icon="md-menu"></ons-icon>
    *       </ons-toolbar-button>
    *     </div>
    *   </ons-toolbar>
    * </ons-page>
    */

   var ToolbarElement = function (_BaseElement) {
     babelHelpers.inherits(ToolbarElement, _BaseElement);

     function ToolbarElement() {
       babelHelpers.classCallCheck(this, ToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarElement, [{
       key: 'createdCallback',


       /**
        * @attribute inline
        * @initonly
        * @description
        *   [en]Display the toolbar as an inline element.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }
         });

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this2._tryToEnsureNodePosition();
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this3._tryToEnsureNodePosition();
         });
       }
     }, {
       key: '_tryToEnsureNodePosition',
       value: function _tryToEnsureNodePosition() {
         if (!this.parentNode || this.hasAttribute('inline')) {
           return;
         }
         var page = util.findParent(this, 'ons-page');

         if (page && page !== this.parentNode) {
           page._registerToolbar(this);
         }
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarLeftItemsElement',
       value: function _getToolbarLeftItemsElement() {
         return this.querySelector('.left') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarCenterItemsElement',
       value: function _getToolbarCenterItemsElement() {
         return this.querySelector('.center') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarRightItemsElement',
       value: function _getToolbarRightItemsElement() {
         return this.querySelector('.right') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarBackButtonLabelElement',
       value: function _getToolbarBackButtonLabelElement() {
         return this.querySelector('ons-back-button .back-button__label') || internal.nullElement;
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this.classList.add('navigation-bar');
         this._ensureToolbarItemElements();
         ModifierUtil.initModifier(this, scheme$22);
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_ensureToolbarItemElements',
       value: function _ensureToolbarItemElements() {
         for (var i = this.childNodes.length - 1; i >= 0; i--) {
           // case of not element
           if (this.childNodes[i].nodeType != 1) {
             this.removeChild(this.childNodes[i]);
           }
         }

         var center = this._ensureToolbarElement('center');
         center.classList.add('navigation-bar__title');

         if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
           var left = this._ensureToolbarElement('left');
           var right = this._ensureToolbarElement('right');

           if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
             this.appendChild(left);
             this.appendChild(center);
             this.appendChild(right);
           }
         }
       }
     }, {
       key: '_ensureToolbarElement',
       value: function _ensureToolbarElement(name) {
         var element = util.findChild(this, '.' + name) || util.create('.' + name);

         element.classList.add('navigation-bar__' + name);

         return element;
       }
     }]);
     return ToolbarElement;
   }(BaseElement);

   window.OnsToolbarElement = document.registerElement('ons-toolbar', {
     prototype: ToolbarElement.prototype
   });

   var scheme$23 = {
     '.range': 'range--*',
     '.range__left': 'range--*__left'
   };

   var templateSource$2 = util.createElement('<div>\n  <div class="range__left"></div>\n  <input type="range" class="range">\n</div>');

   var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

   /**
    * @element ons-range
    * @category range
    * @modifier material
    *   [en]Material Design slider[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Range input component. Used to display a draggable slider.
    *
    *     Works very similar to the `<input type="range">` element.
    *   [/en]
    *   [ja][/ja]
    * @codepen xZQomM
    * @tutorial vanilla/Reference/range
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja][/ja]
    * @seealso ons-input
    *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
    *   [ja][/ja]
    * @example
    * <ons-range value="20"></ons-range>
    * <ons-range modifier="material" value="10"></range>
    */

   var RangeElement = function (_BaseElement) {
     babelHelpers.inherits(RangeElement, _BaseElement);

     function RangeElement() {
       babelHelpers.classCallCheck(this, RangeElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RangeElement).apply(this, arguments));
     }

     babelHelpers.createClass(RangeElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           _this2._updateBoundAttributes();
           _this2._onChange();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (!(util.findChild(this, '.range__left') && util.findChild(this, 'input'))) {
           var template = templateSource$2.cloneNode(true);
           while (template.children[0]) {
             this.appendChild(template.children[0]);
           }
         }

         ModifierUtil.initModifier(this, scheme$23);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._left.style.width = 100 * this._ratio + '%';
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$23);
         } else if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
           contentReady(this, function () {
             _this3._updateBoundAttributes();

             if (name === 'min' || name === 'max') {
               _this3._onChange();
             }
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('input', this._onChange);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('input', this._onChange);
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this4 = this;

         INPUT_ATTRIBUTES$1.forEach(function (attr) {
           if (_this4.hasAttribute(attr)) {
             _this4._input.setAttribute(attr, _this4.getAttribute(attr));
           } else {
             _this4._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_ratio',
       get: function get() {
         // Returns the current ratio.
         var min = this._input.min === '' ? 0 : parseInt(this._input.min);
         var max = this._input.max === '' ? 100 : parseInt(this._input.max);

         return (this.value - min) / (max - min);
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_left',
       get: function get() {
         return this.querySelector('.range__left');
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current value.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'value',
       get: function get() {
         return this._input.value;
       },
       set: function set(val) {
         var _this5 = this;

         contentReady(this, function () {
           _this5._input.value = val;
           _this5._onChange();
         });
       }
     }]);
     return RangeElement;
   }(BaseElement);

   window.OnsRangeElement = document.registerElement('ons-range', {
     prototype: RangeElement.prototype
   });

   // fastclick
   window.addEventListener('load', function () {
     ons.fastClick = FastClick.attach(document.body);
   }, false);

   // ons._defaultDeviceBackButtonHandler
   window.addEventListener('DOMContentLoaded', function () {
     ons._deviceBackButtonDispatcher.enable();
     ons._defaultDeviceBackButtonHandler = ons._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
       navigator.app.exitApp();
     });
     document.body._gestureDetector = new ons.GestureDetector(document.body);
   }, false);

   // setup loading placeholder
   ons.ready(function () {
     ons._setupLoadingPlaceHolders();
   });

   // viewport.js
   new Viewport().setup();

   return ons;

}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFuaW1pdC5qcyIsImNoaWxkTm9kZVJlbW92ZS5qcyIsImNsYXNzTGlzdC5qcyIsIkN1c3RvbUVsZW1lbnRzLmpzIiwiQ3VzdG9tRXZlbnQuanMiLCJmYXN0Y2xpY2stcGF0Y2hlZC5qcyIsIm1pY3JvZXZlbnQuanMiLCJNdXRhdGlvbk9ic2VydmVyLmpzIiwicHJvbWlzZS03LjAuNC5taW4uanMiLCJzZXRJbW1lZGlhdGUuanMiLCJ2aWV3cG9ydC5qcyIsIndpbnN0b3JlLWpzY29tcGF0LmpzIiwib25zL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlci5qcyIsIm9ucy91dGlsLmpzIiwib25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCJvbnMvcGxhdGZvcm0uanMiLCJvbnMvbm90aWZpY2F0aW9uLmpzIiwib25zL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24uanMiLCJvbnMvaW50ZXJuYWwvaW50ZXJuYWwuanMiLCJvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeS5qcyIsIm9ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsLmpzIiwib25zL2ludGVybmFsL2xhenktcmVwZWF0LmpzIiwib25zL2ludGVybmFsL2luZGV4LmpzIiwib25zL29yaWVudGF0aW9uLmpzIiwib25zL3NvZnR3YXJlLWtleWJvYXJkLmpzIiwib25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyLmpzIiwib25zL2F1dG9zdHlsZS5qcyIsIm9ucy9kb29ybG9jay5qcyIsIm9ucy9jb250ZW50LXJlYWR5LmpzIiwib25zL29ucy5qcyIsIm9ucy9iYXNlLWVsZW1lbnQuanMiLCJlbGVtZW50cy9vbnMtdGVtcGxhdGUuanMiLCJlbGVtZW50cy9vbnMtaWYuanMiLCJlbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1idXR0b24uanMiLCJlbGVtZW50cy9vbnMtY2Fyb3VzZWwtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1jYXJvdXNlbC5qcyIsImVsZW1lbnRzL29ucy1jb2wuanMiLCJlbGVtZW50cy9vbnMtZGlhbG9nL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLWRpYWxvZy9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1mYWIuanMiLCJlbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvci5qcyIsImVsZW1lbnRzL29ucy1pY29uLmpzIiwiZWxlbWVudHMvb25zLWxhenktcmVwZWF0LmpzIiwiZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyLmpzIiwiZWxlbWVudHMvb25zLWxpc3QtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1saXN0LmpzIiwiZWxlbWVudHMvb25zLWlucHV0LmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc2xpZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1saWZ0LWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3MtZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtc2xpZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWxpZnQtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL25vbmUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXBhZ2UuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1wb3BvdmVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXByb2dyZXNzLWJhci5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhci5qcyIsImVsZW1lbnRzL29ucy1wdWxsLWhvb2suanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2FuaW1hdG9yLWNzcy5qcyIsImVsZW1lbnRzL29ucy1yaXBwbGUvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtcm93LmpzIiwiZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbS5qcyIsImxpYi9zdHlsZXIuanMiLCJlbGVtZW50cy9vbnMtc3BlZWQtZGlhbC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50LmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLW1hc2suanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXIvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZS5qcyIsImVsZW1lbnRzL29ucy1zd2l0Y2guanMiLCJlbGVtZW50cy9vbnMtdGFiYmFyL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLXRhYmJhci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy10YWIuanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24uanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1yYW5nZS5qcyIsInNldHVwLmpzIl0sIm5hbWVzIjpbImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsIkV2ZW50IiwidXRpbCIsIm9uc1BsYXRmb3JtIiwiUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24iLCJhbmltYXRpb25PcHRpb25zUGFyc2VyIiwic2NoZW1lIiwiX2FuaW1hdG9yRGljdCIsInRlbXBsYXRlIiwiQW5pbWF0b3IiLCJyZXdyaXRhYmxlcyIsIk9uc1NwbGl0dGVyRWxlbWVudCIsImdlbmVyYXRlSWQiLCJ0ZW1wbGF0ZVNvdXJjZSIsIklOUFVUX0FUVFJJQlVURVMiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3VkE7QUFDQTtBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ozs7S0FqSHdCOztBQW9IM0IsR0FBQSxPQUFPLGVBQVAsR0FBeUIsU0FBUyxlQUFULENBQXlCLFdBQXpCLEVBQXNDO0FBQzdELEdBQUEsYUFBVyxhQUFhO0FBRHFDLEdBQUEsQ0FBdEMsQ0FBekI7OztBQ2pKQSxHQUFBLE9BQU8sZ0JBQVAsQ0FBd0IsTUFBeEIsRUFBZ0MsWUFBTTtBQUNsQyxHQUFBLE1BQUksU0FBSixHQUFnQixVQUFVLE1BQVYsQ0FBaUIsU0FBUyxJQUExQixDQUFoQjtBQUNILEdBQUEsQ0FGRCxFQUVHLEtBRkg7OztBQUtBLEdBQUEsT0FBTyxnQkFBUCxDQUF3QixrQkFBeEIsRUFBNEMsWUFBTTtBQUNoRCxHQUFBLE1BQUksMkJBQUosQ0FBZ0MsTUFBaEM7QUFDQSxHQUFBLE1BQUksK0JBQUosR0FBc0MsSUFBSSwyQkFBSixDQUFnQyxhQUFoQyxDQUE4QyxPQUFPLFFBQVAsQ0FBZ0IsSUFBOUQsRUFBb0UsWUFBTTtBQUM5RyxHQUFBLGNBQVUsR0FBVixDQUFjLE9BQWQ7QUFDRCxHQUFBLEdBRnFDLENBQXRDO0FBR0EsR0FBQSxXQUFTLElBQVQsQ0FBYyxnQkFBZCxHQUFpQyxJQUFJLElBQUksZUFBUixDQUF3QixTQUFTLElBQWpDLENBQWpDO0FBQ0QsR0FBQSxDQU5ELEVBTUcsS0FOSDs7O0FBU0EsR0FBQSxJQUFJLEtBQUosQ0FBVSxZQUFXO0FBQ25CLEdBQUEsTUFBSSx5QkFBSjtBQUNELEdBQUEsQ0FGRDs7O0FBS0EsR0FBQSxJQUFJLFFBQUosR0FBZSxLQUFmIiwiZmlsZSI6Im9uc2VudWkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNaW5pbWFsIGFuaW1hdGlvbiBsaWJyYXJ5IGZvciBtYW5hZ2luZyBjc3MgdHJhbnNpdGlvbiBvbiBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG53aW5kb3cuYW5pbWl0ID0gKGZ1bmN0aW9uKCl7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgVElNRU9VVF9SQVRJTyA9IDEuNDtcclxuXHJcbiAgdmFyIHV0aWwgPSB7XHJcbiAgfTtcclxuXHJcbiAgLy8gY2FwaXRhbGl6ZSBzdHJpbmdcclxuICB1dGlsLmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnByb3BlcnR5XHJcbiAgKiBAcGFyYW0ge0Zsb2F0fSBwYXJhbXMuZHVyYXRpb25cclxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGltaW5nXHJcbiAgKi9cclxuICB1dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICBwYXJhbXMucHJvcGVydHkgPSBwYXJhbXMucHJvcGVydHkgfHwgJ2FsbCc7XHJcbiAgICBwYXJhbXMuZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb24gfHwgMC40O1xyXG4gICAgcGFyYW1zLnRpbWluZyA9IHBhcmFtcy50aW1pbmcgfHwgJ2xpbmVhcic7XHJcblxyXG4gICAgdmFyIHByb3BzID0gcGFyYW1zLnByb3BlcnR5LnNwbGl0KC8gKy8pO1xyXG5cclxuICAgIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xyXG4gICAgICByZXR1cm4gcHJvcCArICcgJyArIHBhcmFtcy5kdXJhdGlvbiArICdzICcgKyBwYXJhbXMudGltaW5nO1xyXG4gICAgfSkuam9pbignLCAnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxyXG4gICovXHJcbiAgdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm4gPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBpZiAoZWxlbWVudCA9PSBldmVudC50YXJnZXQpIHtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xyXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcclxuICB9O1xyXG5cclxuICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIGlmICgnb250cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcclxuICAgICAgcmV0dXJuIFsndHJhbnNpdGlvbmVuZCddO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcclxuICAgICAgcmV0dXJuIFsnd2Via2l0VHJhbnNpdGlvbkVuZCddO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1dGlsLnZlbmRvclByZWZpeCA9PT0gJ3dlYmtpdCcgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdvJyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21veicgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtcycpIHtcclxuICAgICAgcmV0dXJuIFt1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW107XHJcbiAgfSkoKTtcclxuXHJcbiAgdXRpbC5fY3NzUHJvcGVydHlEaWN0ID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xyXG4gICAgdmFyIGRpY3QgPSB7fTtcclxuICAgIHZhciBhID0gJ0EnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICB2YXIgeiA9ICd6Jy5jaGFyQ29kZUF0KDApO1xyXG5cclxuICAgIHZhciB1cHBlciA9IGZ1bmN0aW9uKHMpIHtcclxuICAgICAgcmV0dXJuIHMuc3Vic3RyKDEpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICB2YXIga2V5ID0gc3R5bGVzW2ldXHJcbiAgICAgICAgLnJlcGxhY2UoL15bXFwtXSsvLCAnJylcclxuICAgICAgICAucmVwbGFjZSgvW1xcLV1bYS16XS9nLCB1cHBlcilcclxuICAgICAgICAucmVwbGFjZSgvXm1vei8sICdNb3onKTtcclxuXHJcbiAgICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICBpZiAoa2V5ICE9PSAnY3NzVGV4dCcgJiYga2V5ICE9PSAncGFyZW50VGV4dCcpIHtcclxuICAgICAgICAgIGRpY3Rba2V5XSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpY3Q7XHJcbiAgfSkoKTtcclxuXHJcbiAgdXRpbC5oYXNDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lIGluIHV0aWwuX2Nzc1Byb3BlcnR5RGljdDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXHJcbiAgICovXHJcbiAgdXRpbC52ZW5kb3JQcmVmaXggPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXHJcbiAgICBwcmUgPSAoQXJyYXkucHJvdG90eXBlLnNsaWNlXHJcbiAgICAgIC5jYWxsKHN0eWxlcylcclxuICAgICAgLmpvaW4oJycpXHJcbiAgICAgIC5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKSB8fCAoc3R5bGVzLk9MaW5rID09PSAnJyAmJiBbJycsICdvJ10pXHJcbiAgICApWzFdO1xyXG4gICAgcmV0dXJuIHByZTtcclxuICB9KSgpO1xyXG5cclxuICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmJhdGNoSW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xyXG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAvLyBmb3JjZSBsYXlvdXRcclxuICAgICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgfSk7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB1dGlsLmJhdGNoSW1tZWRpYXRlID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICAgICAgICBjYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XHJcblxyXG4gICAgdmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJhZihmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICAgICAgICBjYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuICB1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWUgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSgndHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcclxuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xyXG4gICAgICByZXR1cm4gdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKi9cclxuICB2YXIgQW5pbWl0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFuaW1pdCkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBBbmltaXQoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzID0gW2VsZW1lbnRdO1xyXG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnQ7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IG9yIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50LicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlID0gW107XHJcbiAgICB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3QgPSBbXTtcclxuICB9O1xyXG5cclxuICBBbmltaXQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdHJhbnNpdGlvblF1ZXVlOiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBlbGVtZW50czogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgcGxheTogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30pXHJcbiAgICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXHJcbiAgICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjc3M6IHtjb2xvcjogJ3JlZCd9LCBkdXJhdGlvbjogMC4yfSlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICovXHJcbiAgICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICB2YXIgcXVldWUgPSB0aGlzLnRyYW5zaXRpb25RdWV1ZTtcclxuXHJcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zLmNzcyA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbihvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikpIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcclxuICAgICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xyXG4gICAgICAgICAgICBjc3M6IHRyYW5zaXRpb25cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgIHF1ZXVlLnB1c2godHJhbnNpdGlvbik7XHJcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RmxvYXR9IHNlY29uZHNcclxuICAgICAqL1xyXG4gICAgd2FpdDogZnVuY3Rpb24oc2Vjb25kcykge1xyXG4gICAgICBpZiAoc2Vjb25kcyA+IDApIHtcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCAqIHNlY29uZHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG4gICAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmUgZWxlbWVudCdzIHN0eWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWluZ11cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxyXG4gICAgICovXHJcbiAgICByZXN0b3JlU3R5bGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5kdXJhdGlvblwiIGlzIHJlcXVpcmVkIHdoZW4gXCJvcHRpb25zLnRyYW5zaXRpb25cIiBpcyBlbmFibGVkLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSB1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWU7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSBvcHRpb25zLnRyYW5zaXRpb24gfHwgKCdhbGwgJyArIG9wdGlvbnMuZHVyYXRpb24gKyAncyAnICsgKG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInKSk7XHJcblxyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgIHZhciB0aW1lb3V0SWQ7XHJcblxyXG4gICAgICAgICAgdmFyIGNsZWFyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICcnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgLy8gYWRkIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIGZvciBmYWlsIHNhZmUuXHJcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgIH0sIG9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTyk7XHJcblxyXG4gICAgICAgICAgLy8gdHJhbnNpdGlvbiBhbmQgc3R5bGUgc2V0dGluZ3NcclxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjc3MpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XHJcbiAgICAgICAgICAgICAgaWYgKGNzc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgIGlmIChrZXkgIT09IHRyYW5zaXRpb25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgdHJhbnNpdGlvbiBhbmltYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgc2VsZi5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICdub25lJztcclxuXHJcbiAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcclxuXHJcbiAgICAgICAgICBpZiAoIWNzcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5hbWUgPSAnJzsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgc3RhcnRBbmltYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIF9kZXF1ZXVlVHJhbnNpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uUXVldWUuc2hpZnQoKTtcclxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50IHRyYW5zaXRpb24gZXhpc3RzLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcblxyXG4gICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2VsZi5fY3VycmVudFRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBzZWxmLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHR3aWNlLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QW5pbWl0fSBhcmd1bWVudHNcclxuICAgKi9cclxuICBBbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhcmd1bWVudHNbaV0ucGxheSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9wZXJ0eV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxyXG4gICAqL1xyXG4gIEFuaW1pdC5UcmFuc2l0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5kdXJhdGlvbiB8fCAwO1xyXG4gICAgdGhpcy5vcHRpb25zLnRpbWluZyA9IHRoaXMub3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XHJcbiAgICB0aGlzLm9wdGlvbnMuY3NzID0gdGhpcy5vcHRpb25zLmNzcyB8fCB7fTtcclxuICAgIHRoaXMub3B0aW9ucy5wcm9wZXJ0eSA9IHRoaXMub3B0aW9ucy5wcm9wZXJ0eSB8fCAnYWxsJztcclxuICB9O1xyXG5cclxuICBBbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jc3MpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5jc3MgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5vcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU87XHJcbiAgICAgICAgICB2YXIgdGltZW91dElkO1xyXG5cclxuICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgfSwgdGltZW91dCk7XHJcblxyXG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IGNzc1tuYW1lXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSAnJztcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IGNzc1tuYW1lXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlKGVsZW1lbnRzLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG5cclxuICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gY3NzW25hbWVdO1xyXG5cclxuICAgICAgICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIHByZWZpeGVkID0gdXRpbC52ZW5kb3JQcmVmaXggKyB1dGlsLmNhcGl0YWxpemUobmFtZSk7XHJcbiAgICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgcmV0dXJuIEFuaW1pdDtcclxufSkoKTtcclxuIiwiLypcclxuICogY2hpbGROb2RlLnJlbW92ZSBtZXRob2QgcG9seWZpbGwgZm9yIElFLlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2hpbGROb2RlL3JlbW92ZVxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuXHQgIEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcblx0ICAgIFx0dGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxufSkoKTtcclxuIiwiLypcclxuICogY2xhc3NMaXN0LmpzOiBDcm9zcy1icm93c2VyIGZ1bGwgZWxlbWVudC5jbGFzc0xpc3QgaW1wbGVtZW50YXRpb24uXHJcbiAqIDEuMS4yMDE1MDMxMlxyXG4gKlxyXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXHJcbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cclxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcclxuICovXHJcblxyXG4vKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXHJcblxyXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xyXG5cclxuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XHJcblxyXG4vLyBGdWxsIHBvbHlmaWxsIGZvciBicm93c2VycyB3aXRoIG5vIGNsYXNzTGlzdCBzdXBwb3J0XHJcbi8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxyXG5pZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpKVxyXG4gIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XHJcblxyXG4oZnVuY3Rpb24gKHZpZXcpIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XHJcblxyXG52YXJcclxuICAgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXHJcbiAgLCBwcm90b1Byb3AgPSBcInByb3RvdHlwZVwiXHJcbiAgLCBlbGVtQ3RyUHJvdG8gPSB2aWV3LkVsZW1lbnRbcHJvdG9Qcm9wXVxyXG4gICwgb2JqQ3RyID0gT2JqZWN0XHJcbiAgLCBzdHJUcmltID0gU3RyaW5nW3Byb3RvUHJvcF0udHJpbSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcclxuICB9XHJcbiAgLCBhcnJJbmRleE9mID0gQXJyYXlbcHJvdG9Qcm9wXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICB2YXJcclxuICAgICAgICBpID0gMFxyXG4gICAgICAsIGxlbiA9IHRoaXMubGVuZ3RoXHJcbiAgICA7XHJcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIC8vIFZlbmRvcnM6IHBsZWFzZSBhbGxvdyBjb250ZW50IGNvZGUgdG8gaW5zdGFudGlhdGUgRE9NRXhjZXB0aW9uc1xyXG4gICwgRE9NRXggPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xyXG4gICAgdGhpcy5uYW1lID0gdHlwZTtcclxuICAgIHRoaXMuY29kZSA9IERPTUV4Y2VwdGlvblt0eXBlXTtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgfVxyXG4gICwgY2hlY2tUb2tlbkFuZEdldEluZGV4ID0gZnVuY3Rpb24gKGNsYXNzTGlzdCwgdG9rZW4pIHtcclxuICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXgoXHJcbiAgICAgICAgICBcIlNZTlRBWF9FUlJcIlxyXG4gICAgICAgICwgXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWRcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKC9cXHMvLnRlc3QodG9rZW4pKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeChcclxuICAgICAgICAgIFwiSU5WQUxJRF9DSEFSQUNURVJfRVJSXCJcclxuICAgICAgICAsIFwiU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJJbmRleE9mLmNhbGwoY2xhc3NMaXN0LCB0b2tlbik7XHJcbiAgfVxyXG4gICwgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHZhclxyXG4gICAgICAgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcclxuICAgICAgLCBjbGFzc2VzID0gdHJpbW1lZENsYXNzZXMgPyB0cmltbWVkQ2xhc3Nlcy5zcGxpdCgvXFxzKy8pIDogW11cclxuICAgICAgLCBpID0gMFxyXG4gICAgICAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXHJcbiAgICA7XHJcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHRoaXMucHVzaChjbGFzc2VzW2ldKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgLCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cclxuICAsIGNsYXNzTGlzdEdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgQ2xhc3NMaXN0KHRoaXMpO1xyXG4gIH1cclxuO1xyXG4vLyBNb3N0IERPTUV4Y2VwdGlvbiBpbXBsZW1lbnRhdGlvbnMgZG9uJ3QgYWxsb3cgY2FsbGluZyBET01FeGNlcHRpb24ncyB0b1N0cmluZygpXHJcbi8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxyXG5ET01FeFtwcm90b1Byb3BdID0gRXJyb3JbcHJvdG9Qcm9wXTtcclxuY2xhc3NMaXN0UHJvdG8uaXRlbSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgcmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcclxufTtcclxuY2xhc3NMaXN0UHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICB0b2tlbiArPSBcIlwiO1xyXG4gIHJldHVybiBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pICE9PSAtMTtcclxufTtcclxuY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhclxyXG4gICAgICB0b2tlbnMgPSBhcmd1bWVudHNcclxuICAgICwgaSA9IDBcclxuICAgICwgbCA9IHRva2Vucy5sZW5ndGhcclxuICAgICwgdG9rZW5cclxuICAgICwgdXBkYXRlZCA9IGZhbHNlXHJcbiAgO1xyXG4gIGRvIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcclxuICAgIGlmIChjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pID09PSAtMSkge1xyXG4gICAgICB0aGlzLnB1c2godG9rZW4pO1xyXG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKCsraSA8IGwpO1xyXG5cclxuICBpZiAodXBkYXRlZCkge1xyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyXHJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xyXG4gICAgLCBpID0gMFxyXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxyXG4gICAgLCB0b2tlblxyXG4gICAgLCB1cGRhdGVkID0gZmFsc2VcclxuICAgICwgaW5kZXhcclxuICA7XHJcbiAgZG8ge1xyXG4gICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xyXG4gICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xyXG4gICAgd2hpbGUgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlICgrK2kgPCBsKTtcclxuXHJcbiAgaWYgKHVwZGF0ZWQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xyXG4gIHRva2VuICs9IFwiXCI7XHJcblxyXG4gIHZhclxyXG4gICAgICByZXN1bHQgPSB0aGlzLmNvbnRhaW5zKHRva2VuKVxyXG4gICAgLCBtZXRob2QgPSByZXN1bHQgP1xyXG4gICAgICBmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXHJcbiAgICA6XHJcbiAgICAgIGZvcmNlICE9PSBmYWxzZSAmJiBcImFkZFwiXHJcbiAgO1xyXG5cclxuICBpZiAobWV0aG9kKSB7XHJcbiAgICB0aGlzW21ldGhvZF0odG9rZW4pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZvcmNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gIXJlc3VsdDtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xyXG59O1xyXG5cclxuaWYgKG9iakN0ci5kZWZpbmVQcm9wZXJ0eSkge1xyXG4gIHZhciBjbGFzc0xpc3RQcm9wRGVzYyA9IHtcclxuICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcclxuICAgICwgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcclxuICB9O1xyXG4gIHRyeSB7XHJcbiAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XHJcbiAgfSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXHJcbiAgICBpZiAoZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xyXG4gICAgICBjbGFzc0xpc3RQcm9wRGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcclxuICAgIH1cclxuICB9XHJcbn0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xyXG4gIGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XHJcbn1cclxuXHJcbn0oc2VsZikpO1xyXG5cclxufSBlbHNlIHtcclxuLy8gVGhlcmUgaXMgZnVsbCBvciBwYXJ0aWFsIG5hdGl2ZSBjbGFzc0xpc3Qgc3VwcG9ydCwgc28ganVzdCBjaGVjayBpZiB3ZSBuZWVkXHJcbi8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKTtcclxuXHJcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7XHJcblxyXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXHJcbiAgLy8gY2xhc3NMaXN0LnJlbW92ZSBleGlzdCBidXQgc3VwcG9ydCBvbmx5IG9uZSBhcmd1bWVudCBhdCBhIHRpbWUuXHJcbiAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xyXG4gICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgICB2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XHJcblxyXG4gICAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih0b2tlbikge1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIHRva2VuID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCB0b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XHJcbiAgICBjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xyXG4gIH1cclxuXHJcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImMzXCIsIGZhbHNlKTtcclxuXHJcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxyXG4gIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICBpZiAodGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzNcIikpIHtcclxuICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XHJcblxyXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbih0b2tlbiwgZm9yY2UpIHtcclxuICAgICAgaWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcmNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICB9XHJcblxyXG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcclxufSgpKTtcclxuXHJcbn1cclxuXHJcbn1cclxuXHJcbiIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XHJcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XHJcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxyXG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xyXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxyXG4gKi9cclxuLy8gQHZlcnNpb24gMC43LjNcclxuaWYgKHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xyXG4gICAgdmFyIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xyXG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcclxuICAgIH07XHJcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcclxuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XHJcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcclxuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcclxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICAgIHJldHVybiAoZW50cnkgPSBrZXlbdGhpcy5uYW1lXSkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICB9LFxyXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcclxuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9LFxyXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xyXG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcclxuICB9KSgpO1xyXG59XHJcblxyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgdmFyIHNldEltbWVkaWF0ZTtcclxuICBpZiAoL1RyaWRlbnR8RWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcclxuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcclxuICAgIHNldEltbWVkaWF0ZSA9IHdpbmRvdy5zZXRJbW1lZGlhdGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xyXG4gICAgdmFyIHNlbnRpbmVsID0gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcclxuICAgICAgICB2YXIgcXVldWUgPSBzZXRJbW1lZGlhdGVRdWV1ZTtcclxuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xyXG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xyXG4gICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcclxuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHNlbnRpbmVsLCBcIipcIik7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcclxuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XHJcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xyXG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xyXG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XHJcbiAgICAgIHNldEltbWVkaWF0ZShkaXNwYXRjaENhbGxiYWNrcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHdyYXBJZk5lZWRlZChub2RlKSB7XHJcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFja3MoKSB7XHJcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcclxuICAgIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xyXG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XHJcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcclxuICAgIH0pO1xyXG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XHJcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcXVldWUgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xyXG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xyXG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2tfKHF1ZXVlLCBvYnNlcnZlcik7XHJcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKSB7XHJcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZXR1cm47XHJcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcclxuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XHJcbiAgICAgIGlmIChyZWdpc3RyYXRpb25zKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcclxuICAgICAgICAgIHZhciBvcHRpb25zID0gcmVnaXN0cmF0aW9uLm9wdGlvbnM7XHJcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xyXG4gICAgICAgICAgaWYgKHJlY29yZCkgcmVnaXN0cmF0aW9uLmVucXVldWUocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xyXG4gIGZ1bmN0aW9uIEpzTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgIHRoaXMubm9kZXNfID0gW107XHJcbiAgICB0aGlzLnJlY29yZHNfID0gW107XHJcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XHJcbiAgfVxyXG4gIEpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XHJcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XHJcbiAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhIHx8IG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KHRhcmdldCk7XHJcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XHJcbiAgICAgIHZhciByZWdpc3RyYXRpb247XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xyXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgcmVnaXN0cmF0aW9uID0gbmV3IFJlZ2lzdHJhdGlvbih0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xyXG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XHJcbiAgICB9LFxyXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xyXG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XHJcbiAgICB9LFxyXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY29weU9mUmVjb3JkcyA9IHRoaXMucmVjb3Jkc187XHJcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcclxuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xyXG4gICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcclxuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcclxuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gbnVsbDtcclxuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcclxuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcclxuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcclxuICAgIHJlY29yZC5hZGRlZE5vZGVzID0gb3JpZ2luYWwuYWRkZWROb2Rlcy5zbGljZSgpO1xyXG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xyXG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcclxuICAgIHJlY29yZC5uZXh0U2libGluZyA9IG9yaWdpbmFsLm5leHRTaWJsaW5nO1xyXG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcclxuICAgIHJlY29yZC5vbGRWYWx1ZSA9IG9yaWdpbmFsLm9sZFZhbHVlO1xyXG4gICAgcmV0dXJuIHJlY29yZDtcclxuICB9XHJcbiAgdmFyIGN1cnJlbnRSZWNvcmQsIHJlY29yZFdpdGhPbGRWYWx1ZTtcclxuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcclxuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XHJcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUgPSBjb3B5TXV0YXRpb25SZWNvcmQoY3VycmVudFJlY29yZCk7XHJcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcclxuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcclxuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XHJcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XHJcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcclxuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBSZWdpc3RyYXRpb24ob2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xyXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XHJcbiAgfVxyXG4gIFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcclxuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xyXG4gICAgICB2YXIgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7XHJcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIHJlY29yZFRvUmVwbGFjZUxhc3QgPSBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgcmVjb3JkKTtcclxuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xyXG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2sodGhpcy5vYnNlcnZlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xyXG4gICAgfSxcclxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xyXG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XHJcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xyXG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18odGhpcy50YXJnZXQpO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcclxuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xyXG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcclxuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgYWRkVHJhbnNpZW50T2JzZXJ2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XHJcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcclxuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XHJcbiAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgdHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcztcclxuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XHJcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKG5vZGUpO1xyXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XHJcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xyXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBlLnJlbGF0ZWROb2RlLm5hbWVzcGFjZVVSSTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XHJcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xyXG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGFyYWN0ZXJEYXRhXCIsIHRhcmdldCk7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XHJcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHJldHVybjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgIGNhc2UgXCJET01Ob2RlUmVtb3ZlZFwiOlxyXG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xyXG5cclxuICAgICAgIGNhc2UgXCJET01Ob2RlSW5zZXJ0ZWRcIjpcclxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcclxuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xyXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiRE9NTm9kZUluc2VydGVkXCIpIHtcclxuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XHJcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xyXG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGlsZExpc3RcIiwgZS50YXJnZXQucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xyXG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XHJcbiAgICAgICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzU2libGluZztcclxuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcclxuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCkgcmV0dXJuO1xyXG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBjbGVhclJlY29yZHMoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikgZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XHJcbn0pKHRoaXMpO1xyXG5cclxud2luZG93LkN1c3RvbUVsZW1lbnRzID0gd2luZG93LkN1c3RvbUVsZW1lbnRzIHx8IHtcclxuICBmbGFnczoge31cclxufTtcclxuXHJcbihmdW5jdGlvbihzY29wZSkge1xyXG4gIHZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xyXG4gIHZhciBtb2R1bGVzID0gW107XHJcbiAgdmFyIGFkZE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4gICAgbW9kdWxlcy5wdXNoKG1vZHVsZSk7XHJcbiAgfTtcclxuICB2YXIgaW5pdGlhbGl6ZU1vZHVsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuICAgICAgbW9kdWxlKHNjb3BlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgc2NvcGUuYWRkTW9kdWxlID0gYWRkTW9kdWxlO1xyXG4gIHNjb3BlLmluaXRpYWxpemVNb2R1bGVzID0gaW5pdGlhbGl6ZU1vZHVsZXM7XHJcbiAgc2NvcGUuaGFzTmF0aXZlID0gQm9vbGVhbihkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQpO1xyXG4gIHNjb3BlLnVzZU5hdGl2ZSA9ICFmbGFncy5yZWdpc3RlciAmJiBzY29wZS5oYXNOYXRpdmUgJiYgIXdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCAmJiAoIXdpbmRvdy5IVE1MSW1wb3J0cyB8fCBIVE1MSW1wb3J0cy51c2VOYXRpdmUpO1xyXG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xyXG5cclxud2luZG93LkN1c3RvbUVsZW1lbnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xyXG4gIHZhciBJTVBPUlRfTElOS19UWVBFID0gd2luZG93LkhUTUxJbXBvcnRzID8gSFRNTEltcG9ydHMuSU1QT1JUX0xJTktfVFlQRSA6IFwibm9uZVwiO1xyXG4gIGZ1bmN0aW9uIGZvclN1YnRyZWUobm9kZSwgY2IpIHtcclxuICAgIGZpbmRBbGxFbGVtZW50cyhub2RlLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmIChjYihlKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGZvclJvb3RzKGUsIGNiKTtcclxuICAgIH0pO1xyXG4gICAgZm9yUm9vdHMobm9kZSwgY2IpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmaW5kQWxsRWxlbWVudHMobm9kZSwgZmluZCwgZGF0YSkge1xyXG4gICAgdmFyIGUgPSBub2RlLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgaWYgKCFlKSB7XHJcbiAgICAgIGUgPSBub2RlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgIHdoaWxlIChlICYmIGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgZSA9IGUubmV4dFNpYmxpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdoaWxlIChlKSB7XHJcbiAgICAgIGlmIChmaW5kKGUsIGRhdGEpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgZmluZEFsbEVsZW1lbnRzKGUsIGZpbmQsIGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIGUgPSBlLm5leHRFbGVtZW50U2libGluZztcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmb3JSb290cyhub2RlLCBjYikge1xyXG4gICAgdmFyIHJvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XHJcbiAgICB3aGlsZSAocm9vdCkge1xyXG4gICAgICBmb3JTdWJ0cmVlKHJvb3QsIGNiKTtcclxuICAgICAgcm9vdCA9IHJvb3Qub2xkZXJTaGFkb3dSb290O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBmb3JEb2N1bWVudFRyZWUoZG9jLCBjYikge1xyXG4gICAgX2ZvckRvY3VtZW50VHJlZShkb2MsIGNiLCBbXSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF9mb3JEb2N1bWVudFRyZWUoZG9jLCBjYiwgcHJvY2Vzc2luZ0RvY3VtZW50cykge1xyXG4gICAgZG9jID0gd3JhcChkb2MpO1xyXG4gICAgaWYgKHByb2Nlc3NpbmdEb2N1bWVudHMuaW5kZXhPZihkb2MpID49IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc2luZ0RvY3VtZW50cy5wdXNoKGRvYyk7XHJcbiAgICB2YXIgaW1wb3J0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9XCIgKyBJTVBPUlRfTElOS19UWVBFICsgXCJdXCIpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbXBvcnRzLmxlbmd0aCwgbjsgaSA8IGwgJiYgKG4gPSBpbXBvcnRzW2ldKTsgaSsrKSB7XHJcbiAgICAgIGlmIChuLmltcG9ydCkge1xyXG4gICAgICAgIF9mb3JEb2N1bWVudFRyZWUobi5pbXBvcnQsIGNiLCBwcm9jZXNzaW5nRG9jdW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2IoZG9jKTtcclxuICB9XHJcbiAgc2NvcGUuZm9yRG9jdW1lbnRUcmVlID0gZm9yRG9jdW1lbnRUcmVlO1xyXG4gIHNjb3BlLmZvclN1YnRyZWUgPSBmb3JTdWJ0cmVlO1xyXG59KTtcclxuXHJcbndpbmRvdy5DdXN0b21FbGVtZW50cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcclxuICB2YXIgZmxhZ3MgPSBzY29wZS5mbGFncztcclxuICB2YXIgZm9yU3VidHJlZSA9IHNjb3BlLmZvclN1YnRyZWU7XHJcbiAgdmFyIGZvckRvY3VtZW50VHJlZSA9IHNjb3BlLmZvckRvY3VtZW50VHJlZTtcclxuICBmdW5jdGlvbiBhZGRlZE5vZGUobm9kZSkge1xyXG4gICAgcmV0dXJuIGFkZGVkKG5vZGUpIHx8IGFkZGVkU3VidHJlZShub2RlKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkZWQobm9kZSkge1xyXG4gICAgaWYgKHNjb3BlLnVwZ3JhZGUobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hlZChub2RlKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkZWRTdWJ0cmVlKG5vZGUpIHtcclxuICAgIGZvclN1YnRyZWUobm9kZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICBpZiAoYWRkZWQoZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGF0dGFjaGVkTm9kZShub2RlKSB7XHJcbiAgICBhdHRhY2hlZChub2RlKTtcclxuICAgIGlmIChpbkRvY3VtZW50KG5vZGUpKSB7XHJcbiAgICAgIGZvclN1YnRyZWUobm9kZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGF0dGFjaGVkKGUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIGhhc1BvbHlmaWxsTXV0YXRpb25zID0gIXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyID09PSB3aW5kb3cuSnNNdXRhdGlvbk9ic2VydmVyO1xyXG4gIHNjb3BlLmhhc1BvbHlmaWxsTXV0YXRpb25zID0gaGFzUG9seWZpbGxNdXRhdGlvbnM7XHJcbiAgdmFyIGlzUGVuZGluZ011dGF0aW9ucyA9IGZhbHNlO1xyXG4gIHZhciBwZW5kaW5nTXV0YXRpb25zID0gW107XHJcbiAgZnVuY3Rpb24gZGVmZXJNdXRhdGlvbihmbikge1xyXG4gICAgcGVuZGluZ011dGF0aW9ucy5wdXNoKGZuKTtcclxuICAgIGlmICghaXNQZW5kaW5nTXV0YXRpb25zKSB7XHJcbiAgICAgIGlzUGVuZGluZ011dGF0aW9ucyA9IHRydWU7XHJcbiAgICAgIHNldFRpbWVvdXQodGFrZU11dGF0aW9ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRha2VNdXRhdGlvbnMoKSB7XHJcbiAgICBpc1BlbmRpbmdNdXRhdGlvbnMgPSBmYWxzZTtcclxuICAgIHZhciAkcCA9IHBlbmRpbmdNdXRhdGlvbnM7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9ICRwLmxlbmd0aCwgcDsgaSA8IGwgJiYgKHAgPSAkcFtpXSk7IGkrKykge1xyXG4gICAgICBwKCk7XHJcbiAgICB9XHJcbiAgICBwZW5kaW5nTXV0YXRpb25zID0gW107XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGF0dGFjaGVkKGVsZW1lbnQpIHtcclxuICAgIGlmIChoYXNQb2x5ZmlsbE11dGF0aW9ucykge1xyXG4gICAgICBkZWZlck11dGF0aW9uKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9hdHRhY2hlZChlbGVtZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfYXR0YWNoZWQoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF9hdHRhY2hlZChlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudC5fX3VwZ3JhZGVkX18gJiYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjayB8fCBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spKSB7XHJcbiAgICAgIGlmICghZWxlbWVudC5fX2F0dGFjaGVkICYmIGluRG9jdW1lbnQoZWxlbWVudCkpIHtcclxuICAgICAgICBlbGVtZW50Ll9fYXR0YWNoZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChlbGVtZW50LmF0dGFjaGVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgIGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBkZXRhY2hlZE5vZGUobm9kZSkge1xyXG4gICAgZGV0YWNoZWQobm9kZSk7XHJcbiAgICBmb3JTdWJ0cmVlKG5vZGUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgZGV0YWNoZWQoZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGV0YWNoZWQoZWxlbWVudCkge1xyXG4gICAgaWYgKGhhc1BvbHlmaWxsTXV0YXRpb25zKSB7XHJcbiAgICAgIGRlZmVyTXV0YXRpb24oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX2RldGFjaGVkKGVsZW1lbnQpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9kZXRhY2hlZChlbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gX2RldGFjaGVkKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50Ll9fdXBncmFkZWRfXyAmJiAoZWxlbWVudC5hdHRhY2hlZENhbGxiYWNrIHx8IGVsZW1lbnQuZGV0YWNoZWRDYWxsYmFjaykpIHtcclxuICAgICAgaWYgKGVsZW1lbnQuX19hdHRhY2hlZCAmJiAhaW5Eb2N1bWVudChlbGVtZW50KSkge1xyXG4gICAgICAgIGVsZW1lbnQuX19hdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgIGVsZW1lbnQuZGV0YWNoZWRDYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBpbkRvY3VtZW50KGVsZW1lbnQpIHtcclxuICAgIHZhciBwID0gZWxlbWVudDtcclxuICAgIHZhciBkb2MgPSB3cmFwKGRvY3VtZW50KTtcclxuICAgIHdoaWxlIChwKSB7XHJcbiAgICAgIGlmIChwID09IGRvYykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHAgPSBwLnBhcmVudE5vZGUgfHwgcC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIHAuaG9zdDtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gd2F0Y2hTaGFkb3cobm9kZSkge1xyXG4gICAgaWYgKG5vZGUuc2hhZG93Um9vdCAmJiAhbm9kZS5zaGFkb3dSb290Ll9fd2F0Y2hlZCkge1xyXG4gICAgICBmbGFncy5kb20gJiYgY29uc29sZS5sb2coXCJ3YXRjaGluZyBzaGFkb3ctcm9vdCBmb3I6IFwiLCBub2RlLmxvY2FsTmFtZSk7XHJcbiAgICAgIHZhciByb290ID0gbm9kZS5zaGFkb3dSb290O1xyXG4gICAgICB3aGlsZSAocm9vdCkge1xyXG4gICAgICAgIG9ic2VydmUocm9vdCk7XHJcbiAgICAgICAgcm9vdCA9IHJvb3Qub2xkZXJTaGFkb3dSb290O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGhhbmRsZXIobXV0YXRpb25zKSB7XHJcbiAgICBpZiAoZmxhZ3MuZG9tKSB7XHJcbiAgICAgIHZhciBteCA9IG11dGF0aW9uc1swXTtcclxuICAgICAgaWYgKG14ICYmIG14LnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgJiYgbXguYWRkZWROb2Rlcykge1xyXG4gICAgICAgIGlmIChteC5hZGRlZE5vZGVzKSB7XHJcbiAgICAgICAgICB2YXIgZCA9IG14LmFkZGVkTm9kZXNbMF07XHJcbiAgICAgICAgICB3aGlsZSAoZCAmJiBkICE9PSBkb2N1bWVudCAmJiAhZC5ob3N0KSB7XHJcbiAgICAgICAgICAgIGQgPSBkLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgdSA9IGQgJiYgKGQuVVJMIHx8IGQuX1VSTCB8fCBkLmhvc3QgJiYgZC5ob3N0LmxvY2FsTmFtZSkgfHwgXCJcIjtcclxuICAgICAgICAgIHUgPSB1LnNwbGl0KFwiLz9cIikuc2hpZnQoKS5zcGxpdChcIi9cIikucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUuZ3JvdXAoXCJtdXRhdGlvbnMgKCVkKSBbJXNdXCIsIG11dGF0aW9ucy5sZW5ndGgsIHUgfHwgXCJcIik7XHJcbiAgICB9XHJcbiAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihteCkge1xyXG4gICAgICBpZiAobXgudHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xyXG4gICAgICAgIGZvckVhY2gobXguYWRkZWROb2RlcywgZnVuY3Rpb24obikge1xyXG4gICAgICAgICAgaWYgKCFuLmxvY2FsTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhZGRlZE5vZGUobik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yRWFjaChteC5yZW1vdmVkTm9kZXMsIGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICAgIGlmICghbi5sb2NhbE5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGV0YWNoZWROb2RlKG4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRha2VSZWNvcmRzKG5vZGUpIHtcclxuICAgIG5vZGUgPSB3cmFwKG5vZGUpO1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgIG5vZGUgPSB3cmFwKGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcclxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgIH1cclxuICAgIHZhciBvYnNlcnZlciA9IG5vZGUuX19vYnNlcnZlcjtcclxuICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICBoYW5kbGVyKG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xyXG4gICAgICB0YWtlTXV0YXRpb25zKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcclxuICBmdW5jdGlvbiBvYnNlcnZlKGluUm9vdCkge1xyXG4gICAgaWYgKGluUm9vdC5fX29ic2VydmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZXIpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShpblJvb3QsIHtcclxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGluUm9vdC5fX29ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVwZ3JhZGVEb2N1bWVudChkb2MpIHtcclxuICAgIGRvYyA9IHdyYXAoZG9jKTtcclxuICAgIGZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwKFwidXBncmFkZURvY3VtZW50OiBcIiwgZG9jLmJhc2VVUkkuc3BsaXQoXCIvXCIpLnBvcCgpKTtcclxuICAgIGFkZGVkTm9kZShkb2MpO1xyXG4gICAgb2JzZXJ2ZShkb2MpO1xyXG4gICAgZmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdXBncmFkZURvY3VtZW50VHJlZShkb2MpIHtcclxuICAgIGZvckRvY3VtZW50VHJlZShkb2MsIHVwZ3JhZGVEb2N1bWVudCk7XHJcbiAgfVxyXG4gIHZhciBvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QgPSBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290O1xyXG4gIGlmIChvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QpIHtcclxuICAgIEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHJvb3QgPSBvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QuY2FsbCh0aGlzKTtcclxuICAgICAgQ3VzdG9tRWxlbWVudHMud2F0Y2hTaGFkb3codGhpcyk7XHJcbiAgICAgIHJldHVybiByb290O1xyXG4gICAgfTtcclxuICB9XHJcbiAgc2NvcGUud2F0Y2hTaGFkb3cgPSB3YXRjaFNoYWRvdztcclxuICBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gdXBncmFkZURvY3VtZW50VHJlZTtcclxuICBzY29wZS51cGdyYWRlU3VidHJlZSA9IGFkZGVkU3VidHJlZTtcclxuICBzY29wZS51cGdyYWRlQWxsID0gYWRkZWROb2RlO1xyXG4gIHNjb3BlLmF0dGFjaGVkTm9kZSA9IGF0dGFjaGVkTm9kZTtcclxuICBzY29wZS50YWtlUmVjb3JkcyA9IHRha2VSZWNvcmRzO1xyXG59KTtcclxuXHJcbndpbmRvdy5DdXN0b21FbGVtZW50cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcclxuICB2YXIgZmxhZ3MgPSBzY29wZS5mbGFncztcclxuICBmdW5jdGlvbiB1cGdyYWRlKG5vZGUpIHtcclxuICAgIGlmICghbm9kZS5fX3VwZ3JhZGVkX18gJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgdmFyIGlzID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJpc1wiKTtcclxuICAgICAgdmFyIGRlZmluaXRpb24gPSBzY29wZS5nZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihpcyB8fCBub2RlLmxvY2FsTmFtZSk7XHJcbiAgICAgIGlmIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzICYmIGRlZmluaXRpb24udGFnID09IG5vZGUubG9jYWxOYW1lKSB7XHJcbiAgICAgICAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKG5vZGUsIGRlZmluaXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzICYmICFkZWZpbml0aW9uLmV4dGVuZHMpIHtcclxuICAgICAgICAgIHJldHVybiB1cGdyYWRlV2l0aERlZmluaXRpb24obm9kZSwgZGVmaW5pdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVwZ3JhZGVXaXRoRGVmaW5pdGlvbihlbGVtZW50LCBkZWZpbml0aW9uKSB7XHJcbiAgICBmbGFncy51cGdyYWRlICYmIGNvbnNvbGUuZ3JvdXAoXCJ1cGdyYWRlOlwiLCBlbGVtZW50LmxvY2FsTmFtZSk7XHJcbiAgICBpZiAoZGVmaW5pdGlvbi5pcykge1xyXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImlzXCIsIGRlZmluaXRpb24uaXMpO1xyXG4gICAgfVxyXG4gICAgaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIGRlZmluaXRpb24pO1xyXG4gICAgZWxlbWVudC5fX3VwZ3JhZGVkX18gPSB0cnVlO1xyXG4gICAgY3JlYXRlZChlbGVtZW50KTtcclxuICAgIHNjb3BlLmF0dGFjaGVkTm9kZShlbGVtZW50KTtcclxuICAgIHNjb3BlLnVwZ3JhZGVTdWJ0cmVlKGVsZW1lbnQpO1xyXG4gICAgZmxhZ3MudXBncmFkZSAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbiAgZnVuY3Rpb24gaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIGRlZmluaXRpb24pIHtcclxuICAgIGlmIChPYmplY3QuX19wcm90b19fKSB7XHJcbiAgICAgIGVsZW1lbnQuX19wcm90b19fID0gZGVmaW5pdGlvbi5wcm90b3R5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXN0b21NaXhpbihlbGVtZW50LCBkZWZpbml0aW9uLnByb3RvdHlwZSwgZGVmaW5pdGlvbi5uYXRpdmUpO1xyXG4gICAgICBlbGVtZW50Ll9fcHJvdG9fXyA9IGRlZmluaXRpb24ucHJvdG90eXBlO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBjdXN0b21NaXhpbihpblRhcmdldCwgaW5TcmMsIGluTmF0aXZlKSB7XHJcbiAgICB2YXIgdXNlZCA9IHt9O1xyXG4gICAgdmFyIHAgPSBpblNyYztcclxuICAgIHdoaWxlIChwICE9PSBpbk5hdGl2ZSAmJiBwICE9PSBIVE1MRWxlbWVudC5wcm90b3R5cGUpIHtcclxuICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGs7IGsgPSBrZXlzW2ldOyBpKyspIHtcclxuICAgICAgICBpZiAoIXVzZWRba10pIHtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpblRhcmdldCwgaywgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCBrKSk7XHJcbiAgICAgICAgICB1c2VkW2tdID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlZChlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudC5jcmVhdGVkQ2FsbGJhY2spIHtcclxuICAgICAgZWxlbWVudC5jcmVhdGVkQ2FsbGJhY2soKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2NvcGUudXBncmFkZSA9IHVwZ3JhZGU7XHJcbiAgc2NvcGUudXBncmFkZVdpdGhEZWZpbml0aW9uID0gdXBncmFkZVdpdGhEZWZpbml0aW9uO1xyXG4gIHNjb3BlLmltcGxlbWVudFByb3RvdHlwZSA9IGltcGxlbWVudFByb3RvdHlwZTtcclxufSk7XHJcblxyXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XHJcbiAgdmFyIGlzSUUxMU9yT2xkZXIgPSBzY29wZS5pc0lFMTFPck9sZGVyO1xyXG4gIHZhciB1cGdyYWRlRG9jdW1lbnRUcmVlID0gc2NvcGUudXBncmFkZURvY3VtZW50VHJlZTtcclxuICB2YXIgdXBncmFkZUFsbCA9IHNjb3BlLnVwZ3JhZGVBbGw7XHJcbiAgdmFyIHVwZ3JhZGVXaXRoRGVmaW5pdGlvbiA9IHNjb3BlLnVwZ3JhZGVXaXRoRGVmaW5pdGlvbjtcclxuICB2YXIgaW1wbGVtZW50UHJvdG90eXBlID0gc2NvcGUuaW1wbGVtZW50UHJvdG90eXBlO1xyXG4gIHZhciB1c2VOYXRpdmUgPSBzY29wZS51c2VOYXRpdmU7XHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGRlZmluaXRpb24gPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudDogZmlyc3QgYXJndW1lbnQgYG5hbWVgIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUuaW5kZXhPZihcIi1cIikgPCAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudDogZmlyc3QgYXJndW1lbnQgKCduYW1lJykgbXVzdCBjb250YWluIGEgZGFzaCAoJy0nKS4gQXJndW1lbnQgcHJvdmlkZWQgd2FzICdcIiArIFN0cmluZyhuYW1lKSArIFwiJy5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAncmVnaXN0ZXJFbGVtZW50JyBvbiAnRG9jdW1lbnQnOiBSZWdpc3RyYXRpb24gZmFpbGVkIGZvciB0eXBlICdcIiArIFN0cmluZyhuYW1lKSArIFwiJy4gVGhlIHR5cGUgbmFtZSBpcyBpbnZhbGlkLlwiKTtcclxuICAgIH1cclxuICAgIGlmIChnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihuYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGVEZWZpbml0aW9uRXJyb3I6IGEgdHlwZSB3aXRoIG5hbWUgJ1wiICsgU3RyaW5nKG5hbWUpICsgXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcclxuICAgIH1cclxuICAgIGlmICghZGVmaW5pdGlvbi5wcm90b3R5cGUpIHtcclxuICAgICAgZGVmaW5pdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbiAgICBkZWZpbml0aW9uLl9fbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGRlZmluaXRpb24ubGlmZWN5Y2xlID0gZGVmaW5pdGlvbi5saWZlY3ljbGUgfHwge307XHJcbiAgICBkZWZpbml0aW9uLmFuY2VzdHJ5ID0gYW5jZXN0cnkoZGVmaW5pdGlvbi5leHRlbmRzKTtcclxuICAgIHJlc29sdmVUYWdOYW1lKGRlZmluaXRpb24pO1xyXG4gICAgcmVzb2x2ZVByb3RvdHlwZUNoYWluKGRlZmluaXRpb24pO1xyXG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVBcGkoZGVmaW5pdGlvbi5wcm90b3R5cGUpO1xyXG4gICAgcmVnaXN0ZXJEZWZpbml0aW9uKGRlZmluaXRpb24uX19uYW1lLCBkZWZpbml0aW9uKTtcclxuICAgIGRlZmluaXRpb24uY3RvciA9IGdlbmVyYXRlQ29uc3RydWN0b3IoZGVmaW5pdGlvbik7XHJcbiAgICBkZWZpbml0aW9uLmN0b3IucHJvdG90eXBlID0gZGVmaW5pdGlvbi5wcm90b3R5cGU7XHJcbiAgICBkZWZpbml0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlZmluaXRpb24uY3RvcjtcclxuICAgIGlmIChzY29wZS5yZWFkeSkge1xyXG4gICAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZpbml0aW9uLmN0b3I7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG92ZXJyaWRlQXR0cmlidXRlQXBpKHByb3RvdHlwZSkge1xyXG4gICAgaWYgKHByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuX3BvbHlmaWxsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHNldEF0dHJpYnV0ZSA9IHByb3RvdHlwZS5zZXRBdHRyaWJ1dGU7XHJcbiAgICBwcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgY2hhbmdlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIHNldEF0dHJpYnV0ZSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZUF0dHJpYnV0ZSA9IHByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGU7XHJcbiAgICBwcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICBjaGFuZ2VBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCByZW1vdmVBdHRyaWJ1dGUpO1xyXG4gICAgfTtcclxuICAgIHByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuX3BvbHlmaWxsZWQgPSB0cnVlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wZXJhdGlvbikge1xyXG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xyXG4gICAgb3BlcmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcclxuICAgIGlmICh0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAmJiBuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gaXNSZXNlcnZlZFRhZyhuYW1lKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkVGFnTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAobmFtZSA9PT0gcmVzZXJ2ZWRUYWdMaXN0W2ldKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHJlc2VydmVkVGFnTGlzdCA9IFsgXCJhbm5vdGF0aW9uLXhtbFwiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJmb250LWZhY2VcIiwgXCJmb250LWZhY2Utc3JjXCIsIFwiZm9udC1mYWNlLXVyaVwiLCBcImZvbnQtZmFjZS1mb3JtYXRcIiwgXCJmb250LWZhY2UtbmFtZVwiLCBcIm1pc3NpbmctZ2x5cGhcIiBdO1xyXG4gIGZ1bmN0aW9uIGFuY2VzdHJ5KGV4dG5kcykge1xyXG4gICAgdmFyIGV4dGVuZGVlID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24oZXh0bmRzKTtcclxuICAgIGlmIChleHRlbmRlZSkge1xyXG4gICAgICByZXR1cm4gYW5jZXN0cnkoZXh0ZW5kZWUuZXh0ZW5kcykuY29uY2F0KFsgZXh0ZW5kZWUgXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKGRlZmluaXRpb24pIHtcclxuICAgIHZhciBiYXNlVGFnID0gZGVmaW5pdGlvbi5leHRlbmRzO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGE7IGEgPSBkZWZpbml0aW9uLmFuY2VzdHJ5W2ldOyBpKyspIHtcclxuICAgICAgYmFzZVRhZyA9IGEuaXMgJiYgYS50YWc7XHJcbiAgICB9XHJcbiAgICBkZWZpbml0aW9uLnRhZyA9IGJhc2VUYWcgfHwgZGVmaW5pdGlvbi5fX25hbWU7XHJcbiAgICBpZiAoYmFzZVRhZykge1xyXG4gICAgICBkZWZpbml0aW9uLmlzID0gZGVmaW5pdGlvbi5fX25hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlc29sdmVQcm90b3R5cGVDaGFpbihkZWZpbml0aW9uKSB7XHJcbiAgICBpZiAoIU9iamVjdC5fX3Byb3RvX18pIHtcclxuICAgICAgdmFyIG5hdGl2ZVByb3RvdHlwZSA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcclxuICAgICAgaWYgKGRlZmluaXRpb24uaXMpIHtcclxuICAgICAgICB2YXIgaW5zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVmaW5pdGlvbi50YWcpO1xyXG4gICAgICAgIHZhciBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KTtcclxuICAgICAgICBpZiAoZXhwZWN0ZWRQcm90b3R5cGUgPT09IGRlZmluaXRpb24ucHJvdG90eXBlKSB7XHJcbiAgICAgICAgICBuYXRpdmVQcm90b3R5cGUgPSBleHBlY3RlZFByb3RvdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHByb3RvID0gZGVmaW5pdGlvbi5wcm90b3R5cGUsIGFuY2VzdG9yO1xyXG4gICAgICB3aGlsZSAocHJvdG8gJiYgcHJvdG8gIT09IG5hdGl2ZVByb3RvdHlwZSkge1xyXG4gICAgICAgIGFuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICAgICAgICBwcm90by5fX3Byb3RvX18gPSBhbmNlc3RvcjtcclxuICAgICAgICBwcm90byA9IGFuY2VzdG9yO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmluaXRpb24ubmF0aXZlID0gbmF0aXZlUHJvdG90eXBlO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBpbnN0YW50aWF0ZShkZWZpbml0aW9uKSB7XHJcbiAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKGRvbUNyZWF0ZUVsZW1lbnQoZGVmaW5pdGlvbi50YWcpLCBkZWZpbml0aW9uKTtcclxuICB9XHJcbiAgdmFyIHJlZ2lzdHJ5ID0ge307XHJcbiAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24obmFtZSkge1xyXG4gICAgaWYgKG5hbWUpIHtcclxuICAgICAgcmV0dXJuIHJlZ2lzdHJ5W25hbWUudG9Mb3dlckNhc2UoKV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGVmaW5pdGlvbihuYW1lLCBkZWZpbml0aW9uKSB7XHJcbiAgICByZWdpc3RyeVtuYW1lXSA9IGRlZmluaXRpb247XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ29uc3RydWN0b3IoZGVmaW5pdGlvbikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gaW5zdGFudGlhdGUoZGVmaW5pdGlvbik7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgSFRNTF9OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcclxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWcsIHR5cGVFeHRlbnNpb24pIHtcclxuICAgIGlmIChuYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XHJcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZywgdHlwZUV4dGVuc2lvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZG9tQ3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIHR5cGVFeHRlbnNpb24pIHtcclxuICAgIGlmICh0YWcpIHtcclxuICAgICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZUV4dGVuc2lvbikge1xyXG4gICAgICB0eXBlRXh0ZW5zaW9uID0gdHlwZUV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG4gICAgdmFyIGRlZmluaXRpb24gPSBnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbih0eXBlRXh0ZW5zaW9uIHx8IHRhZyk7XHJcbiAgICBpZiAoZGVmaW5pdGlvbikge1xyXG4gICAgICBpZiAodGFnID09IGRlZmluaXRpb24udGFnICYmIHR5cGVFeHRlbnNpb24gPT0gZGVmaW5pdGlvbi5pcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgZGVmaW5pdGlvbi5jdG9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0eXBlRXh0ZW5zaW9uICYmICFkZWZpbml0aW9uLmlzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBkZWZpbml0aW9uLmN0b3IoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGVsZW1lbnQ7XHJcbiAgICBpZiAodHlwZUV4dGVuc2lvbikge1xyXG4gICAgICBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImlzXCIsIHR5cGVFeHRlbnNpb24pO1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIGVsZW1lbnQgPSBkb21DcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICBpZiAodGFnLmluZGV4T2YoXCItXCIpID49IDApIHtcclxuICAgICAgaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIEhUTUxFbGVtZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuICB2YXIgZG9tQ3JlYXRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChkb2N1bWVudCk7XHJcbiAgdmFyIGRvbUNyZWF0ZUVsZW1lbnROUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUy5iaW5kKGRvY3VtZW50KTtcclxuICB2YXIgaXNJbnN0YW5jZTtcclxuICBpZiAoIU9iamVjdC5fX3Byb3RvX18gJiYgIXVzZU5hdGl2ZSkge1xyXG4gICAgaXNJbnN0YW5jZSA9IGZ1bmN0aW9uKG9iaiwgY3Rvcikge1xyXG4gICAgICB2YXIgcCA9IG9iajtcclxuICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICBpZiAocCA9PT0gY3Rvci5wcm90b3R5cGUpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwID0gcC5fX3Byb3RvX187XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgaXNJbnN0YW5jZSA9IGZ1bmN0aW9uKG9iaiwgYmFzZSkge1xyXG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgYmFzZTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHdyYXBEb21NZXRob2RUb0ZvcmNlVXBncmFkZShvYmosIG1ldGhvZE5hbWUpIHtcclxuICAgIHZhciBvcmlnID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgb2JqW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBuID0gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB1cGdyYWRlQWxsKG4pO1xyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcbiAgfVxyXG4gIHdyYXBEb21NZXRob2RUb0ZvcmNlVXBncmFkZShOb2RlLnByb3RvdHlwZSwgXCJjbG9uZU5vZGVcIik7XHJcbiAgd3JhcERvbU1ldGhvZFRvRm9yY2VVcGdyYWRlKGRvY3VtZW50LCBcImltcG9ydE5vZGVcIik7XHJcbiAgaWYgKGlzSUUxMU9yT2xkZXIpIHtcclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGltcG9ydE5vZGUgPSBkb2N1bWVudC5pbXBvcnROb2RlO1xyXG4gICAgICBkb2N1bWVudC5pbXBvcnROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG4gPSBpbXBvcnROb2RlLmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmIChuLm5vZGVUeXBlID09IG4uRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xyXG4gICAgICAgICAgdmFyIGYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICBmLmFwcGVuZENoaWxkKG4pO1xyXG4gICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcbiAgfVxyXG4gIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCA9IHJlZ2lzdGVyO1xyXG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xyXG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyA9IGNyZWF0ZUVsZW1lbnROUztcclxuICBzY29wZS5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xyXG4gIHNjb3BlLmluc3RhbmNlb2YgPSBpc0luc3RhbmNlO1xyXG4gIHNjb3BlLnJlc2VydmVkVGFnTGlzdCA9IHJlc2VydmVkVGFnTGlzdDtcclxuICBzY29wZS5nZXRSZWdpc3RlcmVkRGVmaW5pdGlvbiA9IGdldFJlZ2lzdGVyZWREZWZpbml0aW9uO1xyXG4gIGRvY3VtZW50LnJlZ2lzdGVyID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50O1xyXG59KTtcclxuXHJcbihmdW5jdGlvbihzY29wZSkge1xyXG4gIHZhciB1c2VOYXRpdmUgPSBzY29wZS51c2VOYXRpdmU7XHJcbiAgdmFyIGluaXRpYWxpemVNb2R1bGVzID0gc2NvcGUuaW5pdGlhbGl6ZU1vZHVsZXM7XHJcbiAgdmFyIGlzSUUxMU9yT2xkZXIgPSAvVHJpZGVudC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICBpZiAodXNlTmF0aXZlKSB7XHJcbiAgICB2YXIgbm9wID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIHNjb3BlLndhdGNoU2hhZG93ID0gbm9wO1xyXG4gICAgc2NvcGUudXBncmFkZSA9IG5vcDtcclxuICAgIHNjb3BlLnVwZ3JhZGVBbGwgPSBub3A7XHJcbiAgICBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gbm9wO1xyXG4gICAgc2NvcGUudXBncmFkZVN1YnRyZWUgPSBub3A7XHJcbiAgICBzY29wZS50YWtlUmVjb3JkcyA9IG5vcDtcclxuICAgIHNjb3BlLmluc3RhbmNlb2YgPSBmdW5jdGlvbihvYmosIGJhc2UpIHtcclxuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGJhc2U7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpbml0aWFsaXplTW9kdWxlcygpO1xyXG4gIH1cclxuICB2YXIgdXBncmFkZURvY3VtZW50VHJlZSA9IHNjb3BlLnVwZ3JhZGVEb2N1bWVudFRyZWU7XHJcbiAgaWYgKCF3aW5kb3cud3JhcCkge1xyXG4gICAgaWYgKHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCkge1xyXG4gICAgICB3aW5kb3cud3JhcCA9IFNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZDtcclxuICAgICAgd2luZG93LnVud3JhcCA9IFNoYWRvd0RPTVBvbHlmaWxsLnVud3JhcElmTmVlZGVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LndyYXAgPSB3aW5kb3cudW53cmFwID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBib290c3RyYXAoKSB7XHJcbiAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKHdyYXAoZG9jdW1lbnQpKTtcclxuICAgIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcclxuICAgICAgSFRNTEltcG9ydHMuX19pbXBvcnRzUGFyc2luZ0hvb2sgPSBmdW5jdGlvbihlbHQpIHtcclxuICAgICAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKHdyYXAoZWx0LmltcG9ydCkpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgQ3VzdG9tRWxlbWVudHMucmVhZHkgPSB0cnVlO1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgQ3VzdG9tRWxlbWVudHMucmVhZHlUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xyXG4gICAgICAgIEN1c3RvbUVsZW1lbnRzLmVsYXBzZWQgPSBDdXN0b21FbGVtZW50cy5yZWFkeVRpbWUgLSBIVE1MSW1wb3J0cy5yZWFkeVRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJXZWJDb21wb25lbnRzUmVhZHlcIiwge1xyXG4gICAgICAgIGJ1YmJsZXM6IHRydWVcclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChpc0lFMTFPck9sZGVyICYmIHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgd2luZG93LkN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oaW5UeXBlLCBwYXJhbXMpIHtcclxuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xyXG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XHJcbiAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KGluVHlwZSwgQm9vbGVhbihwYXJhbXMuYnViYmxlcyksIEJvb2xlYW4ocGFyYW1zLmNhbmNlbGFibGUpLCBwYXJhbXMuZGV0YWlsKTtcclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9O1xyXG4gICAgd2luZG93LkN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XHJcbiAgfVxyXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgc2NvcGUuZmxhZ3MuZWFnZXIpIHtcclxuICAgIGJvb3RzdHJhcCgpO1xyXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiICYmICF3aW5kb3cuYXR0YWNoRXZlbnQgJiYgKCF3aW5kb3cuSFRNTEltcG9ydHMgfHwgd2luZG93LkhUTUxJbXBvcnRzLnJlYWR5KSkge1xyXG4gICAgYm9vdHN0cmFwKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBsb2FkRXZlbnQgPSB3aW5kb3cuSFRNTEltcG9ydHMgJiYgIUhUTUxJbXBvcnRzLnJlYWR5ID8gXCJIVE1MSW1wb3J0c0xvYWRlZFwiIDogXCJET01Db250ZW50TG9hZGVkXCI7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihsb2FkRXZlbnQsIGJvb3RzdHJhcCk7XHJcbiAgfVxyXG4gIHNjb3BlLmlzSUUxMU9yT2xkZXIgPSBpc0lFMTFPck9sZGVyO1xyXG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xyXG4iLCJpZiAoIXdpbmRvdy5DdXN0b21FdmVudCkge1xyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIHZhciBDdXN0b21FdmVudDtcclxuXHJcbiAgICBDdXN0b21FdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBwYXJhbXMpIHtcclxuICAgICAgdmFyIGV2dDtcclxuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtcclxuICAgICAgICBidWJibGVzOiBmYWxzZSxcclxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcclxuICAgICAgICBkZXRhaWw6IHVuZGVmaW5lZFxyXG4gICAgICB9O1xyXG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xyXG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xyXG4gICAgICByZXR1cm4gZXZ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xyXG5cclxuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xyXG4gIH0pKCk7XHJcbn1cclxuIiwiOyhmdW5jdGlvbiAoKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHQvKipcclxuXHQgKiBAcHJlc2VydmUgRmFzdENsaWNrOiBwb2x5ZmlsbCB0byByZW1vdmUgY2xpY2sgZGVsYXlzIG9uIGJyb3dzZXJzIHdpdGggdG91Y2ggVUlzLlxyXG5cdCAqXHJcblx0ICogQGNvZGluZ3N0YW5kYXJkIGZ0bGFicy1qc3YyXHJcblx0ICogQGNvcHlyaWdodCBUaGUgRmluYW5jaWFsIFRpbWVzIExpbWl0ZWQgW0FsbCBSaWdodHMgUmVzZXJ2ZWRdXHJcblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcclxuXHQgKi9cclxuXHJcblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xyXG5cdC8qZ2xvYmFsIGRlZmluZSwgRXZlbnQsIE5vZGUqL1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGUgZmFzdC1jbGlja2luZyBsaXN0ZW5lcnMgb24gdGhlIHNwZWNpZmllZCBsYXllci5cclxuXHQgKlxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb2xkT25DbGljaztcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgYSBjbGljayBpcyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSBib29sZWFuXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRpbWVzdGFtcCBmb3Igd2hlbiBjbGljayB0cmFja2luZyBzdGFydGVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIG51bWJlclxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSBFdmVudFRhcmdldFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xyXG5cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFgtY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSBudW1iZXJcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogWS1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIG51bWJlclxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gMDtcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSBudW1iZXJcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gMDtcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUb3VjaG1vdmUgYm91bmRhcnksIGJleW9uZCB3aGljaCBhIGNsaWNrIHdpbGwgYmUgY2FuY2VsbGVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIG51bWJlclxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIEZhc3RDbGljayBsYXllci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSBFbGVtZW50XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiB0YXAodG91Y2hzdGFydCBhbmQgdG91Y2hlbmQpIGV2ZW50c1xyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIG51bWJlclxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIG51bWJlclxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRhcFRpbWVvdXQgPSBvcHRpb25zLnRhcFRpbWVvdXQgfHwgNzAwO1xyXG5cclxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU29tZSBvbGQgdmVyc2lvbnMgb2YgQW5kcm9pZCBkb24ndCBoYXZlIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXHJcblx0XHRmdW5jdGlvbiBiaW5kKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0dmFyIG1ldGhvZHMgPSBbJ29uTW91c2UnLCAnb25DbGljaycsICdvblRvdWNoU3RhcnQnLCAnb25Ub3VjaE1vdmUnLCAnb25Ub3VjaEVuZCcsICdvblRvdWNoQ2FuY2VsJ107XHJcblx0XHR2YXIgY29udGV4dCA9IHRoaXM7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdGNvbnRleHRbbWV0aG9kc1tpXV0gPSBiaW5kKGNvbnRleHRbbWV0aG9kc1tpXV0sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB1cCBldmVudCBoYW5kbGVycyBhcyByZXF1aXJlZFxyXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xyXG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xyXG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2UsIHRydWUpO1xyXG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XHJcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcclxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIGZhbHNlKTtcclxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XHJcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xyXG5cclxuXHRcdC8vIEhhY2sgaXMgcmVxdWlyZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxyXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xyXG5cdFx0Ly8gbGF5ZXIgd2hlbiB0aGV5IGFyZSBjYW5jZWxsZWQuXHJcblx0XHRpZiAoIUV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcclxuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XHJcblx0XHRcdFx0dmFyIHJtdiA9IE5vZGUucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XHJcblx0XHRcdFx0dmFyIGFkdiA9IE5vZGUucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIWV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSksIGNhcHR1cmUpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiBhIGhhbmRsZXIgaXMgYWxyZWFkeSBkZWNsYXJlZCBpbiB0aGUgZWxlbWVudCdzIG9uY2xpY2sgYXR0cmlidXRlLCBpdCB3aWxsIGJlIGZpcmVkIGJlZm9yZVxyXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXHJcblx0XHQvLyBhZGRpbmcgaXQgYXMgbGlzdGVuZXIuXHJcblx0XHRpZiAodHlwZW9mIGxheWVyLm9uY2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuXHJcblx0XHRcdC8vIEFuZHJvaWQgYnJvd3NlciBvbiBhdCBsZWFzdCAzLjIgcmVxdWlyZXMgYSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBmdW5jdGlvbiBpbiBsYXllci5vbmNsaWNrXHJcblx0XHRcdC8vIC0gdGhlIG9sZCBvbmUgd29uJ3Qgd29yayBpZiBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lciBkaXJlY3RseS5cclxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XHJcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0XHRvbGRPbkNsaWNrKGV2ZW50KTtcclxuXHRcdFx0fSwgZmFsc2UpO1xyXG5cdFx0XHRsYXllci5vbmNsaWNrID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cclxuXHQqXHJcblx0KiBAdHlwZSBib29sZWFuXHJcblx0Ki9cclxuXHR2YXIgZGV2aWNlSXNXaW5kb3dzUGhvbmUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJXaW5kb3dzIFBob25lXCIpID49IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuZHJvaWQgcmVxdWlyZXMgZXhjZXB0aW9ucy5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIGJvb2xlYW5cclxuXHQgKi9cclxuXHR2YXIgZGV2aWNlSXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPiAwICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxyXG5cdCAqXHJcblx0ICogQHR5cGUgYm9vbGVhblxyXG5cdCAqL1xyXG5cdHZhciBkZXZpY2VJc0lPUyA9IC9pUChhZHxob25lfG9kKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhZGV2aWNlSXNXaW5kb3dzUGhvbmU7XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBpT1MgNCByZXF1aXJlcyBhbiBleGNlcHRpb24gZm9yIHNlbGVjdCBlbGVtZW50cy5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIGJvb2xlYW5cclxuXHQgKi9cclxuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogaU9TIDYuMC03LiogcmVxdWlyZXMgdGhlIHRhcmdldCBlbGVtZW50IHRvIGJlIG1hbnVhbGx5IGRlcml2ZWRcclxuXHQgKlxyXG5cdCAqIEB0eXBlIGJvb2xlYW5cclxuXHQgKi9cclxuXHR2YXIgZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyBbNi03XV9cXGQvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuXHQvKipcclxuXHQgKiBCbGFja0JlcnJ5IHJlcXVpcmVzIGV4Y2VwdGlvbnMuXHJcblx0ICpcclxuXHQgKiBAdHlwZSBib29sZWFuXHJcblx0ICovXHJcblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXHJcblx0ICovXHJcblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0NsaWNrID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG5cdFx0Ly8gRG9uJ3Qgc2VuZCBhIHN5bnRoZXRpYyBjbGljayB0byBkaXNhYmxlZCBpbnB1dHMgKGlzc3VlICM2MilcclxuXHRcdGNhc2UgJ2J1dHRvbic6XHJcblx0XHRjYXNlICdzZWxlY3QnOlxyXG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxyXG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnaW5wdXQnOlxyXG5cclxuXHRcdFx0Ly8gRmlsZSBpbnB1dHMgbmVlZCByZWFsIGNsaWNrcyBvbiBpT1MgNiBkdWUgdG8gYSBicm93c2VyIGJ1ZyAoaXNzdWUgIzY4KVxyXG5cdFx0XHRpZiAoKGRldmljZUlzSU9TICYmIHRhcmdldC50eXBlID09PSAnZmlsZScpIHx8IHRhcmdldC5kaXNhYmxlZCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2xhYmVsJzpcclxuXHRcdGNhc2UgJ2lmcmFtZSc6IC8vIGlPUzggaG9tZXNjcmVlbiBhcHBzIGNhbiBwcmV2ZW50IGV2ZW50cyBidWJibGluZyBpbnRvIGZyYW1lc1xyXG5cdFx0Y2FzZSAndmlkZW8nOlxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKC9cXGJuZWVkc2NsaWNrXFxiLykudGVzdCh0YXJnZXQuY2xhc3NOYW1lKTtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXHJcblx0ICovXHJcblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0ZvY3VzID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRjYXNlICd0ZXh0YXJlYSc6XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0Y2FzZSAnc2VsZWN0JzpcclxuXHRcdFx0cmV0dXJuICFkZXZpY2VJc0FuZHJvaWQ7XHJcblx0XHRjYXNlICdpbnB1dCc6XHJcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcclxuXHRcdFx0Y2FzZSAnYnV0dG9uJzpcclxuXHRcdFx0Y2FzZSAnY2hlY2tib3gnOlxyXG5cdFx0XHRjYXNlICdmaWxlJzpcclxuXHRcdFx0Y2FzZSAnaW1hZ2UnOlxyXG5cdFx0XHRjYXNlICdyYWRpbyc6XHJcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBObyBwb2ludCBpbiBhdHRlbXB0aW5nIHRvIGZvY3VzIGRpc2FibGVkIGlucHV0c1xyXG5cdFx0XHRyZXR1cm4gIXRhcmdldC5kaXNhYmxlZCAmJiAhdGFyZ2V0LnJlYWRPbmx5O1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuICgvXFxibmVlZHNmb2N1c1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlbmQgYSBjbGljayBldmVudCB0byB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqL1xyXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcclxuXHRcdHZhciBjbGlja0V2ZW50LCB0b3VjaDtcclxuXHJcblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxyXG5cdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGFyZ2V0RWxlbWVudCkge1xyXG5cdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cclxuXHRcdC8vIFN5bnRoZXNpemUgYSBjbGljayBldmVudCwgd2l0aCBhbiBleHRyYSBhdHRyaWJ1dGUgc28gaXQgY2FuIGJlIHRyYWNrZWRcclxuXHRcdGNsaWNrRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcclxuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xyXG5cdFx0Y2xpY2tFdmVudC5mb3J3YXJkZWRUb3VjaEV2ZW50ID0gdHJ1ZTtcclxuXHRcdHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcclxuXHR9O1xyXG5cclxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRldGVybWluZUV2ZW50VHlwZSA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcclxuXHJcblx0XHQvL0lzc3VlICMxNTk6IEFuZHJvaWQgQ2hyb21lIFNlbGVjdCBCb3ggZG9lcyBub3Qgb3BlbiB3aXRoIGEgc3ludGhldGljIGNsaWNrIGV2ZW50XHJcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkICYmIHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xyXG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICdjbGljayc7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxyXG5cdCAqL1xyXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XHJcblx0XHR2YXIgbGVuZ3RoO1xyXG5cclxuXHRcdC8vIElzc3VlICMxNjA6IG9uIGlPUyA3LCBzb21lIGlucHV0IGVsZW1lbnRzIChlLmcuIGRhdGUgZGF0ZXRpbWUgbW9udGgpIHRocm93IGEgdmFndWUgVHlwZUVycm9yIG9uIHNldFNlbGVjdGlvblJhbmdlLiBUaGVzZSBlbGVtZW50cyBkb24ndCBoYXZlIGFuIGludGVnZXIgdmFsdWUgZm9yIHRoZSBzZWxlY3Rpb25TdGFydCBhbmQgc2VsZWN0aW9uRW5kIHByb3BlcnRpZXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoYXQgY2FuJ3QgYmUgdXNlZCBmb3IgZGV0ZWN0aW9uIGJlY2F1c2UgYWNjZXNzaW5nIHRoZSBwcm9wZXJ0aWVzIGFsc28gdGhyb3dzIGEgVHlwZUVycm9yLiBKdXN0IGNoZWNrIHRoZSB0eXBlIGluc3RlYWQuIEZpbGVkIGFzIEFwcGxlIGJ1ZyAjMTUxMjI3MjQuXHJcblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSAmJiB0YXJnZXRFbGVtZW50LnR5cGUuaW5kZXhPZignZGF0ZScpICE9PSAwICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ3RpbWUnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ21vbnRoJykge1xyXG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcclxuXHRcdFx0dGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShsZW5ndGgsIGxlbmd0aCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxyXG5cdCAqL1xyXG5cdEZhc3RDbGljay5wcm90b3R5cGUudXBkYXRlU2Nyb2xsUGFyZW50ID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xyXG5cdFx0dmFyIHNjcm9sbFBhcmVudCwgcGFyZW50RWxlbWVudDtcclxuXHJcblx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcclxuXHJcblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcclxuXHRcdC8vIHRhcmdldCBlbGVtZW50IHdhcyBtb3ZlZCB0byBhbm90aGVyIHBhcmVudC5cclxuXHRcdGlmICghc2Nyb2xsUGFyZW50IHx8ICFzY3JvbGxQYXJlbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcclxuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XHJcblx0XHRcdGRvIHtcclxuXHRcdFx0XHRpZiAocGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodCkge1xyXG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcclxuXHRcdFx0XHRcdHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxyXG5cdFx0aWYgKHNjcm9sbFBhcmVudCkge1xyXG5cdFx0XHRzY3JvbGxQYXJlbnQuZmFzdENsaWNrTGFzdFNjcm9sbFRvcCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cclxuXHQgKi9cclxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQgPSBmdW5jdGlvbihldmVudFRhcmdldCkge1xyXG5cclxuXHRcdC8vIE9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgKG5vdGFibHkgU2FmYXJpIG9uIGlPUyA0LjEgLSBzZWUgaXNzdWUgIzU2KSB0aGUgZXZlbnQgdGFyZ2V0IG1heSBiZSBhIHRleHQgbm9kZS5cclxuXHRcdGlmIChldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcclxuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBPbiB0b3VjaCBzdGFydCwgcmVjb3JkIHRoZSBwb3NpdGlvbiBhbmQgc2Nyb2xsIG9mZnNldC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICovXHJcblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0dmFyIHRhcmdldEVsZW1lbnQsIHRvdWNoLCBzZWxlY3Rpb247XHJcblxyXG5cdFx0Ly8gSWdub3JlIG11bHRpcGxlIHRvdWNoZXMsIG90aGVyd2lzZSBwaW5jaC10by16b29tIGlzIHByZXZlbnRlZCBpZiBib3RoIGZpbmdlcnMgYXJlIG9uIHRoZSBGYXN0Q2xpY2sgZWxlbWVudCAoaXNzdWUgIzExMSkuXHJcblx0XHRpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcclxuXHRcdHRvdWNoID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXTtcclxuXHJcblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcclxuXHJcblx0XHRcdC8vIE9ubHkgdHJ1c3RlZCBldmVudHMgd2lsbCBkZXNlbGVjdCB0ZXh0IG9uIGlPUyAoaXNzdWUgIzQ5KVxyXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcblx0XHRcdGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCAmJiAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghZGV2aWNlSXNJT1M0KSB7XHJcblxyXG5cdFx0XHRcdC8vIFdlaXJkIHRoaW5ncyBoYXBwZW4gb24gaU9TIHdoZW4gYW4gYWxlcnQgb3IgY29uZmlybSBkaWFsb2cgaXMgb3BlbmVkIGZyb20gYSBjbGljayBldmVudCBjYWxsYmFjayAoaXNzdWUgIzIzKTpcclxuXHRcdFx0XHQvLyB3aGVuIHRoZSB1c2VyIG5leHQgdGFwcyBhbnl3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCBuZXcgdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXHJcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXHJcblx0XHRcdFx0Ly8gU2FkbHksIHRoZXJlIGlzIGFuIGlzc3VlIG9uIGlPUyA0IHRoYXQgY2F1c2VzIHNvbWUgbm9ybWFsIHRvdWNoIGV2ZW50cyB0byBoYXZlIHRoZSBzYW1lIGlkZW50aWZpZXIgYXMgYW5cclxuXHRcdFx0XHQvLyBpbW1lZGlhdGVseSBwcmVjZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXHJcblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXHJcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGFsbCB0b3VjaCBldmVudHMgdG8gYmUgaWdub3JlZC4gQXMgdGhpcyBibG9jayBvbmx5IGFwcGxpZXMgdG8gaU9TLCBhbmQgaU9TIGlkZW50aWZpZXJzIGFyZSBhbHdheXMgbG9uZyxcclxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXHJcblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcclxuXHJcblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyICh1c2luZyAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2gpIGFuZDpcclxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXHJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXHJcblx0XHRcdFx0Ly8gdGhlbiB0aGUgZXZlbnQudGFyZ2V0IG9mIHRoZSBsYXN0ICd0b3VjaGVuZCcgZXZlbnQgd2lsbCBiZSB0aGUgZWxlbWVudCB0aGF0IHdhcyB1bmRlciB0aGUgdXNlcidzIGZpbmdlclxyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xyXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cclxuXHRcdFx0XHR0aGlzLnVwZGF0ZVNjcm9sbFBhcmVudCh0YXJnZXRFbGVtZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XHJcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcclxuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XHJcblxyXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xyXG5cdFx0dGhpcy50b3VjaFN0YXJ0WSA9IHRvdWNoLnBhZ2VZO1xyXG5cclxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXHJcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqL1xyXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XHJcblxyXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqL1xyXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xyXG5cdFx0aWYgKHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCkgfHwgdGhpcy50b3VjaEhhc01vdmVkKGV2ZW50KSkge1xyXG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8SFRNTExhYmVsRWxlbWVudH0gbGFiZWxFbGVtZW50XHJcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cclxuXHQgKi9cclxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZpbmRDb250cm9sID0gZnVuY3Rpb24obGFiZWxFbGVtZW50KSB7XHJcblxyXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxyXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5jb250cm9sICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxyXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XHJcblx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsYWJlbEVsZW1lbnQuaHRtbEZvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgbm8gZm9yIGF0dHJpYnV0ZSBleGlzdHMsIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGZpcnN0IGxhYmVsbGFibGUgZGVzY2VuZGFudCBlbGVtZW50XHJcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcclxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICovXHJcblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcclxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xyXG5cdFx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IHRydWU7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IHRvIHByZXZlbnQgd3JvbmcgY2xpY2sgY2FuY2VsIG9uIGlucHV0IChpc3N1ZSAjMTU2KS5cclxuXHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5sYXN0Q2xpY2tUaW1lID0gZXZlbnQudGltZVN0YW1wO1xyXG5cclxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xyXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XHJcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XHJcblxyXG5cdFx0Ly8gT24gc29tZSBpT1MgZGV2aWNlcywgdGhlIHRhcmdldEVsZW1lbnQgc3VwcGxpZWQgd2l0aCB0aGUgZXZlbnQgaXMgaW52YWxpZCBpZiB0aGUgbGF5ZXJcclxuXHRcdC8vIGlzIHBlcmZvcm1pbmcgYSB0cmFuc2l0aW9uIG9yIHNjcm9sbCwgYW5kIGhhcyB0byBiZSByZS1kZXRlY3RlZCBtYW51YWxseS4gTm90ZSB0aGF0XHJcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxyXG5cdFx0Ly8gU2VlIGlzc3VlICM1NzsgYWxzbyBmaWxlZCBhcyByZGFyOi8vMTMwNDg1ODkgLlxyXG5cdFx0aWYgKGRldmljZUlzSU9TV2l0aEJhZFRhcmdldCkge1xyXG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cclxuXHRcdFx0Ly8gSW4gY2VydGFpbiBjYXNlcyBhcmd1bWVudHMgb2YgZWxlbWVudEZyb21Qb2ludCBjYW4gYmUgbmVnYXRpdmUsIHNvIHByZXZlbnQgc2V0dGluZyB0YXJnZXRFbGVtZW50IHRvIG51bGxcclxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xyXG5cdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0VGFnTmFtZSA9IHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0aWYgKHRhcmdldFRhZ05hbWUgPT09ICdsYWJlbCcpIHtcclxuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XHJcblx0XHRcdGlmIChmb3JFbGVtZW50KSB7XHJcblx0XHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcclxuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0YXJnZXRFbGVtZW50ID0gZm9yRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcclxuXHJcblx0XHRcdC8vIENhc2UgMTogSWYgdGhlIHRvdWNoIHN0YXJ0ZWQgYSB3aGlsZSBhZ28gKGJlc3QgZ3Vlc3MgaXMgMTAwbXMgYmFzZWQgb24gdGVzdHMgZm9yIGlzc3VlICMzNikgdGhlbiBmb2N1cyB3aWxsIGJlIHRyaWdnZXJlZCBhbnl3YXkuIFJldHVybiBlYXJseSBhbmQgdW5zZXQgdGhlIHRhcmdldCBlbGVtZW50IHJlZmVyZW5jZSBzbyB0aGF0IHRoZSBzdWJzZXF1ZW50IGNsaWNrIHdpbGwgYmUgYWxsb3dlZCB0aHJvdWdoLlxyXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxyXG5cdFx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRyYWNraW5nQ2xpY2tTdGFydCkgPiAxMDAgfHwgKGRldmljZUlzSU9TICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB0YXJnZXRUYWdOYW1lID09PSAnaW5wdXQnKSkge1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xyXG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XHJcblxyXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXHJcblx0XHRcdC8vIEFsc28gdGhpcyBicmVha3Mgb3BlbmluZyBzZWxlY3RzIHdoZW4gVm9pY2VPdmVyIGlzIGFjdGl2ZSBvbiBpT1M2LCBpT1M3IChhbmQgcG9zc2libHkgb3RoZXJzKVxyXG5cdFx0XHRpZiAoIWRldmljZUlzSU9TIHx8IHRhcmdldFRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XHJcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcclxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRldmljZUlzSU9TICYmICFkZXZpY2VJc0lPUzQpIHtcclxuXHJcblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcclxuXHRcdFx0Ly8gYW5kIHRoaXMgdGFwIGlzIGJlaW5nIHVzZWQgdG8gc3RvcCB0aGUgc2Nyb2xsaW5nICh1c3VhbGx5IGluaXRpYXRlZCBieSBhIGZsaW5nIC0gaXNzdWUgIzQyKS5cclxuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XHJcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFByZXZlbnQgdGhlIGFjdHVhbCBjbGljayBmcm9tIGdvaW5nIHRob3VnaCAtIHVubGVzcyB0aGUgdGFyZ2V0IG5vZGUgaXMgbWFya2VkIGFzIHJlcXVpcmluZ1xyXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cclxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRhcmdldEVsZW1lbnQpKSB7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIE9uIHRvdWNoIGNhbmNlbCwgc3RvcCB0cmFja2luZyB0aGUgY2xpY2suXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgKi9cclxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xyXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lIG1vdXNlIGV2ZW50cyB3aGljaCBzaG91bGQgYmUgcGVybWl0dGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xyXG5cclxuXHRcdC8vIElmIGEgdGFyZ2V0IGVsZW1lbnQgd2FzIG5ldmVyIHNldCAoYmVjYXVzZSBhIHRvdWNoIGV2ZW50IHdhcyBuZXZlciBmaXJlZCkgYWxsb3cgdGhlIGV2ZW50XHJcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBQcm9ncmFtbWF0aWNhbGx5IGdlbmVyYXRlZCBldmVudHMgdGFyZ2V0aW5nIGEgc3BlY2lmaWMgZWxlbWVudCBzaG91bGQgYmUgcGVybWl0dGVkXHJcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGVyaXZlIGFuZCBjaGVjayB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gc2VlIHdoZXRoZXIgdGhlIG1vdXNlIGV2ZW50IG5lZWRzIHRvIGJlIHBlcm1pdHRlZDtcclxuXHRcdC8vIHVubGVzcyBleHBsaWNpdGx5IGVuYWJsZWQsIHByZXZlbnQgbm9uLXRvdWNoIGNsaWNrIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgYWN0aW9ucyxcclxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxyXG5cdFx0aWYgKCF0aGlzLm5lZWRzQ2xpY2sodGhpcy50YXJnZXRFbGVtZW50KSB8fCB0aGlzLmNhbmNlbE5leHRDbGljaykge1xyXG5cclxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cclxuXHRcdFx0aWYgKGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBQYXJ0IG9mIHRoZSBoYWNrIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIChlLmcuIEFuZHJvaWQgMilcclxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XHJcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHRoZSBtb3VzZSBldmVudCBpcyBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogT24gYWN0dWFsIGNsaWNrcywgZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHRvdWNoLWdlbmVyYXRlZCBjbGljaywgYSBjbGljayBhY3Rpb24gb2NjdXJyaW5nXHJcblx0ICogbmF0dXJhbGx5IGFmdGVyIGEgZGVsYXkgYWZ0ZXIgYSB0b3VjaCAod2hpY2ggbmVlZHMgdG8gYmUgY2FuY2VsbGVkIHRvIGF2b2lkIGR1cGxpY2F0aW9uKSwgb3JcclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICovXHJcblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdHZhciBwZXJtaXR0ZWQ7XHJcblxyXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3IgYW5vdGhlciBGYXN0Q2xpY2stbGlrZSBsaWJyYXJ5IGRlbGl2ZXJlZCB3aXRoIHRoaXJkLXBhcnR5IGNvZGUgdG8gZmlyZSBhIGNsaWNrIGV2ZW50IGJlZm9yZSBGYXN0Q2xpY2sgZG9lcyAoaXNzdWUgIzQ0KS4gSW4gdGhhdCBjYXNlLCBzZXQgdGhlIGNsaWNrLXRyYWNraW5nIGZsYWcgYmFjayB0byBmYWxzZSBhbmQgcmV0dXJuIGVhcmx5LiBUaGlzIHdpbGwgY2F1c2Ugb25Ub3VjaEVuZCB0byByZXR1cm4gZWFybHkuXHJcblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XHJcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvciBvbiBpT1MgKGlzc3VlICMxOCk6IGlmIGEgc3VibWl0IGVsZW1lbnQgaXMgcHJlc2VudCBpbnNpZGUgYSBmb3JtIGFuZCB0aGUgdXNlciBoaXRzIGVudGVyIGluIHRoZSBpT1Mgc2ltdWxhdG9yIG9yIGNsaWNrcyB0aGUgR28gYnV0dG9uIG9uIHRoZSBwb3AtdXAgT1Mga2V5Ym9hcmQgdGhlIGEga2luZCBvZiAnZmFrZScgY2xpY2sgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCB0aGUgc3VibWl0LXR5cGUgaW5wdXQgZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxyXG5cdFx0aWYgKGV2ZW50LnRhcmdldC50eXBlID09PSAnc3VibWl0JyAmJiBldmVudC5kZXRhaWwgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcclxuXHJcblx0XHQvLyBPbmx5IHVuc2V0IHRhcmdldEVsZW1lbnQgaWYgdGhlIGNsaWNrIGlzIG5vdCBwZXJtaXR0ZWQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgY2hlY2sgZm9yICF0YXJnZXRFbGVtZW50IGluIG9uTW91c2UgZmFpbHMgYW5kIHRoZSBicm93c2VyJ3MgY2xpY2sgZG9lc24ndCBnbyB0aHJvdWdoLlxyXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcclxuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiBjbGlja3MgYXJlIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cclxuXHRcdHJldHVybiBwZXJtaXR0ZWQ7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBhbGwgRmFzdENsaWNrJ3MgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge3ZvaWR9XHJcblx0ICovXHJcblx0RmFzdENsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xyXG5cclxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcclxuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcclxuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcclxuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRydWUpO1xyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XHJcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XHJcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCwgZmFsc2UpO1xyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcclxuXHR9O1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgd2hldGhlciBGYXN0Q2xpY2sgaXMgbmVlZGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXHJcblx0ICovXHJcblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XHJcblx0XHR2YXIgbWV0YVZpZXdwb3J0O1xyXG5cdFx0dmFyIGNocm9tZVZlcnNpb247XHJcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XHJcblx0XHR2YXIgZmlyZWZveFZlcnNpb247XHJcblxyXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcclxuXHRcdGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hyb21lIHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xyXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xyXG5cclxuXHRcdGlmIChjaHJvbWVWZXJzaW9uKSB7XHJcblxyXG5cdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XHJcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xyXG5cclxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XHJcblx0XHRcdFx0XHQvLyBDaHJvbWUgb24gQW5kcm9pZCB3aXRoIHVzZXItc2NhbGFibGU9XCJub1wiIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICM4OSlcclxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXHJcblx0XHRcdFx0XHRpZiAoY2hyb21lVmVyc2lvbiA+IDMxICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcclxuXHRcdFx0YmxhY2tiZXJyeVZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFswLTldKilcXC4oWzAtOV0qKS8pO1xyXG5cclxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9pc3N1ZXMvMjUxXHJcblx0XHRcdGlmIChibGFja2JlcnJ5VmVyc2lvblsxXSA+PSAxMCAmJiBibGFja2JlcnJ5VmVyc2lvblsyXSA+PSAzKSB7XHJcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xyXG5cclxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XHJcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXHJcblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIHdpZHRoPWRldmljZS13aWR0aCAob3IgbGVzcyB0aGFuIGRldmljZS13aWR0aCkgZWxpbWluYXRlcyBjbGljayBkZWxheS5cclxuXHRcdFx0XHRcdGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5NylcclxuXHRcdGlmIChsYXllci5zdHlsZS5tc1RvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpcmVmb3ggdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXHJcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcclxuXHJcblx0XHRpZiAoZmlyZWZveFZlcnNpb24gPj0gMjcpIHtcclxuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XHJcblxyXG5cdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XHJcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSUUxMTogcHJlZml4ZWQgLW1zLXRvdWNoLWFjdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFuZCBpdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBub24tcHJlZml4ZWQgdmVyc2lvblxyXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9IaDc2NzMxMy5hc3B4XHJcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xyXG5cdCAqL1xyXG5cdEZhc3RDbGljay5hdHRhY2ggPSBmdW5jdGlvbihsYXllciwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG4gIHdpbmRvdy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXIgKHNlcnZlciBvciBicm93c2VyKVxyXG4gKiBcclxuICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXHJcbiAqIC0gZG9udCByZWx5IG9uIHRoZSBicm93c2VyIGRvbXNcclxuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0ZWx5LCBubyBteXN0ZXJ5LCBubyBtYWdpYyBpbnZvbHZlZFxyXG4gKlxyXG4gKiAtIGNyZWF0ZSBhIE1pY3JvRXZlbnREZWJ1ZyB3aXRoIGdvb2RpZXMgdG8gZGVidWdcclxuICogICAtIG1ha2UgaXQgc2FmZXIgdG8gdXNlXHJcbiovXHJcblxyXG4vKiogTk9URTogVGhpcyBsaWJyYXJ5IGlzIGN1c3RvbWl6ZWQgZm9yIE9uc2VuIFVJLiAqL1xyXG5cclxudmFyIE1pY3JvRXZlbnQgID0gZnVuY3Rpb24oKXt9O1xyXG5NaWNyb0V2ZW50LnByb3RvdHlwZSAgPSB7XHJcbiAgb24gIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XHJcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcclxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xyXG4gIH0sXHJcbiAgb25jZSA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZXIpO1xyXG4gICAgICByZXR1cm4gZmN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbihldmVudCwgd3JhcHBlcik7XHJcbiAgfSxcclxuICBvZmYgIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XHJcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgICBpZiggZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSAgKSAgcmV0dXJuO1xyXG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5zcGxpY2UodGhpcy5fZXZlbnRzW2V2ZW50XS5pbmRleE9mKGZjdCksIDEpO1xyXG4gIH0sXHJcbiAgZW1pdCA6IGZ1bmN0aW9uKGV2ZW50IC8qICwgYXJncy4uLiAqLyl7XHJcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgICBpZiggZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSAgKSAgcmV0dXJuO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50c1tldmVudF0ubGVuZ3RoOyBpKyspe1xyXG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBtaXhpbiB3aWxsIGRlbGVnYXRlIGFsbCBNaWNyb0V2ZW50LmpzIGZ1bmN0aW9uIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcclxuICpcclxuICogLSByZXF1aXJlKCdNaWNyb0V2ZW50JykubWl4aW4oRm9vYmFyKSB3aWxsIG1ha2UgRm9vYmFyIGFibGUgdG8gdXNlIE1pY3JvRXZlbnRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBzdXBwb3J0IE1pY3JvRXZlbnRcclxuKi9cclxuTWljcm9FdmVudC5taXhpbiAgPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcclxuICB2YXIgcHJvcHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ2VtaXQnXTtcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICsrKXtcclxuICAgIGlmKCB0eXBlb2YgZGVzdE9iamVjdCA9PT0gJ2Z1bmN0aW9uJyApe1xyXG4gICAgICBkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgIGRlc3RPYmplY3RbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gZXhwb3J0IGluIGNvbW1vbiBqc1xyXG5pZiggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoJ2V4cG9ydHMnIGluIG1vZHVsZSkpe1xyXG4gIG1vZHVsZS5leHBvcnRzICA9IE1pY3JvRXZlbnQ7XHJcbn1cclxuXHJcbndpbmRvdy5NaWNyb0V2ZW50ID0gTWljcm9FdmVudDtcclxuIiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcclxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcclxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XHJcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXHJcbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XHJcbiAqL1xyXG4vLyBAdmVyc2lvbiAwLjcuMjJcclxuaWYgKHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xyXG4gICAgdmFyIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xyXG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcclxuICAgIH07XHJcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcclxuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XHJcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcclxuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcclxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICAgIHJldHVybiAoZW50cnkgPSBrZXlbdGhpcy5uYW1lXSkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICB9LFxyXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcclxuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9LFxyXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xyXG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcclxuICB9KSgpO1xyXG59XHJcblxyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgaWYgKGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgdmFyIHNldEltbWVkaWF0ZTtcclxuICBpZiAoL1RyaWRlbnR8RWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcclxuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcclxuICAgIHNldEltbWVkaWF0ZSA9IHdpbmRvdy5zZXRJbW1lZGlhdGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xyXG4gICAgdmFyIHNlbnRpbmVsID0gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcclxuICAgICAgICB2YXIgcXVldWUgPSBzZXRJbW1lZGlhdGVRdWV1ZTtcclxuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xyXG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xyXG4gICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcclxuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHNlbnRpbmVsLCBcIipcIik7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcclxuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XHJcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xyXG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xyXG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XHJcbiAgICAgIHNldEltbWVkaWF0ZShkaXNwYXRjaENhbGxiYWNrcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHdyYXBJZk5lZWRlZChub2RlKSB7XHJcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFja3MoKSB7XHJcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcclxuICAgIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xyXG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XHJcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcclxuICAgIH0pO1xyXG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XHJcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xyXG4gICAgICB2YXIgcXVldWUgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xyXG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xyXG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2tfKHF1ZXVlLCBvYnNlcnZlcik7XHJcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKSB7XHJcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZXR1cm47XHJcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcclxuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XHJcbiAgICAgIGlmIChyZWdpc3RyYXRpb25zKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcclxuICAgICAgICAgIHZhciBvcHRpb25zID0gcmVnaXN0cmF0aW9uLm9wdGlvbnM7XHJcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xyXG4gICAgICAgICAgaWYgKHJlY29yZCkgcmVnaXN0cmF0aW9uLmVucXVldWUocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xyXG4gIGZ1bmN0aW9uIEpzTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgIHRoaXMubm9kZXNfID0gW107XHJcbiAgICB0aGlzLnJlY29yZHNfID0gW107XHJcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XHJcbiAgfVxyXG4gIEpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XHJcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XHJcbiAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhIHx8IG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KHRhcmdldCk7XHJcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XHJcbiAgICAgIHZhciByZWdpc3RyYXRpb247XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xyXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgcmVnaXN0cmF0aW9uID0gbmV3IFJlZ2lzdHJhdGlvbih0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xyXG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XHJcbiAgICB9LFxyXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xyXG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XHJcbiAgICB9LFxyXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY29weU9mUmVjb3JkcyA9IHRoaXMucmVjb3Jkc187XHJcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcclxuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xyXG4gICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcclxuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcclxuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gbnVsbDtcclxuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcclxuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcclxuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcclxuICAgIHJlY29yZC5hZGRlZE5vZGVzID0gb3JpZ2luYWwuYWRkZWROb2Rlcy5zbGljZSgpO1xyXG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xyXG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcclxuICAgIHJlY29yZC5uZXh0U2libGluZyA9IG9yaWdpbmFsLm5leHRTaWJsaW5nO1xyXG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcclxuICAgIHJlY29yZC5vbGRWYWx1ZSA9IG9yaWdpbmFsLm9sZFZhbHVlO1xyXG4gICAgcmV0dXJuIHJlY29yZDtcclxuICB9XHJcbiAgdmFyIGN1cnJlbnRSZWNvcmQsIHJlY29yZFdpdGhPbGRWYWx1ZTtcclxuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcclxuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XHJcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUgPSBjb3B5TXV0YXRpb25SZWNvcmQoY3VycmVudFJlY29yZCk7XHJcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcclxuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcclxuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XHJcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XHJcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcclxuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBSZWdpc3RyYXRpb24ob2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xyXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XHJcbiAgfVxyXG4gIFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcclxuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xyXG4gICAgICB2YXIgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7XHJcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIHJlY29yZFRvUmVwbGFjZUxhc3QgPSBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgcmVjb3JkKTtcclxuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xyXG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2sodGhpcy5vYnNlcnZlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xyXG4gICAgfSxcclxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xyXG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XHJcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xyXG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18odGhpcy50YXJnZXQpO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcclxuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xyXG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcclxuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgYWRkVHJhbnNpZW50T2JzZXJ2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XHJcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcclxuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XHJcbiAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgdHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcztcclxuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XHJcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKG5vZGUpO1xyXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XHJcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xyXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBlLnJlbGF0ZWROb2RlLm5hbWVzcGFjZVVSSTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XHJcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xyXG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGFyYWN0ZXJEYXRhXCIsIHRhcmdldCk7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XHJcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHJldHVybjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgIGNhc2UgXCJET01Ob2RlUmVtb3ZlZFwiOlxyXG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xyXG5cclxuICAgICAgIGNhc2UgXCJET01Ob2RlSW5zZXJ0ZWRcIjpcclxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcclxuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xyXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiRE9NTm9kZUluc2VydGVkXCIpIHtcclxuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XHJcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xyXG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGlsZExpc3RcIiwgZS50YXJnZXQucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xyXG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XHJcbiAgICAgICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzU2libGluZztcclxuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcclxuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCkgcmV0dXJuO1xyXG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBjbGVhclJlY29yZHMoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICBKc011dGF0aW9uT2JzZXJ2ZXIuX2lzUG9seWZpbGxlZCA9IHRydWU7XHJcbiAgfVxyXG59KShzZWxmKTsiLCIhZnVuY3Rpb24gbih0LGUscil7ZnVuY3Rpb24gbyh1LGYpe2lmKCFlW3VdKXtpZighdFt1XSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyh1LCEwKTtpZihpKXJldHVybiBpKHUsITApO3ZhciBzPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrdStcIidcIik7dGhyb3cgcy5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHN9dmFyIGw9ZVt1XT17ZXhwb3J0czp7fX07dFt1XVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihuKXt2YXIgZT10W3VdWzFdW25dO3JldHVybiBvKGU/ZTpuKX0sbCxsLmV4cG9ydHMsbix0LGUscil9cmV0dXJuIGVbdV0uZXhwb3J0c31mb3IodmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSx1PTA7dTxyLmxlbmd0aDt1KyspbyhyW3VdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKG4sdCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7fWZ1bmN0aW9uIG8obil7dHJ5e3JldHVybiBuLnRoZW59Y2F0Y2godCl7cmV0dXJuIGQ9dCx3fX1mdW5jdGlvbiBpKG4sdCl7dHJ5e3JldHVybiBuKHQpfWNhdGNoKGUpe3JldHVybiBkPWUsd319ZnVuY3Rpb24gdShuLHQsZSl7dHJ5e24odCxlKX1jYXRjaChyKXtyZXR1cm4gZD1yLHd9fWZ1bmN0aW9uIGYobil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ld1wiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSBmdW5jdGlvblwiKTt0aGlzLl8zNz0wLHRoaXMuXzEyPW51bGwsdGhpcy5fNTk9W10sbiE9PXImJnYobix0aGlzKX1mdW5jdGlvbiBjKG4sdCxlKXtyZXR1cm4gbmV3IG4uY29uc3RydWN0b3IoZnVuY3Rpb24obyxpKXt2YXIgdT1uZXcgZihyKTt1LnRoZW4obyxpKSxzKG4sbmV3IHAodCxlLHUpKX0pfWZ1bmN0aW9uIHMobix0KXtmb3IoOzM9PT1uLl8zNzspbj1uLl8xMjtyZXR1cm4gMD09PW4uXzM3P3ZvaWQgbi5fNTkucHVzaCh0KTp2b2lkIHkoZnVuY3Rpb24oKXt2YXIgZT0xPT09bi5fMzc/dC5vbkZ1bGZpbGxlZDp0Lm9uUmVqZWN0ZWQ7aWYobnVsbD09PWUpcmV0dXJuIHZvaWQoMT09PW4uXzM3P2wodC5wcm9taXNlLG4uXzEyKTphKHQucHJvbWlzZSxuLl8xMikpO3ZhciByPWkoZSxuLl8xMik7cj09PXc/YSh0LnByb21pc2UsZCk6bCh0LnByb21pc2Uscil9KX1mdW5jdGlvbiBsKG4sdCl7aWYodD09PW4pcmV0dXJuIGEobixuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIikpO2lmKHQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkpe3ZhciBlPW8odCk7aWYoZT09PXcpcmV0dXJuIGEobixkKTtpZihlPT09bi50aGVuJiZ0IGluc3RhbmNlb2YgZilyZXR1cm4gbi5fMzc9MyxuLl8xMj10LHZvaWQgaChuKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlKXJldHVybiB2b2lkIHYoZS5iaW5kKHQpLG4pfW4uXzM3PTEsbi5fMTI9dCxoKG4pfWZ1bmN0aW9uIGEobix0KXtuLl8zNz0yLG4uXzEyPXQsaChuKX1mdW5jdGlvbiBoKG4pe2Zvcih2YXIgdD0wO3Q8bi5fNTkubGVuZ3RoO3QrKylzKG4sbi5fNTlbdF0pO24uXzU5PW51bGx9ZnVuY3Rpb24gcChuLHQsZSl7dGhpcy5vbkZ1bGZpbGxlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246bnVsbCx0aGlzLm9uUmVqZWN0ZWQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90Om51bGwsdGhpcy5wcm9taXNlPWV9ZnVuY3Rpb24gdihuLHQpe3ZhciBlPSExLHI9dShuLGZ1bmN0aW9uKG4pe2V8fChlPSEwLGwodCxuKSl9LGZ1bmN0aW9uKG4pe2V8fChlPSEwLGEodCxuKSl9KTtlfHxyIT09d3x8KGU9ITAsYSh0LGQpKX12YXIgeT1uKFwiYXNhcC9yYXdcIiksZD1udWxsLHc9e307dC5leHBvcnRzPWYsZi5fOTk9cixmLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKG4sdCl7aWYodGhpcy5jb25zdHJ1Y3RvciE9PWYpcmV0dXJuIGModGhpcyxuLHQpO3ZhciBlPW5ldyBmKHIpO3JldHVybiBzKHRoaXMsbmV3IHAobix0LGUpKSxlfX0se1wiYXNhcC9yYXdcIjo0fV0sMjpbZnVuY3Rpb24obix0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIobil7dmFyIHQ9bmV3IG8oby5fOTkpO3JldHVybiB0Ll8zNz0xLHQuXzEyPW4sdH12YXIgbz1uKFwiLi9jb3JlLmpzXCIpO3QuZXhwb3J0cz1vO3ZhciBpPXIoITApLHU9cighMSksZj1yKG51bGwpLGM9cih2b2lkIDApLHM9cigwKSxsPXIoXCJcIik7by5yZXNvbHZlPWZ1bmN0aW9uKG4pe2lmKG4gaW5zdGFuY2VvZiBvKXJldHVybiBuO2lmKG51bGw9PT1uKXJldHVybiBmO2lmKHZvaWQgMD09PW4pcmV0dXJuIGM7aWYobj09PSEwKXJldHVybiBpO2lmKG49PT0hMSlyZXR1cm4gdTtpZigwPT09bilyZXR1cm4gcztpZihcIlwiPT09bilyZXR1cm4gbDtpZihcIm9iamVjdFwiPT10eXBlb2Ygbnx8XCJmdW5jdGlvblwiPT10eXBlb2Ygbil0cnl7dmFyIHQ9bi50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpcmV0dXJuIG5ldyBvKHQuYmluZChuKSl9Y2F0Y2goZSl7cmV0dXJuIG5ldyBvKGZ1bmN0aW9uKG4sdCl7dChlKX0pfXJldHVybiByKG4pfSxvLmFsbD1mdW5jdGlvbihuKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTtyZXR1cm4gbmV3IG8oZnVuY3Rpb24obixlKXtmdW5jdGlvbiByKHUsZil7aWYoZiYmKFwib2JqZWN0XCI9PXR5cGVvZiBmfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBmKSl7aWYoZiBpbnN0YW5jZW9mIG8mJmYudGhlbj09PW8ucHJvdG90eXBlLnRoZW4pe2Zvcig7Mz09PWYuXzM3OylmPWYuXzEyO3JldHVybiAxPT09Zi5fMzc/cih1LGYuXzEyKTooMj09PWYuXzM3JiZlKGYuXzEyKSx2b2lkIGYudGhlbihmdW5jdGlvbihuKXtyKHUsbil9LGUpKX12YXIgYz1mLnRoZW47aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYyl7dmFyIHM9bmV3IG8oYy5iaW5kKGYpKTtyZXR1cm4gdm9pZCBzLnRoZW4oZnVuY3Rpb24obil7cih1LG4pfSxlKX19dFt1XT1mLDA9PT0tLWkmJm4odCl9aWYoMD09PXQubGVuZ3RoKXJldHVybiBuKFtdKTtmb3IodmFyIGk9dC5sZW5ndGgsdT0wO3U8dC5sZW5ndGg7dSsrKXIodSx0W3VdKX0pfSxvLnJlamVjdD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IG8oZnVuY3Rpb24odCxlKXtlKG4pfSl9LG8ucmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IG8oZnVuY3Rpb24odCxlKXtuLmZvckVhY2goZnVuY3Rpb24obil7by5yZXNvbHZlKG4pLnRoZW4odCxlKX0pfSl9LG8ucHJvdG90eXBlW1wiY2F0Y2hcIl09ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMudGhlbihudWxsLG4pfX0se1wiLi9jb3JlLmpzXCI6MX1dLDM6W2Z1bmN0aW9uKG4sdCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7aWYoYy5sZW5ndGgpdGhyb3cgYy5zaGlmdCgpfWZ1bmN0aW9uIG8obil7dmFyIHQ7dD1mLmxlbmd0aD9mLnBvcCgpOm5ldyBpLHQudGFzaz1uLHUodCl9ZnVuY3Rpb24gaSgpe3RoaXMudGFzaz1udWxsfXZhciB1PW4oXCIuL3Jhd1wiKSxmPVtdLGM9W10scz11Lm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihyKTt0LmV4cG9ydHM9byxpLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKCl7dHJ5e3RoaXMudGFzay5jYWxsKCl9Y2F0Y2gobil7by5vbmVycm9yP28ub25lcnJvcihuKTooYy5wdXNoKG4pLHMoKSl9ZmluYWxseXt0aGlzLnRhc2s9bnVsbCxmW2YubGVuZ3RoXT10aGlzfX19LHtcIi4vcmF3XCI6NH1dLDQ6W2Z1bmN0aW9uKG4sdCxlKXsoZnVuY3Rpb24obil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShuKXtmLmxlbmd0aHx8KHUoKSxjPSEwKSxmW2YubGVuZ3RoXT1ufWZ1bmN0aW9uIHIoKXtmb3IoO3M8Zi5sZW5ndGg7KXt2YXIgbj1zO2lmKHMrPTEsZltuXS5jYWxsKCkscz5sKXtmb3IodmFyIHQ9MCxlPWYubGVuZ3RoLXM7ZT50O3QrKylmW3RdPWZbdCtzXTtmLmxlbmd0aC09cyxzPTB9fWYubGVuZ3RoPTAscz0wLGM9ITF9ZnVuY3Rpb24gbyhuKXt2YXIgdD0xLGU9bmV3IGEobikscj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtyZXR1cm4gZS5vYnNlcnZlKHIse2NoYXJhY3RlckRhdGE6ITB9KSxmdW5jdGlvbigpe3Q9LXQsci5kYXRhPXR9fWZ1bmN0aW9uIGkobil7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe2NsZWFyVGltZW91dChlKSxjbGVhckludGVydmFsKHIpLG4oKX12YXIgZT1zZXRUaW1lb3V0KHQsMCkscj1zZXRJbnRlcnZhbCh0LDUwKX19dC5leHBvcnRzPWU7dmFyIHUsZj1bXSxjPSExLHM9MCxsPTEwMjQsYT1uLk11dGF0aW9uT2JzZXJ2ZXJ8fG4uV2ViS2l0TXV0YXRpb25PYnNlcnZlcjt1PVwiZnVuY3Rpb25cIj09dHlwZW9mIGE/byhyKTppKHIpLGUucmVxdWVzdEZsdXNoPXUsZS5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXI9aX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se31dLDU6W2Z1bmN0aW9uKG4sdCxlKXtcImZ1bmN0aW9uXCIhPXR5cGVvZiBQcm9taXNlLnByb3RvdHlwZS5kb25lJiYoUHJvbWlzZS5wcm90b3R5cGUuZG9uZT1mdW5jdGlvbihuLHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg/dGhpcy50aGVuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzO2UudGhlbihudWxsLGZ1bmN0aW9uKG4pe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBufSwwKX0pfSl9LHt9XSw2OltmdW5jdGlvbihuLHQsZSl7bihcImFzYXBcIik7XCJ1bmRlZmluZWRcIj09dHlwZW9mIFByb21pc2UmJihQcm9taXNlPW4oXCIuL2xpYi9jb3JlLmpzXCIpLG4oXCIuL2xpYi9lczYtZXh0ZW5zaW9ucy5qc1wiKSksbihcIi4vcG9seWZpbGwtZG9uZS5qc1wiKX0se1wiLi9saWIvY29yZS5qc1wiOjEsXCIuL2xpYi9lczYtZXh0ZW5zaW9ucy5qc1wiOjIsXCIuL3BvbHlmaWxsLWRvbmUuanNcIjo1LGFzYXA6M31dfSx7fSxbNl0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGFcclxuXHJcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG5cclxuKi9cclxuKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cclxuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XHJcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XHJcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xyXG4gICAgdmFyIHNldEltbWVkaWF0ZTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3MpIHtcclxuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxyXG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxyXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcclxuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXHJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cclxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXHJcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xyXG4gICAgICAgICAgICBpZiAodGFzaykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xyXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XHJcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxyXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxyXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcclxuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxyXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxyXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcclxuXHJcbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcclxuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XHJcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcclxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cclxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXHJcbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XHJcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcclxuXHJcbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXHJcbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XHJcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxyXG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XHJcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xyXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcclxuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxyXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xyXG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxyXG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xyXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XHJcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xyXG59KGZ1bmN0aW9uKCkge3JldHVybiB0aGlzO30oKSkpO1xyXG4iLCIoZnVuY3Rpb24oKSB7XHJcbiAgICBmdW5jdGlvbiBWaWV3cG9ydCgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcclxuICAgICAgICB0aGlzLklPUzdfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XHJcbiAgICAgICAgdGhpcy5ERUZBVUxUX1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xyXG5cclxuICAgICAgICB0aGlzLmVuc3VyZVZpZXdwb3J0RWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSB7fTtcclxuICAgICAgICB0aGlzLnBsYXRmb3JtLm5hbWUgPSB0aGlzLmdldFBsYXRmb3JtTmFtZSgpO1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm0udmVyc2lvbiA9IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZW5zdXJlVmlld3BvcnRFbGVtZW50ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcclxuICAgICAgICBpZighdGhpcy52aWV3cG9ydEVsZW1lbnQpe1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQubmFtZSA9IFwidmlld3BvcnRcIjtcclxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLnZpZXdwb3J0RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm8tYWRqdXN0JykgPT0gXCJ0cnVlXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS5uYW1lID09ICdpb3MnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS52ZXJzaW9uID49IDcgJiYgaXNXZWJWaWV3KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLklPUzdfVklFV1BPUlQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLlBSRV9JT1M3X1ZJRVdQT1JUKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuREVGQVVMVF9WSUVXUE9SVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGlzV2ViVmlldygpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmdldFBsYXRmb3JtTmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImFuZHJvaWRcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kL2kpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImlvc1wiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdW5rbm93blxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybVZlcnNpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPUyAnKTtcclxuICAgICAgICByZXR1cm4gd2luZG93Lk51bWJlcih3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5zdWJzdHIoc3RhcnQgKyAzLCAzKS5yZXBsYWNlKCdfJywgJy4nKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHdpbmRvdy5WaWV3cG9ydCA9IFZpZXdwb3J0O1xyXG59KSgpO1xyXG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBPcGVuIFRlY2hub2xvZ2llcywgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuLy8gSmF2YVNjcmlwdCBEeW5hbWljIENvbnRlbnQgc2hpbSBmb3IgV2luZG93cyBTdG9yZSBhcHBzXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKHdpbmRvdy5NU0FwcCAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xyXG5cclxuICAgICAgICAvLyBTb21lIG5vZGVzIHdpbGwgaGF2ZSBhbiBcImF0dHJpYnV0ZXNcIiBwcm9wZXJ0eSB3aGljaCBzaGFkb3dzIHRoZSBOb2RlLnByb3RvdHlwZS5hdHRyaWJ1dGVzIHByb3BlcnR5XHJcbiAgICAgICAgLy8gIGFuZCBtZWFucyB3ZSBkb24ndCBhY3R1YWxseSBzZWUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIE5vZGUgKGludGVyZXN0aW5nbHkgdGhlIFZTIGRlYnVnIGNvbnNvbGVcclxuICAgICAgICAvLyAgYXBwZWFycyB0byBzdWZmZXIgZnJvbSB0aGUgc2FtZSBpc3N1ZSkuXHJcbiAgICAgICAgLy9cclxuICAgICAgICB2YXIgRWxlbWVudF9zZXRBdHRyaWJ1dGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCBcInNldEF0dHJpYnV0ZVwiKS52YWx1ZTtcclxuICAgICAgICB2YXIgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCBcInJlbW92ZUF0dHJpYnV0ZVwiKS52YWx1ZTtcclxuICAgICAgICB2YXIgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwiaW5zZXJ0QWRqYWNlbnRIVE1MXCIpO1xyXG4gICAgICAgIHZhciBOb2RlX2dldF9hdHRyaWJ1dGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVzXCIpLmdldDtcclxuICAgICAgICB2YXIgTm9kZV9nZXRfY2hpbGROb2RlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiY2hpbGROb2Rlc1wiKS5nZXQ7XHJcbiAgICAgICAgdmFyIGRldGVjdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfYXR0cmlidXRlcy5jYWxsKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIEVsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkTm9kZXMoZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfY2hpbGROb2Rlcy5jYWxsKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydEFkamFjZW50SFRNTChlbGVtZW50LCBwb3NpdGlvbiwgaHRtbCkge1xyXG4gICAgICAgICAgICBIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUxQcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUuY2FsbChlbGVtZW50LCBwb3NpdGlvbiwgaHRtbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpblVuc2FmZU1vZGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1Vuc2FmZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25EaXYuaW5uZXJIVE1MID0gXCI8dGVzdC8+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpc1Vuc2FmZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaXNVbnNhZmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjbGVhbnNlKGh0bWwsIHRhcmdldEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGNsZWFuZXIgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJjbGVhbmVyXCIpO1xyXG4gICAgICAgICAgICBlbXB0eShjbGVhbmVyLmRvY3VtZW50RWxlbWVudCk7XHJcbiAgICAgICAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGluc2VydEFkamFjZW50SFRNTChjbGVhbmVyLmRvY3VtZW50RWxlbWVudCwgXCJhZnRlcmJlZ2luXCIsIGh0bWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gY2xlYW5lci5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKTtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzY3JpcHRzLCBmdW5jdGlvbiAoc2NyaXB0KSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjcmlwdC50eXBlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2luZXJ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9lY21hc2NyaXB0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQveC1qYXZhc2NyaXB0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvanNjcmlwdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2xpdmVzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4xXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuMlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjNcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvaW5lcnQtXCIgKyBzY3JpcHQudHlwZS5zbGljZShcInRleHQvXCIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcImFwcGxpY2F0aW9uL2luZXJ0LVwiICsgc2NyaXB0LnR5cGUuc2xpY2UoXCJhcHBsaWNhdGlvbi9cIi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5zZUF0dHJpYnV0ZXMoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBhdHRyaWJ1dGVzIGNvbGxlY3Rpb24gaXMgbGl2ZSBpdCBpcyBzaW1wbGVyIHRvIHF1ZXVlIHVwIHRoZSByZW5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuYW1lWzBdID09PSBcIm9cIiB8fCBuYW1lWzBdID09PSBcIk9cIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lWzFdID09PSBcIm5cIiB8fCBuYW1lWzFdID09PSBcIk5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHsgbmFtZTogYXR0cmlidXRlLm5hbWUsIHZhbHVlOiBhdHRyaWJ1dGUudmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gZXZlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBcIngtXCIgKyBhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNoaWxkTm9kZXMoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnNlQXR0cmlidXRlcyhjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNsZWFuZWROb2RlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gJ0hUTUwnKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhbmVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuZXIuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IGNsZWFuZWROb2Rlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuaGVhZCkuY2hpbGROb2RlcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuZXIuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IGNsZWFuZWROb2Rlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuYm9keSkuY2hpbGROb2RlcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZE5vZGVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2xlYW5zZVByb3BlcnR5U2V0dGVyKHByb3BlcnR5LCBzZXR0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNldHRlciA9IHByb3BlcnR5RGVzY3JpcHRvci5zZXQ7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IHByb3BlcnR5RGVzY3JpcHRvci5nZXQsXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5XaW5KUyAmJiB3aW5kb3cuV2luSlMuX2V4ZWNVbnNhZmUgJiYgaW5VbnNhZmVNb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBjbGVhbnNlKHZhbHVlLCB0aGF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHByb3BlcnR5RGVzY3JpcHRvciwgdGhhdCwgbm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogcHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbnNlUHJvcGVydHlTZXR0ZXIoXCJpbm5lckhUTUxcIiwgZnVuY3Rpb24gKHByb3BlcnR5RGVzY3JpcHRvciwgdGFyZ2V0LCBlbGVtZW50cykge1xyXG4gICAgICAgICAgICBlbXB0eSh0YXJnZXQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjbGVhbnNlUHJvcGVydHlTZXR0ZXIoXCJvdXRlckhUTUxcIiwgZnVuY3Rpb24gKHByb3BlcnR5RGVzY3JpcHRvciwgdGFyZ2V0LCBlbGVtZW50cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBlbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG59KCkpOyIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB1bndyYXAgPSBzdHJpbmcgPT4gc3RyaW5nLnNsaWNlKDEsIC0xKTtcclxuY29uc3QgaXNPYmplY3RTdHJpbmcgPSBzdHJpbmcgPT4gc3RyaW5nLnN0YXJ0c1dpdGgoJ3snKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ30nKTtcclxuY29uc3QgaXNBcnJheVN0cmluZyA9IHN0cmluZyA9PiBzdHJpbmcuc3RhcnRzV2l0aCgnWycpICYmIHN0cmluZy5lbmRzV2l0aCgnXScpO1xyXG5jb25zdCBpc1F1b3RlZFN0cmluZyA9IHN0cmluZyA9PiAoc3RyaW5nLnN0YXJ0c1dpdGgoJ1xcJycpICYmIHN0cmluZy5lbmRzV2l0aCgnXFwnJykpIHx8IChzdHJpbmcuc3RhcnRzV2l0aCgnXCInKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1wiJykpO1xyXG5cclxuY29uc3QgZXJyb3IgPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gXFwnJyArIHRva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAnICsgKG9yaWdpbmFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggLSAxKSArICcgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XHJcbn07XHJcblxyXG5jb25zdCBwcm9jZXNzVG9rZW4gPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcclxuICBpZiAodG9rZW4gPT09ICd0cnVlJyB8fCB0b2tlbiA9PT0gJ2ZhbHNlJykge1xyXG4gICAgcmV0dXJuIHRva2VuID09PSAndHJ1ZSc7XHJcbiAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcclxuICAgIHJldHVybiB1bndyYXAodG9rZW4pO1xyXG4gIH0gZWxzZSBpZiAoIWlzTmFOKHRva2VuKSkge1xyXG4gICAgcmV0dXJuICsodG9rZW4pO1xyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3RTdHJpbmcodG9rZW4pKSB7XHJcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHRva2VuKSk7XHJcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHRva2VuKSkge1xyXG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHRva2VuKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBuZXh0VG9rZW4gPSAoc3RyaW5nKSA9PiB7XHJcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW1MZWZ0KCk7XHJcbiAgbGV0IGxpbWl0ID0gc3RyaW5nLmxlbmd0aDtcclxuXHJcbiAgaWYgKHN0cmluZ1swXSA9PT0gJzonIHx8IHN0cmluZ1swXSA9PT0gJywnKSB7XHJcblxyXG4gICAgbGltaXQgPSAxO1xyXG5cclxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XHJcblxyXG4gICAgY29uc3QgYyA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xyXG4gICAgbGV0IG5lc3RlZE9iamVjdCA9IDE7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMpIHtcclxuICAgICAgICBuZXN0ZWRPYmplY3QrKztcclxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYyArIDIpIHtcclxuICAgICAgICBuZXN0ZWRPYmplY3QtLTtcclxuICAgICAgICBpZiAobmVzdGVkT2JqZWN0ID09PSAwKSB7XHJcbiAgICAgICAgICBsaW1pdCA9IGkgKyAxO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAnXFwnJyB8fCBzdHJpbmdbMF0gPT09ICdcXFwiJykge1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChzdHJpbmdbaV0gPT09IHN0cmluZ1swXSkge1xyXG4gICAgICAgIGxpbWl0ID0gaSArIDE7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoWycgJywgJywnLCAnOiddLmluZGV4T2Yoc3RyaW5nW2ldKSAhPT0gLTEpIHtcclxuICAgICAgICBsaW1pdCA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxpbWl0KTtcclxufTtcclxuXHJcbmNvbnN0IHBhcnNlT2JqZWN0ID0gKHN0cmluZykgPT4ge1xyXG4gIGNvbnN0IGlzVmFsaWRLZXkgPSBrZXkgPT4gL15bQS1aX1xcJF1bQS1aMC05X1xcJF0qJC9pLnRlc3Qoa2V5KTtcclxuXHJcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcclxuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcclxuICBjb25zdCBvYmplY3QgPSB7fTtcclxuICBsZXQgcmVhZGluZ0tleSA9IHRydWUsIGtleSwgcHJldmlvdXNUb2tlbiwgdG9rZW47XHJcblxyXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XHJcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xyXG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcclxuXHJcbiAgICBpZiAoKHRva2VuID09PSAnOicgJiYgKCFyZWFkaW5nS2V5IHx8ICFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykpXHJcbiAgICAgICB8fCAodG9rZW4gPT09ICcsJyAmJiByZWFkaW5nS2V5KVxyXG4gICAgICAgfHwgKHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuICE9PSAnLCcgJiYgcHJldmlvdXNUb2tlbiAhPT0gJzonKSkpIHtcclxuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xyXG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJzonICYmIHJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xyXG4gICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xyXG4gICAgICAgIGtleSA9IHByZXZpb3VzVG9rZW47XHJcbiAgICAgICAgcmVhZGluZ0tleSA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgdG9rZW4gXFwnJyArIHByZXZpb3VzVG9rZW4gKyAnXFwnIGF0IHBvc2l0aW9uIDAgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XHJcbiAgICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHByZXZpb3VzVG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xyXG4gICAgICByZWFkaW5nS2V5ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4odG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iamVjdDtcclxufTtcclxuXHJcbmNvbnN0IHBhcnNlQXJyYXkgPSAoc3RyaW5nKSA9PiB7XHJcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcclxuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcclxuICBjb25zdCBhcnJheSA9IFtdO1xyXG4gIGxldCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcclxuXHJcbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcclxuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcclxuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XHJcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltTGVmdCgpO1xyXG5cclxuICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XHJcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcclxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJykge1xyXG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodG9rZW4pIHtcclxuICAgIGlmICh0b2tlbiAhPT0gJywnKSB7XHJcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5jb25zdCBwYXJzZSA9IChzdHJpbmcpID0+IHtcclxuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xyXG5cclxuICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xyXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHVud3JhcChzdHJpbmcpKTtcclxuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcoc3RyaW5nKSkge1xyXG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHN0cmluZyBtdXN0IGJlIG9iamVjdCBvciBhcnJheSBsaWtlOiAnICsgc3RyaW5nKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBhbmltYXRpb25PcHRpb25zUGFyc2UgZnJvbSAnLi9hbmltYXRpb24tb3B0aW9ucy1wYXJzZXInO1xyXG5cclxuY29uc3QgdXRpbCA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cclxuICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAqL1xyXG51dGlsLnByZXBhcmVRdWVyeSA9IChxdWVyeSkgPT4ge1xyXG4gIHJldHVybiBxdWVyeSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcXVlcnkgOiAoZWxlbWVudCkgPT4gdXRpbC5tYXRjaChlbGVtZW50LCBxdWVyeSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG51dGlsLm1hdGNoID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XHJcbiAgaWYgKHF1ZXJ5WzBdID09PSAnLicpIHtcclxuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhxdWVyeS5zbGljZSgxKSk7XHJcbiAgfVxyXG4gIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHF1ZXJ5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XHJcbiAqL1xyXG51dGlsLmZpbmRDaGlsZCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xyXG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKG1hdGNoKG5vZGUpKSB7XHJcbiAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxyXG4gKi9cclxudXRpbC5maW5kUGFyZW50ID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XHJcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XHJcblxyXG4gIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgZm9yICg7Oykge1xyXG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBkb2N1bWVudCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChtYXRjaChwYXJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG51dGlsLmlzQXR0YWNoZWQgPSAoZWxlbWVudCkgPT4ge1xyXG4gIHdoaWxlIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbnV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQgPSAoZWxlbWVudCkgPT4ge1xyXG4gIHdoaWxlIChlbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5tYXRjaCgvKG9ucy1uYXZpZ2F0b3J8b25zLXRhYmJhcnxvbnMtc2xpZGluZy1tZW51fG9ucy1zcGxpdC12aWV3KS8pKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXHJcbiAqL1xyXG51dGlsLnByb3BhZ2F0ZUFjdGlvbiA9IChlbGVtZW50LCBhY3Rpb24pID0+IHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XHJcbiAgICBpZiAoY2hpbGRbYWN0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgIGNoaWxkW2FjdGlvbl0oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKGNoaWxkLCBhY3Rpb24pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gdGFnIGFuZCBjbGFzcyBvbmx5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9XHJcbiAqL1xyXG51dGlsLmNyZWF0ZSA9IChzZWxlY3RvciA9ICcnLCBzdHlsZSA9IHt9KSA9PiB7XHJcbiAgY29uc3QgY2xhc3NMaXN0ID0gc2VsZWN0b3Iuc3BsaXQoJy4nKTtcclxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjbGFzc0xpc3Quc2hpZnQoKSB8fCAnZGl2Jyk7XHJcblxyXG4gIGlmIChjbGFzc0xpc3QubGVuZ3RoKSB7XHJcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XHJcbiAgfVxyXG5cclxuICB1dGlsLmV4dGVuZChlbGVtZW50LnN0eWxlLCBzdHlsZSk7XHJcblxyXG4gIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqL1xyXG51dGlsLmNyZWF0ZUVsZW1lbnQgPSAoaHRtbCkgPT4ge1xyXG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICB3cmFwcGVyLmlubmVySFRNTCA9IGh0bWw7XHJcblxyXG4gIGlmICh3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignXCJodG1sXCIgbXVzdCBiZSBvbmUgd3JhcHBlciBlbGVtZW50LicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHdyYXBwZXIuY2hpbGRyZW5bMF07XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcclxuICogQHJldHVybiB7SFRNTEZyYWdtZW50fVxyXG4gKi9cclxudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XHJcbiAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIHdyYXBwZXIuaW5uZXJIVE1MID0gaHRtbDtcclxuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcbiAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmcmFnbWVudDtcclxufTtcclxuXHJcbi8qXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0LlxyXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cclxuICovXHJcbnV0aWwuZXh0ZW5kID0gKGRzdCwgLi4uYXJncykgPT4ge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGFyZ3NbaV0pIHtcclxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbaV0pO1xyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xyXG4gICAgICAgIGRzdFtrZXldID0gYXJnc1tpXVtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZHN0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG51dGlsLmFycmF5RnJvbSA9IChhcnJheUxpa2UpID0+IHtcclxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5TGlrZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcclxuICogQHBhcmFtIHtPYmplY3R9IFtmYWlsU2FmZV1cclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxudXRpbC5wYXJzZUpTT05PYmplY3RTYWZlbHkgPSAoanNvblN0cmluZywgZmFpbFNhZmUgPSB7fSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKCcnICsganNvblN0cmluZyk7XHJcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFpbFNhZmU7XHJcbiAgfVxyXG4gIHJldHVybiBmYWlsU2FmZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHBhdGggc3VjaCBhcyAnbXlBcHAuY29udHJvbGxlcnMuZGF0YS5sb2FkRGF0YSdcclxuICogQHJldHVybiB7QW55fSAtIHdoYXRldmVyIGlzIGxvY2F0ZWQgYXQgdGhhdCBwYXRoXHJcbiAqL1xyXG51dGlsLmZpbmRGcm9tUGF0aCA9IChwYXRoKSA9PiB7XHJcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcclxuICB2YXIgZWwgPSB3aW5kb3csIGtleTtcclxuICB3aGlsZSAoa2V5ID0gcGF0aC5zaGlmdCgpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICAgIGVsID0gZWxba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIGVsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsXVxyXG4gKiBAcmV0dXJuIHtDdXN0b21FdmVudH1cclxuICovXHJcbnV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgZGV0YWlsID0ge30pID0+IHtcclxuXHJcbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XHJcbiAgICBidWJibGVzOiB0cnVlLFxyXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcclxuICAgIGRldGFpbDogZGV0YWlsXHJcbiAgfSk7XHJcblxyXG4gIE9iamVjdC5rZXlzKGRldGFpbCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgZXZlbnRba2V5XSA9IGRldGFpbFtrZXldO1xyXG4gIH0pO1xyXG5cclxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcblxyXG4gIHJldHVybiBldmVudDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG51dGlsLmhhc01vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLykuc29tZShlID0+IGUgPT09IG1vZGlmaWVyTmFtZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcclxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBhZGRlZCBvciBub3QuXHJcbiAqL1xyXG51dGlsLmFkZE1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XHJcbiAgaWYgKHV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBtb2RpZmllck5hbWUgPSBtb2RpZmllck5hbWUudHJpbSgpO1xyXG4gIGNvbnN0IG1vZGlmaWVyQXR0cmlidXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcclxuICB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIChtb2RpZmllckF0dHJpYnV0ZSArICcgJyArIG1vZGlmaWVyTmFtZSkudHJpbSgpKTtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cclxuICovXHJcbnV0aWwucmVtb3ZlTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUpID0+IHtcclxuICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1vZGlmaWVycyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykuc3BsaXQoL1xccysvKTtcclxuXHJcbiAgY29uc3QgbmV3TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbSAhPT0gbW9kaWZpZXJOYW1lKTtcclxuICB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVycy5qb2luKCcgJykpO1xyXG5cclxuICByZXR1cm4gbW9kaWZpZXJzLmxlbmd0aCAhPT0gbmV3TW9kaWZpZXJzLmxlbmd0aDtcclxufTtcclxuXHJcbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcclxuICBpZiAoIWVsLl9wYXJlbnRVcGRhdGVkICYmIGVsLnBhcmVudEVsZW1lbnQpIHtcclxuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbC5wYXJlbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xyXG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgIH1cclxuICAgIGVsLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcclxuICB9XHJcbn07XHJcblxyXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCBlbmFibGUpID0+IHtcclxuICBpZiAoZW5hYmxlKSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gIH1cclxufTtcclxuXHJcbnV0aWwuYmluZExpc3RlbmVycyA9IChlbGVtZW50LCBsaXN0ZW5lck5hbWVzKSA9PiB7XHJcbiAgbGlzdGVuZXJOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgY29uc3QgYm91bmROYW1lID0gbmFtZS5yZXBsYWNlKC9eX1thLXpdLywgJ19ib3VuZCcgKyBuYW1lWzFdLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgZWxlbWVudFtib3VuZE5hbWVdID0gZWxlbWVudFtib3VuZE5hbWVdIHx8IGVsZW1lbnRbbmFtZV0uYmluZChlbGVtZW50KTtcclxuICB9KTtcclxufTtcclxuXHJcbnV0aWwuZWFjaCA9IChvYmosIGYpID0+IE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4gZihrZXksIG9ialtrZXldKSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XHJcbiAqL1xyXG51dGlsLnVwZGF0ZVJpcHBsZSA9ICh0YXJnZXQpID0+IHtcclxuICBjb25zdCByaXBwbGVFbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGFyZ2V0LCAnb25zLXJpcHBsZScpO1xyXG5cclxuICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcclxuICAgIGlmICghcmlwcGxlRWxlbWVudCkge1xyXG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1yaXBwbGUnKSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAocmlwcGxlRWxlbWVudCkge1xyXG4gICAgcmlwcGxlRWxlbWVudC5yZW1vdmUoKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9XHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICovXHJcbnV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICovXHJcbnV0aWwuaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcclxuICAgIGlzRmluaXRlKHZhbHVlKSAmJlxyXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcclxuIiwiLypcclxuICogR2VzdHVyZSBkZXRlY3RvciBsaWJyYXJ5IHRoYXQgZm9ya2VkIGZyb20gZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnQsIFV0aWxzLCBEZXRlY3Rpb24sIFBvaW50ZXJFdmVudDtcclxuXHJcbi8qKlxyXG4gKiBAb2JqZWN0IG9ucy5HZXN0dXJlRGV0ZWN0b3JcclxuICogQGNhdGVnb3J5IGdlc3R1cmVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVV0aWxpdHkgY2xhc3MgZm9yIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXHJcbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+OCr+ODqeOCueOBp+OBmeOAglsvamFdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgY29uc3RydWN0b3JcclxuICogQHNpZ25hdHVyZSBjb25zdHJ1Y3RvcihlbGVtZW50Wywgb3B0aW9uc10pXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgW2VuXUNyZWF0ZSBhIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UuWy9lbl1cclxuICogIFtqYV1HZXN0dXJlRGV0ZWN0b3Ljga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cclxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KLRE9N6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxyXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAcmV0dXJuIHtvbnMuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxyXG4gKi9cclxudmFyIEdlc3R1cmVEZXRlY3RvciA9IGZ1bmN0aW9uIEdlc3R1cmVEZXRlY3RvcihlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucyB8fCB7fSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXHJcbiAqIG1vcmUgc2V0dGluZ3MgYXJlIGRlZmluZWQgcGVyIGdlc3R1cmUgYXQgYC9nZXN0dXJlc2AuIEVhY2ggZ2VzdHVyZSBjYW4gYmUgZGlzYWJsZWQvZW5hYmxlZFxyXG4gKiBieSBzZXR0aW5nIGl0J3MgbmFtZSAobGlrZSBgc3dpcGVgKSB0byBmYWxzZS5cclxuICogWW91IGNhbiBzZXQgdGhlIGRlZmF1bHRzIGZvciBhbGwgaW5zdGFuY2VzIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZyBhbiBpbnN0YW5jZS5cclxuICogQGV4YW1wbGVcclxuICogYGBgYFxyXG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmRyYWcgPSBmYWxzZTtcclxuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvbiA9ICdwYW4teSc7XHJcbiAqICBkZWxldGUgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3Q7XHJcbiAqIGBgYGBcclxuICogQHByb3BlcnR5IGRlZmF1bHRzXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5HZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMgPSB7XHJcbiAgYmVoYXZpb3I6IHtcclxuICAgIC8vIHVzZXJTZWxlY3Q6ICdub25lJywgLy8gQWxzbyBkaXNhYmxlcyBzZWxlY3Rpb24gaW4gYGlucHV0YCBjaGlsZHJlblxyXG4gICAgdG91Y2hBY3Rpb246ICdwYW4teScsXHJcbiAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcclxuICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXHJcbiAgICB1c2VyRHJhZzogJ25vbmUnLFxyXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXN0dXJlRGV0ZWN0b3IgZG9jdW1lbnQgd2hlcmUgdGhlIGJhc2UgZXZlbnRzIGFyZSBhZGRlZCBhdFxyXG4gKiBAcHJvcGVydHkgRE9DVU1FTlRcclxuICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gKiBAZGVmYXVsdCB3aW5kb3cuZG9jdW1lbnRcclxuICovXHJcbkdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCA9IGRvY3VtZW50O1xyXG5cclxuLyoqXHJcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xyXG4gKiBAcHJvcGVydHkgSEFTX1BPSU5URVJFVkVOVFNcclxuICogQHR5cGUge0Jvb2xlYW59XHJcbiAqL1xyXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMgPSBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XHJcblxyXG4vKipcclxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHRvdWNoIGV2ZW50c1xyXG4gKiBAcHJvcGVydHkgSEFTX1RPVUNIRVZFTlRTXHJcbiAqIEB0eXBlIHtCb29sZWFufVxyXG4gKi9cclxuR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xyXG5cclxuLyoqXHJcbiAqIGRldGVjdCBtb2JpbGUgYnJvd3NlcnNcclxuICogQHByb3BlcnR5IElTX01PQklMRVxyXG4gKiBAdHlwZSB7Qm9vbGVhbn1cclxuICovXHJcbkdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuLyoqXHJcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXHJcbiAqIEBwcm9wZXJ0eSBOT19NT1VTRUVWRU5UU1xyXG4gKiBAdHlwZSB7Qm9vbGVhbn1cclxuICovXHJcbkdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUyA9IChHZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTICYmIEdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUpIHx8IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUztcclxuXHJcbi8qKlxyXG4gKiBpbnRlcnZhbCBpbiB3aGljaCBHZXN0dXJlRGV0ZWN0b3IgcmVjYWxjdWxhdGVzIGN1cnJlbnQgdmVsb2NpdHkvZGlyZWN0aW9uL2FuZ2xlIGluIG1zXHJcbiAqIEBwcm9wZXJ0eSBDQUxDVUxBVEVfSU5URVJWQUxcclxuICogQHR5cGUge051bWJlcn1cclxuICogQGRlZmF1bHQgMjVcclxuICovXHJcbkdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcclxuXHJcbi8qKlxyXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXHJcbiAqIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIERPTSBldmVudCBuYW1lcyBwZXIgdHlwZSAoYEVWRU5UX1NUQVJUYCwgYEVWRU5UX01PVkVgLCBgRVZFTlRfRU5EYClcclxuICogQHByb3BlcnR5IEVWRU5UX1RZUEVTXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB3cml0ZU9uY2VcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbnZhciBFVkVOVF9UWVBFUyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIGRpcmVjdGlvbiBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xyXG4gKiBAcHJvcGVydHkgRElSRUNUSU9OX0RPV058TEVGVHxVUHxSSUdIVFxyXG4gKiBAZmluYWxcclxuICogQHR5cGUge1N0cmluZ31cclxuICogQGRlZmF1bHQgJ2Rvd24nICdsZWZ0JyAndXAnICdyaWdodCdcclxuICovXHJcbnZhciBESVJFQ1RJT05fRE9XTiA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fRE9XTiA9ICdkb3duJztcclxudmFyIERJUkVDVElPTl9MRUZUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xyXG52YXIgRElSRUNUSU9OX1VQID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9VUCA9ICd1cCc7XHJcbnZhciBESVJFQ1RJT05fUklHSFQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcclxuXHJcbi8qKlxyXG4gKiBwb2ludGVydHlwZSBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xyXG4gKiBAcHJvcGVydHkgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5cclxuICogQGZpbmFsXHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqIEBkZWZhdWx0ICdtb3VzZScgJ3RvdWNoJyAncGVuJ1xyXG4gKi9cclxudmFyIFBPSU5URVJfTU9VU0UgPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9NT1VTRSA9ICdtb3VzZSc7XHJcbnZhciBQT0lOVEVSX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfVE9VQ0ggPSAndG91Y2gnO1xyXG52YXIgUE9JTlRFUl9QRU4gPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9QRU4gPSAncGVuJztcclxuXHJcbi8qKlxyXG4gKiBldmVudHR5cGVzXHJcbiAqIEBwcm9wZXJ0eSBFVkVOVF9TVEFSVHxNT1ZFfEVORHxSRUxFQVNFfFRPVUNIXHJcbiAqIEBmaW5hbFxyXG4gKiBAdHlwZSB7U3RyaW5nfVxyXG4gKiBAZGVmYXVsdCAnc3RhcnQnICdjaGFuZ2UnICdtb3ZlJyAnZW5kJyAncmVsZWFzZScgJ3RvdWNoJ1xyXG4gKi9cclxudmFyIEVWRU5UX1NUQVJUID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcclxudmFyIEVWRU5UX01PVkUgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfTU9WRSA9ICdtb3ZlJztcclxudmFyIEVWRU5UX0VORCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9FTkQgPSAnZW5kJztcclxudmFyIEVWRU5UX1JFTEVBU0UgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcclxudmFyIEVWRU5UX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1RPVUNIID0gJ3RvdWNoJztcclxuXHJcbi8qKlxyXG4gKiBpZiB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2V0Li4uXHJcbiAqIEBwcm9wZXJ0eSBSRUFEWVxyXG4gKiBAd3JpdGVPbmNlXHJcbiAqIEB0eXBlIHtCb29sZWFufVxyXG4gKiBAZGVmYXVsdCBmYWxzZVxyXG4gKi9cclxuR2VzdHVyZURldGVjdG9yLlJFQURZID0gZmFsc2U7XHJcblxyXG4vKipcclxuICogcGx1Z2lucyBuYW1lc3BhY2VcclxuICogQHByb3BlcnR5IHBsdWdpbnNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbkdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zID0gR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgfHwge307XHJcblxyXG4vKipcclxuICogZ2VzdHVyZXMgbmFtZXNwYWNlXHJcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXHJcbiAqIEBwcm9wZXJ0eSBnZXN0dXJlc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzID0gR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIHx8IHt9O1xyXG5cclxuLyoqXHJcbiAqIHNldHVwIGV2ZW50cyB0byBkZXRlY3QgZ2VzdHVyZXMgb24gdGhlIGRvY3VtZW50XHJcbiAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYW4gbmV3IGluc3RhbmNlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICBpZihHZXN0dXJlRGV0ZWN0b3IuUkVBRFkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIGZpbmQgd2hhdCBldmVudHR5cGVzIHdlIGFkZCBsaXN0ZW5lcnMgdG9cclxuICBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzKCk7XHJcblxyXG4gIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXHJcbiAgVXRpbHMuZWFjaChHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcclxuICAgIERldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcclxuICB9KTtcclxuXHJcbiAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcclxuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfTU9WRSwgRGV0ZWN0aW9uLmRldGVjdCk7XHJcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCk7XHJcblxyXG4gIC8vIEdlc3R1cmVEZXRlY3RvciBpcyByZWFkeS4uLiFcclxuICBHZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcclxuICpcclxuICogQGNsYXNzIFV0aWxzXHJcbiAqIEBzdGF0aWNcclxuICovXHJcblV0aWxzID0gR2VzdHVyZURldGVjdG9yLnV0aWxzID0ge1xyXG4gIC8qKlxyXG4gICAqIGV4dGVuZCBtZXRob2QsIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgY2xvbmluZyB3aGVuIGBkZXN0YCBpcyBhbiBlbXB0eSBvYmplY3QuXHJcbiAgICogY2hhbmdlcyB0aGUgZGVzdCBvYmplY3RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV0gIGRvIGEgbWVyZ2VcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlc3RcclxuICAgKi9cclxuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XHJcbiAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZGVzdFtrZXldID09PSB1bmRlZmluZWQgfHwgIW1lcmdlKSkge1xyXG4gICAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBzaW1wbGUgYWRkRXZlbnRMaXN0ZW5lciB3cmFwcGVyXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gICAqL1xyXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIHNpbXBsZSByZW1vdmVFdmVudExpc3RlbmVyIHdyYXBwZXJcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAgICovXHJcbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xyXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBmb3JFYWNoIG92ZXIgYXJyYXlzIGFuZCBvYmplY3RzXHJcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXHJcbiAgICogQHBhcmFtIHthbnl9IGl0ZXJhdG9yLml0ZW1cclxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0b3IuaW5kZXhcclxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gaXRlcmF0b3Iub2JqIHRoZSBzb3VyY2Ugb2JqZWN0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYCBpbiB0aGUgaXRlcmF0b3JcclxuICAgKi9cclxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICAgIHZhciBpLCBsZW47XHJcblxyXG4gICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXHJcbiAgICBpZignZm9yRWFjaCcgaW4gb2JqKSB7XHJcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgICAgLy8gYXJyYXlzXHJcbiAgICB9IGVsc2UgaWYob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIG9iamVjdHNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvcihpIGluIG9iaikge1xyXG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxyXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogZmluZCBpZiBhIHN0cmluZyBjb250YWlucyB0aGUgc3RyaW5nIHVzaW5nIGluZGV4T2ZcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxyXG4gICAqL1xyXG4gIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcclxuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKSA+IC0xO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxyXG4gICAqL1xyXG4gIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kKSB7XHJcbiAgICBpZihzcmMuaW5kZXhPZikge1xyXG4gICAgICB2YXIgaW5kZXggPSBzcmMuaW5kZXhPZihmaW5kKTtcclxuICAgICAgcmV0dXJuIChpbmRleCA9PT0gLTEpID8gZmFsc2UgOiBpbmRleDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHNyYy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmKHNyY1tpXSA9PT0gZmluZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0IChgYXJndW1lbnRzYCwgYHRvdWNobGlzdGApIHRvIGFuIGFycmF5XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAqL1xyXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXHJcbiAgICovXHJcbiAgaGFzUGFyZW50OiBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XHJcbiAgICB3aGlsZShub2RlKSB7XHJcbiAgICAgIGlmKG5vZGUgPT0gcGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcclxuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHBhZ2VYYCwgYHBhZ2VZYCwgYGNsaWVudFhgIGFuZCBgY2xpZW50WWAgcHJvcGVydGllc1xyXG4gICAqL1xyXG4gIGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKHRvdWNoZXMpIHtcclxuICAgIHZhciBwYWdlWCA9IFtdLFxyXG4gICAgICAgIHBhZ2VZID0gW10sXHJcbiAgICAgICAgY2xpZW50WCA9IFtdLFxyXG4gICAgICAgIGNsaWVudFkgPSBbXSxcclxuICAgICAgICBtaW4gPSBNYXRoLm1pbixcclxuICAgICAgICBtYXggPSBNYXRoLm1heDtcclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxyXG4gICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcclxuICAgICAgICBwYWdlWTogdG91Y2hlc1swXS5wYWdlWSxcclxuICAgICAgICBjbGllbnRYOiB0b3VjaGVzWzBdLmNsaWVudFgsXHJcbiAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgVXRpbHMuZWFjaCh0b3VjaGVzLCBmdW5jdGlvbih0b3VjaCkge1xyXG4gICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcclxuICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XHJcbiAgICAgIGNsaWVudFgucHVzaCh0b3VjaC5jbGllbnRYKTtcclxuICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxyXG4gICAgICBwYWdlWTogKG1pbi5hcHBseShNYXRoLCBwYWdlWSkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVkpKSAvIDIsXHJcbiAgICAgIGNsaWVudFg6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WCkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WCkpIC8gMixcclxuICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXHJcbiAgICovXHJcbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IE1hdGguYWJzKGRlbHRhWCAvIGRlbHRhVGltZSkgfHwgMCxcclxuICAgICAgeTogTWF0aC5hYnMoZGVsdGFZIC8gZGVsdGFUaW1lKSB8fCAwXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcclxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcclxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICovXHJcbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XHJcbiAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXHJcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGRvIGEgc21hbGwgY29tcGFyaXNvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxyXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxyXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9MRUZUfFJJR0hUfFVQfERPV05gXHJcbiAgICovXHJcbiAgZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBnZXREaXJlY3Rpb24odG91Y2gxLCB0b3VjaDIpIHtcclxuICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXHJcbiAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xyXG5cclxuICAgIGlmKHggPj0geSkge1xyXG4gICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcclxuICAgIH1cclxuICAgIHJldHVybiB0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlc1xyXG4gICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXHJcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxyXG4gICAqL1xyXG4gIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xyXG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxyXG4gICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcclxuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcclxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXHJcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXHJcbiAgICovXHJcbiAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcclxuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cclxuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSkgLyB0aGlzLmdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcclxuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xyXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cclxuICAgKi9cclxuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgLy8gbmVlZCB0d28gZmluZ2Vyc1xyXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fVVB8RE9XTmBcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxyXG4gICAqL1xyXG4gIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCB8fCBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV047XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIHNldFByZWZpeGVkQ3NzOiBmdW5jdGlvbiBzZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKSB7XHJcbiAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcclxuICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcclxuXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHAgPSBwcm9wO1xyXG4gICAgICAvLyBwcmVmaXhlc1xyXG4gICAgICBpZihwcmVmaXhlc1tpXSkge1xyXG4gICAgICAgIHAgPSBwcmVmaXhlc1tpXSArIHAuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHAuc2xpY2UoMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHRlc3QgdGhlIHN0eWxlXHJcbiAgICAgIGlmKHAgaW4gZWxlbWVudC5zdHlsZSkge1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcF0gPSAodG9nZ2xlID09PSBudWxsIHx8IHRvZ2dsZSkgJiYgdmFsdWUgfHwgJyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXHJcbiAgICogYHVzZXJTZWxlY3Q9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25zZWxlY3RzdGFydGAgdG8gZmFsc2VcclxuICAgKiBgdXNlckRyYWc9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25kcmFnc3RhcnRgIHRvIGZhbHNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0h0bWxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXHJcbiAgICovXHJcbiAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcclxuICAgIGlmKCFwcm9wcyB8fCAhZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBjc3MgcHJvcGVydGllc1xyXG4gICAgVXRpbHMuZWFjaChwcm9wcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcclxuICAgICAgVXRpbHMuc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgZmFsc2VGbiA9IHRvZ2dsZSAmJiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhbHNvIHRoZSBkaXNhYmxlIG9uc2VsZWN0c3RhcnRcclxuICAgIGlmKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XHJcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgICB9XHJcbiAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxyXG4gICAgaWYocHJvcHMudXNlckRyYWcgPT0gJ25vbmUnKSB7XHJcbiAgICAgIGVsZW1lbnQub25kcmFnc3RhcnQgPSBmYWxzZUZuO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcclxuICAgKiBzbyBwcmV2ZW50X2RlZmF1bHQgYmVjb21lcyBwcmV2ZW50RGVmYXVsdFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxyXG4gICAqL1xyXG4gIHRvQ2FtZWxDYXNlOiBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW18tXShbYS16XSkvZywgZnVuY3Rpb24ocykge1xyXG4gICAgICByZXR1cm4gc1sxXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxyXG4gKi9cclxuLyoqXHJcbiAqIEBjbGFzcyBFdmVudFxyXG4gKiBAc3RhdGljXHJcbiAqL1xyXG5FdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ldmVudCA9IHtcclxuICAvKipcclxuICAgKiB3aGVuIHRvdWNoIGV2ZW50cyBoYXZlIGJlZW4gZmlyZWQsIHRoaXMgaXMgdHJ1ZVxyXG4gICAqIHRoaXMgaXMgdXNlZCB0byBzdG9wIG1vdXNlIGV2ZW50c1xyXG4gICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBwcmV2ZW50TW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBpZiBFVkVOVF9TVEFSVCBoYXMgYmVlbiBmaXJlZFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydGVkXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBzdGFydGVkOiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcclxuICAgKiBAcHJvcGVydHkgc2hvdWxkX2RldGVjdFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogc2ltcGxlIGV2ZW50IGJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxyXG4gICAqL1xyXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XHJcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XHJcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIFV0aWxzLm9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtob29rXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcclxuICAgKi9cclxuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XHJcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XHJcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogdGhlIGNvcmUgdG91Y2ggZXZlbnQgaGFuZGxlci5cclxuICAgKiB0aGlzIGZpbmRzIG91dCBpZiB3ZSBzaG91bGQgdG8gZGV0ZWN0IGdlc3R1cmVzXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gICAqIEByZXR1cm4gb25Ub3VjaEhhbmRsZXIge0Z1bmN0aW9ufSB0aGUgY29yZSBldmVudCBoYW5kbGVyXHJcbiAgICovXHJcbiAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xyXG4gICAgICB2YXIgc3JjVHlwZSA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgIGlzUG9pbnRlciA9IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyxcclxuICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcclxuICAgICAgICAgIHRyaWdnZXJUeXBlO1xyXG5cclxuICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXHJcbiAgICAgIC8vIHdlIHdhbnQgdG8gZG8gbm90aGluZy4gc2ltcGx5IGJyZWFrIG91dCBvZiB0aGUgZXZlbnQuXHJcbiAgICAgIGlmKGlzTW91c2UgJiYgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMpIHtcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIG1vdXNlYnV0dG9uIG11c3QgYmUgZG93blxyXG4gICAgICB9IGVsc2UgaWYoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XHJcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcclxuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XHJcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSAoZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KSk7XHJcbiAgICAgICAgLy8ganVzdCBhIHZhbGlkIHN0YXJ0IGV2ZW50LCBidXQgbm8gbW91c2VcclxuICAgICAgfSBlbHNlIGlmKCFpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xyXG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlciBldmVudCBiZWZvcmUgZW50ZXJpbmcgdGhlIGRldGVjdGlvblxyXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xyXG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xyXG4gICAgICBpZihzZWxmLnNob3VsZERldGVjdCkge1xyXG4gICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXHJcbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxyXG4gICAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcclxuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xyXG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgUG9pbnRlckV2ZW50LnJlc2V0KCk7XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyZXZlbnQgb2JqZWN0IGFmdGVyIHRoZSBkZXRlY3Rpb25cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcclxuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm9uKGVsZW1lbnQsIEVWRU5UX1RZUEVTW2V2ZW50VHlwZV0sIG9uVG91Y2hIYW5kbGVyKTtcclxuICAgIHJldHVybiBvblRvdWNoSGFuZGxlcjtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiB0aGUgY29yZSBkZXRlY3Rpb24gbWV0aG9kXHJcbiAgICogdGhpcyBmaW5kcyBvdXQgd2hhdCBHZXN0dXJlRGV0ZWN0b3ItdG91Y2gtZXZlbnRzIHRvIHRyaWdnZXJcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcclxuICAgKi9cclxuICBkb0RldGVjdDogZnVuY3Rpb24gZG9EZXRlY3QoZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcikge1xyXG4gICAgdmFyIHRvdWNoTGlzdCA9IHRoaXMuZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpO1xyXG4gICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XHJcbiAgICB2YXIgdHJpZ2dlclR5cGUgPSBldmVudFR5cGU7XHJcbiAgICB2YXIgdHJpZ2dlckNoYW5nZSA9IHRvdWNoTGlzdC50cmlnZ2VyOyAvLyB1c2VkIGJ5IGZha2VNdWx0aXRvdWNoIHBsdWdpblxyXG4gICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XHJcblxyXG4gICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXHJcbiAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcclxuICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1RPVUNIO1xyXG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XHJcbiAgICB9IGVsc2UgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xyXG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfUkVMRUFTRTtcclxuXHJcbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdG91Y2hlcyBoYXZlIGJlZW4gcmVtb3ZlZFxyXG4gICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtICgoZXYuY2hhbmdlZFRvdWNoZXMpID8gZXYuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDogMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWZ0ZXIgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgb24gdGhlIHNjcmVlbixcclxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXHJcbiAgICAvLyBidXQgb25seSBhZnRlciBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgdGhlIGZpcnN0IHRpbWUgd2UgYWN0dWFsbHkgd2FudCBhIFNUQVJUXHJcbiAgICBpZihjaGFuZ2VkTGVuZ3RoID4gMCAmJiB0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB3ZSBrZWVwIHRyYWNrIG9mIHRoaXMsIHNlZSBhYm92ZVxyXG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cclxuICAgIHZhciBldkRhdGEgPSB0aGlzLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgdHJpZ2dlclR5cGUsIHRvdWNoTGlzdCwgZXYpO1xyXG5cclxuICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXHJcbiAgICAvLyBidXQgdGhlIEVORCBldmVudCBzaG91bGQgYmUgYXQgbGFzdFxyXG4gICAgaWYoZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xyXG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcclxuICAgIGlmKHRyaWdnZXJDaGFuZ2UpIHtcclxuICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xyXG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcclxuXHJcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XHJcblxyXG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlclR5cGU7XHJcbiAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0cmlnZ2VyIHRoZSBFTkQgZXZlbnRcclxuICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xyXG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xyXG5cclxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxyXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcclxuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyaWdnZXJUeXBlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxyXG4gICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxyXG4gICAqIHRoZSBgb25Ub3VjaGAgbWV0aG9kIGlzIGJpbmQgdG8gdGhlc2UgcHJvcGVydGllcy5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xyXG4gICAqL1xyXG4gIGRldGVybWluZUV2ZW50VHlwZXM6IGZ1bmN0aW9uIGRldGVybWluZUV2ZW50VHlwZXMoKSB7XHJcbiAgICB2YXIgdHlwZXM7XHJcbiAgICBpZihHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMpIHtcclxuICAgICAgaWYod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHR5cGVzID0gW1xyXG4gICAgICAgICAgJ3BvaW50ZXJkb3duJyxcclxuICAgICAgICAgICdwb2ludGVybW92ZScsXHJcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xyXG4gICAgICAgIF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHlwZXMgPSBbXHJcbiAgICAgICAgICAnTVNQb2ludGVyRG93bicsXHJcbiAgICAgICAgICAnTVNQb2ludGVyTW92ZScsXHJcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZihHZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMpIHtcclxuICAgICAgdHlwZXMgPSBbXHJcbiAgICAgICAgJ3RvdWNoc3RhcnQnLFxyXG4gICAgICAgICd0b3VjaG1vdmUnLFxyXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCdcclxuICAgICAgXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHR5cGVzID0gW1xyXG4gICAgICAgICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsXHJcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxyXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJ1xyXG4gICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSA9IHR5cGVzWzBdO1xyXG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfTU9WRV0gPSB0eXBlc1sxXTtcclxuICAgIEVWRU5UX1RZUEVTW0VWRU5UX0VORF0gPSB0eXBlc1syXTtcclxuICAgIHJldHVybiBFVkVOVF9UWVBFUztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXHJcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcclxuICAgKi9cclxuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKSB7XHJcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxyXG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XHJcbiAgICAgIHJldHVybiBQb2ludGVyRXZlbnQuZ2V0VG91Y2hMaXN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IHRoZSB0b3VjaGxpc3RcclxuICAgIGlmKGV2LnRvdWNoZXMpIHtcclxuICAgICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX01PVkUpIHtcclxuICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XHJcbiAgICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQoVXRpbHMudG9BcnJheShldi50b3VjaGVzKSwgVXRpbHMudG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcykpO1xyXG4gICAgICB2YXIgdG91Y2hMaXN0ID0gW107XHJcblxyXG4gICAgICBVdGlscy5lYWNoKGNvbmNhdCwgZnVuY3Rpb24odG91Y2gpIHtcclxuICAgICAgICBpZihVdGlscy5pbkFycmF5KGlkZW50aWZpZXJzLCB0b3VjaC5pZGVudGlmaWVyKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHRvdWNoTGlzdC5wdXNoKHRvdWNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b3VjaC5pZGVudGlmaWVyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdG91Y2hMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1ha2UgZmFrZSB0b3VjaExpc3QgZnJvbSBtb3VzZSBwb3NpdGlvblxyXG4gICAgZXYuaWRlbnRpZmllciA9IDE7XHJcbiAgICByZXR1cm4gW2V2XTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjb2xsZWN0IGJhc2ljIGV2ZW50IGRhdGFcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcclxuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG4gIGNvbGxlY3RFdmVudERhdGE6IGZ1bmN0aW9uIGNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgZXZlbnRUeXBlLCB0b3VjaGVzLCBldikge1xyXG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcclxuICAgIHZhciBwb2ludGVyVHlwZSA9IFBPSU5URVJfVE9VQ0g7XHJcbiAgICBpZihVdGlscy5pblN0cihldi50eXBlLCAnbW91c2UnKSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfTU9VU0UsIGV2KSkge1xyXG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XHJcbiAgICB9IGVsc2UgaWYoUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1BFTiwgZXYpKSB7XHJcbiAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9QRU47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXHJcbiAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXHJcbiAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXHJcbiAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxyXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXHJcbiAgICAgIHNyY0V2ZW50OiBldixcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xyXG4gICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxyXG4gICAgICAgKi9cclxuICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzcmNFdmVudCA9IHRoaXMuc3JjRXZlbnQ7XHJcbiAgICAgICAgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7XHJcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xyXG4gICAgICAgKi9cclxuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cclxuICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXHJcbiAgICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgICAqL1xyXG4gICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gRGV0ZWN0aW9uLnN0b3BEZXRlY3QoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXHJcbiAqXHJcbiAqIEBjbGFzcyBQb2ludGVyRXZlbnRcclxuICogQHN0YXRpY1xyXG4gKi9cclxuUG9pbnRlckV2ZW50ID0gR2VzdHVyZURldGVjdG9yLlBvaW50ZXJFdmVudCA9IHtcclxuICAvKipcclxuICAgKiBob2xkcyBhbGwgcG9pbnRlcnMsIGJ5IGBpZGVudGlmaWVyYFxyXG4gICAqIEBwcm9wZXJ0eSBwb2ludGVyc1xyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgcG9pbnRlcnM6IHt9LFxyXG5cclxuICAvKipcclxuICAgKiBnZXQgdGhlIHBvaW50ZXJzIGFzIGFuIGFycmF5XHJcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxyXG4gICAqL1xyXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KCkge1xyXG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xyXG4gICAgLy8gd2UgY2FuIHVzZSBmb3JFYWNoIHNpbmNlIHBvaW50ZXJFdmVudHMgb25seSBpcyBpbiBJRTEwXHJcbiAgICBVdGlscy5lYWNoKHRoaXMucG9pbnRlcnMsIGZ1bmN0aW9uKHBvaW50ZXIpIHtcclxuICAgICAgdG91Y2hsaXN0LnB1c2gocG9pbnRlcik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0b3VjaGxpc3Q7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcclxuICAgKi9cclxuICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgcG9pbnRlckV2ZW50KSB7XHJcbiAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EIHx8IChldmVudFR5cGUgIT0gRVZFTlRfRU5EICYmIHBvaW50ZXJFdmVudC5idXR0b25zICE9PSAxKSkge1xyXG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvaW50ZXJFdmVudC5pZGVudGlmaWVyID0gcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcclxuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjaGVjayBpZiBldiBtYXRjaGVzIHBvaW50ZXJ0eXBlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldlxyXG4gICAqL1xyXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xyXG4gICAgaWYoIWV2LnBvaW50ZXJUeXBlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHQgPSBldi5wb2ludGVyVHlwZSxcclxuICAgICAgICB0eXBlcyA9IHt9O1xyXG5cclxuICAgIHR5cGVzW1BPSU5URVJfTU9VU0VdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgUE9JTlRFUl9NT1VTRSkpO1xyXG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XHJcbiAgICB0eXBlc1tQT0lOVEVSX1BFTl0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9QRU4gfHwgUE9JTlRFUl9QRU4pKTtcclxuICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xyXG4gICAqL1xyXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XHJcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxyXG4gKlxyXG4gKiBAY2xhc3MgRGV0ZWN0aW9uXHJcbiAqIEBzdGF0aWNcclxuICovXHJcbkRldGVjdGlvbiA9IEdlc3R1cmVEZXRlY3Rvci5kZXRlY3Rpb24gPSB7XHJcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXHJcbiAgZ2VzdHVyZXM6IFtdLFxyXG5cclxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXHJcbiAgY3VycmVudDogbnVsbCxcclxuXHJcbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxyXG4gIC8vIGlzIGEgZnVsbCBjbG9uZSBvZiB0aGUgcHJldmlvdXMgZ2VzdHVyZS5jdXJyZW50IG9iamVjdFxyXG4gIHByZXZpb3VzOiBudWxsLFxyXG5cclxuICAvLyB3aGVuIHRoaXMgYmVjb21lcyB0cnVlLCBubyBnZXN0dXJlcyBhcmUgZmlyZWRcclxuICBzdG9wcGVkOiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogc3RhcnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXHJcbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXHJcbiAgICovXHJcbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xyXG4gICAgLy8gYWxyZWFkeSBidXN5IHdpdGggYSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gb24gYW4gZWxlbWVudFxyXG4gICAgaWYodGhpcy5jdXJyZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBob2xkcyBjdXJyZW50IHNlc3Npb25cclxuICAgIHRoaXMuY3VycmVudCA9IHtcclxuICAgICAgaW5zdDogaW5zdCwgLy8gcmVmZXJlbmNlIHRvIEdlc3R1cmVEZXRlY3Rvckluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgZm9yXHJcbiAgICAgIHN0YXJ0RXZlbnQ6IFV0aWxzLmV4dGVuZCh7fSwgZXZlbnREYXRhKSwgLy8gc3RhcnQgZXZlbnREYXRhIGZvciBkaXN0YW5jZXMsIHRpbWluZyBldGNcclxuICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcclxuICAgICAgbGFzdENhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXHJcbiAgICAgIGZ1dHVyZUNhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXHJcbiAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXHJcbiAgICAgIG5hbWU6ICcnIC8vIGN1cnJlbnQgZ2VzdHVyZSB3ZSdyZSBpbi9kZXRlY3RlZCwgY2FuIGJlICd0YXAnLCAnaG9sZCcgZXRjXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGV0ZWN0KGV2ZW50RGF0YSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxyXG4gICAqIEByZXR1cm4ge2FueX1cclxuICAgKi9cclxuICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcclxuICAgIGlmKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5zdG9wcGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBleHRlbmQgZXZlbnQgZGF0YSB3aXRoIGNhbGN1bGF0aW9ucyBhYm91dCBzY2FsZSwgZGlzdGFuY2UgZXRjXHJcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xyXG5cclxuICAgIC8vIEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZSBhbmQgaW5zdGFuY2Ugb3B0aW9uc1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcclxuICAgICAgICBpbnN0T3B0aW9ucyA9IGluc3Qub3B0aW9ucztcclxuXHJcbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXHJcbiAgICBVdGlscy5lYWNoKHRoaXMuZ2VzdHVyZXMsIGZ1bmN0aW9uIHRyaWdnZXJHZXN0dXJlKGdlc3R1cmUpIHtcclxuICAgICAgLy8gb25seSB3aGVuIHRoZSBpbnN0YW5jZSBvcHRpb25zIGhhdmUgZW5hYmxlZCB0aGlzIGdlc3R1cmVcclxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xyXG4gICAgICAgIGdlc3R1cmUuaGFuZGxlci5jYWxsKGdlc3R1cmUsIGV2ZW50RGF0YSwgaW5zdCk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8vIHN0b3JlIGFzIHByZXZpb3VzIGV2ZW50IGV2ZW50XHJcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcclxuICAgICAgdGhpcy5jdXJyZW50Lmxhc3RFdmVudCA9IGV2ZW50RGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZihldmVudERhdGEuZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xyXG4gICAgICB0aGlzLnN0b3BEZXRlY3QoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXZlbnREYXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcclxuICAgKiB0aGlzIGlzIGNhbGxlZCBvbiBlbmREZXRlY3QsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHdoZW4gYSBmaW5hbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYXMgYmVlbiBkZXRlY3RlZFxyXG4gICAqIHRvIHN0b3Agb3RoZXIgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGZyb20gYmVpbmcgZmlyZWRcclxuICAgKi9cclxuICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xyXG4gICAgLy8gY2xvbmUgY3VycmVudCBkYXRhIHRvIHRoZSBzdG9yZSBhcyB0aGUgcHJldmlvdXMgZ2VzdHVyZVxyXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXHJcbiAgICB0aGlzLnByZXZpb3VzID0gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmN1cnJlbnQpO1xyXG5cclxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XHJcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXHJcbiAgICovXHJcbiAgZ2V0Q2FsY3VsYXRlZERhdGE6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWREYXRhKGV2LCBjZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXHJcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXHJcbiAgICAgICAgY2FsY0V2ID0gY3VyLmxhc3RDYWxjRXZlbnQsXHJcbiAgICAgICAgY2FsY0RhdGEgPSBjdXIubGFzdENhbGNEYXRhO1xyXG5cclxuICAgIGlmKGNhbGNFdiAmJiBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wID4gR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCkge1xyXG4gICAgICBjZW50ZXIgPSBjYWxjRXYuY2VudGVyO1xyXG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xyXG4gICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WDtcclxuICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBjYWxjRXYuY2VudGVyLmNsaWVudFk7XHJcbiAgICAgIHJlY2FsYyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XHJcbiAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcclxuICAgIH1cclxuXHJcbiAgICBpZighY3VyLmxhc3RDYWxjRXZlbnQgfHwgcmVjYWxjKSB7XHJcbiAgICAgIGNhbGNEYXRhLnZlbG9jaXR5ID0gVXRpbHMuZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xyXG4gICAgICBjYWxjRGF0YS5kaXJlY3Rpb24gPSBVdGlscy5nZXREaXJlY3Rpb24oY2VudGVyLCBldi5jZW50ZXIpO1xyXG5cclxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xyXG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XHJcbiAgICB9XHJcblxyXG4gICAgZXYudmVsb2NpdHlYID0gY2FsY0RhdGEudmVsb2NpdHkueDtcclxuICAgIGV2LnZlbG9jaXR5WSA9IGNhbGNEYXRhLnZlbG9jaXR5Lnk7XHJcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcclxuICAgIGV2LmludGVyaW1EaXJlY3Rpb24gPSBjYWxjRGF0YS5kaXJlY3Rpb247XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogZXh0ZW5kIGV2ZW50RGF0YSBmb3IgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XHJcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxyXG4gICAgICAgIHN0YXJ0RXYgPSBjdXIuc3RhcnRFdmVudCxcclxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSBzdGFydCB0b3VjaGxpc3QgdG8gY2FsY3VsYXRlIHRoZSBzY2FsZS9yb3RhdGlvblxyXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XHJcbiAgICAgIHN0YXJ0RXYudG91Y2hlcyA9IFtdO1xyXG4gICAgICBVdGlscy5lYWNoKGV2LnRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XHJcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xyXG4gICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcclxuICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIHN0YXJ0RXYudGltZVN0YW1wLFxyXG4gICAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WCxcclxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XHJcblxyXG4gICAgdGhpcy5nZXRDYWxjdWxhdGVkRGF0YShldiwgbGFzdEV2LmNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XHJcblxyXG4gICAgVXRpbHMuZXh0ZW5kKGV2LCB7XHJcbiAgICAgIHN0YXJ0RXZlbnQ6IHN0YXJ0RXYsXHJcblxyXG4gICAgICBkZWx0YVRpbWU6IGRlbHRhVGltZSxcclxuICAgICAgZGVsdGFYOiBkZWx0YVgsXHJcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxyXG5cclxuICAgICAgZGlzdGFuY2U6IFV0aWxzLmdldERpc3RhbmNlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxyXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXHJcbiAgICAgIGRpcmVjdGlvbjogVXRpbHMuZ2V0RGlyZWN0aW9uKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxyXG4gICAgICBzY2FsZTogVXRpbHMuZ2V0U2NhbGUoc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcclxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBldjtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiByZWdpc3RlciBuZXcgZ2VzdHVyZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnZXN0dXJlIG9iamVjdCwgc2VlIGBnZXN0dXJlcy9gIGZvciBkb2N1bWVudGF0aW9uXHJcbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXHJcbiAgICovXHJcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGdlc3R1cmUpIHtcclxuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXHJcbiAgICB2YXIgb3B0aW9ucyA9IGdlc3R1cmUuZGVmYXVsdHMgfHwge307XHJcbiAgICBpZihvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGV4dGVuZCBHZXN0dXJlRGV0ZWN0b3IgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIG9wdGlvbnNcclxuICAgIFV0aWxzLmV4dGVuZChHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xyXG5cclxuICAgIC8vIHNldCBpdHMgaW5kZXhcclxuICAgIGdlc3R1cmUuaW5kZXggPSBnZXN0dXJlLmluZGV4IHx8IDEwMDA7XHJcblxyXG4gICAgLy8gYWRkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHRvIHRoZSBsaXN0XHJcbiAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XHJcblxyXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxyXG4gICAgdGhpcy5nZXN0dXJlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgaWYoYS5pbmRleCA8IGIuaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgIH1cclxuICAgICAgaWYoYS5pbmRleCA+IGIuaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcclxuICovXHJcblxyXG4vKipcclxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcclxuICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXHJcbiAqXHJcbiAqIEBjbGFzcyBJbnN0YW5jZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXHJcbiAqIEByZXR1cm4ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cclxuICovXHJcbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xyXG4gIC8vIHRoaXMgYWxzbyBzZXRzIHVwIHRoZSBkZWZhdWx0IG9wdGlvbnNcclxuICBzZXR1cCgpO1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZW5hYmxlZFxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAvKipcclxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcclxuICAgKiBvcHRpb25zIHdpdGggYW4gXyBhcmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZVxyXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBVdGlscy5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XHJcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcclxuICAgIG9wdGlvbnNbVXRpbHMudG9DYW1lbENhc2UobmFtZSldID0gdmFsdWU7XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMub3B0aW9ucyA9IFV0aWxzLmV4dGVuZChVdGlscy5leHRlbmQoe30sIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcclxuICBpZih0aGlzLm9wdGlvbnMuYmVoYXZpb3IpIHtcclxuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxyXG4gICAqIEBwcm9wZXJ0eSBldmVudFN0YXJ0SGFuZGxlclxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdGhpcy5ldmVudFN0YXJ0SGFuZGxlciA9IEV2ZW50Lm9uVG91Y2goZWxlbWVudCwgRVZFTlRfU1RBUlQsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICBpZihzZWxmLmVuYWJsZWQgJiYgZXYuZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XHJcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XHJcbiAgICB9IGVsc2UgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XHJcbiAgICAgIERldGVjdGlvbi5kZXRlY3QoZXYpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBrZWVwIGEgbGlzdCBvZiB1c2VyIGV2ZW50IGhhbmRsZXJzIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgd2hlbiBjYWxsaW5nICdkaXNwb3NlJ1xyXG4gICAqIEBwcm9wZXJ0eSBldmVudEhhbmRsZXJzXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xyXG4gIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xyXG59O1xyXG5cclxuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcclxuICAvKipcclxuICAgKiBAbWV0aG9kIG9uXHJcbiAgICogQHNpZ25hdHVyZSBvbihnZXN0dXJlcywgaGFuZGxlcilcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXUFkZHMgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSBnZXN0dXJlLiBBdmFpbGFibGUgZ2VzdHVyZXMgYXJlOiBkcmFnLCBkcmFnbGVmdCwgZHJhZ3JpZ2h0LCBkcmFndXAsIGRyYWdkb3duLCBob2xkLCByZWxlYXNlLCBzd2lwZSwgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0LCBzd2lwZXVwLCBzd2lwZWRvd24sIHRhcCwgZG91YmxldGFwLCB0b3VjaCwgdHJhbnNmb3JtLCBwaW5jaCwgcGluY2hpbiwgcGluY2hvdXQgYW5kIHJvdGF0ZS4gWy9lbl1cclxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+OBq+WvvuOBmeOCi+OCpOODmeODs+ODiOODj+ODs+ODieODqeOCkui/veWKoOOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OCuOOCp+OCueODgeODo+WQjeOBr+OAgWRyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBob2xkIHJlbGVhc2Ugc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24gdGFwIGRvdWJsZXRhcCB0b3VjaCB0cmFuc2Zvcm0gcGluY2ggcGluY2hpbiBwaW5jaG91dCByb3RhdGUg44Gn44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcclxuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXHJcbiAgICogICBbamFd5qSc55+l44GZ44KL44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIG9uOiBmdW5jdGlvbiBvbkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5wdXNoKHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBvZmZcclxuICAgKiBAc2lnbmF0dXJlIG9mZihnZXN0dXJlcywgaGFuZGxlcilcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxyXG4gICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcclxuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXHJcbiAgICogICBbamFd44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIG9mZjogZnVuY3Rpb24gb2ZmRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBFdmVudC5vZmYoc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcclxuICAgICAgaWYoaW5kZXggIT09IGZhbHNlKSB7XHJcbiAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogdHJpZ2dlciBnZXN0dXJlIGV2ZW50XHJcbiAgICogQG1ldGhvZCB0cmlnZ2VyXHJcbiAgICogQHNpZ25hdHVyZSB0cmlnZ2VyKGdlc3R1cmUsIGV2ZW50RGF0YSlcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxyXG4gICAqL1xyXG4gIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChnZXN0dXJlLCBldmVudERhdGEpIHtcclxuICAgIC8vIG9wdGlvbmFsXHJcbiAgICBpZighZXZlbnREYXRhKSB7XHJcbiAgICAgIGV2ZW50RGF0YSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSBET00gZXZlbnRcclxuICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGV2ZW50LmluaXRFdmVudChnZXN0dXJlLCB0cnVlLCB0cnVlKTtcclxuICAgIGV2ZW50Lmdlc3R1cmUgPSBldmVudERhdGE7XHJcblxyXG4gICAgLy8gdHJpZ2dlciBvbiB0aGUgdGFyZ2V0IGlmIGl0IGlzIGluIHRoZSBpbnN0YW5jZSBlbGVtZW50LFxyXG4gICAgLy8gdGhpcyBpcyBmb3IgZXZlbnQgZGVsZWdhdGlvbiB0cmlja3NcclxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgaWYoVXRpbHMuaGFzUGFyZW50KGV2ZW50RGF0YS50YXJnZXQsIGVsZW1lbnQpKSB7XHJcbiAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGVuYWJsZVxyXG4gICAqIEBzaWduYXR1cmUgZW5hYmxlKHN0YXRlKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dRW5hYmxlIG9yIGRpc2FibGUgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cclxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+aknOefpeOCkuacieWKueWMli/nhKHlirnljJbjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcclxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSBlbmFibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeacieWKueOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcclxuICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBkaXNwb3NlXHJcbiAgICogQHNpZ25hdHVyZSBkaXNwb3NlKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVJlbW92ZSBhbmQgZGVzdHJveSBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuWy9lbl1cclxuICAgKiAgW2phXeOBk+OBruOCpOODs+OCueOCv+ODs+OCueOBp+OBruOCuOOCp+OCueODgeODo+OBruaknOefpeOChOOAgeOCpOODmeODs+ODiOODj+ODs+ODieODqeOCkuWFqOOBpuino+mZpOOBl+OBpuW7g+ajhOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuICAgIHZhciBpLCBlaDtcclxuXHJcbiAgICAvLyB1bmRvIGFsbCBjaGFuZ2VzIG1hZGUgYnkgc3RvcF9icm93c2VyX2JlaGF2aW9yXHJcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xyXG5cclxuICAgIC8vIHVuYmluZCBhbGwgY3VzdG9tIGV2ZW50IGhhbmRsZXJzXHJcbiAgICBmb3IoaSA9IC0xOyAoZWggPSB0aGlzLmV2ZW50SGFuZGxlcnNbKytpXSk7KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XHJcblxyXG4gICAgLy8gdW5iaW5kIHRoZSBzdGFydCBldmVudCBsaXN0ZW5lclxyXG4gICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcclxuICovXHJcbi8qKlxyXG4gKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS5cclxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxyXG4gKiBgYGBgXHJcbiAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihldikge1xyXG4gKiAgICBjb25zb2xlLmxvZyhldik7XHJcbiAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcclxuICogIH0pO1xyXG4gKiBgYGBgXHJcbiAqXHJcbiAqIEBjbGFzcyBEcmFnXHJcbiAqIEBzdGF0aWNcclxuICovXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICovXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKi9cclxuLyoqXHJcbiAqIEBldmVudCBkcmFnZW5kXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKi9cclxuLyoqXHJcbiAqIEBldmVudCBkcmFwbGVmdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICovXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ3JpZ2h0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKi9cclxuLyoqXHJcbiAqIEBldmVudCBkcmFndXBcclxuICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAqL1xyXG4vKipcclxuICogQGV2ZW50IGRyYWdkb3duXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKi9cclxuKGZ1bmN0aW9uKG5hbWUpIHtcclxuICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGRyYWdHZXN0dXJlKGV2LCBpbnN0KSB7XHJcbiAgICB2YXIgY3VyID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XHJcblxyXG4gICAgLy8gbWF4IHRvdWNoZXNcclxuICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcyA+IDAgJiZcclxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcclxuICAgIGNhc2UgRVZFTlRfU1RBUlQ6XHJcbiAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIEVWRU5UX01PVkU6XHJcbiAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxyXG4gICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xyXG4gICAgICBpZihldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcclxuICAgICAgICBjdXIubmFtZSAhPSBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc3RhcnRDZW50ZXIgPSBjdXIuc3RhcnRFdmVudC5jZW50ZXI7XHJcblxyXG4gICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXHJcbiAgICAgIGlmKGN1ci5uYW1lICE9IG5hbWUpIHtcclxuICAgICAgICBjdXIubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgaWYoaW5zdC5vcHRpb25zLmRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gJiYgZXYuZGlzdGFuY2UgPiAwKSB7XHJcbiAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgZnJvbSB0aGUgb3JpZ2luYWwgZXZlbnQgY2VudGVyLlxyXG4gICAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvcnJlY3Rpb24sIHRoZSBkcmFnZ2VkIGRpc3RhbmNlIHdvdWxkIGp1bXBzdGFydCBhdCBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cclxuICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBzYXZlIHRoZSBvcmlnaW5hbCBzdGFydCBwb2ludCBzb21ld2hlcmVcclxuICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xyXG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xyXG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xyXG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WCArPSBldi5kZWx0YVggKiBmYWN0b3I7XHJcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcclxuXHJcbiAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxyXG4gICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGxvY2sgZHJhZyB0byBheGlzP1xyXG4gICAgICBpZihjdXIubGFzdEV2ZW50LmRyYWdMb2NrVG9BeGlzIHx8XHJcbiAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcclxuICAgICAgICAgIGluc3Qub3B0aW9ucy5kcmFnTG9ja01pbkRpc3RhbmNlIDw9IGV2LmRpc3RhbmNlXHJcbiAgICAgICAgKSkge1xyXG4gICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cclxuICAgICAgICB2YXIgbGFzdERpcmVjdGlvbiA9IGN1ci5sYXN0RXZlbnQuZGlyZWN0aW9uO1xyXG4gICAgICAgIGlmKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xyXG4gICAgICAgICAgaWYoVXRpbHMuaXNWZXJ0aWNhbChsYXN0RGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFZIDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcclxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XHJcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcclxuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50c1xyXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XHJcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcclxuXHJcbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSBVdGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbik7XHJcblxyXG4gICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xyXG4gICAgICAgIGlmKChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrVmVydGljYWwgJiYgaXNWZXJ0aWNhbCkgfHxcclxuICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxyXG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xyXG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xyXG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XHJcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuRHJhZyA9IHtcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgaW5kZXg6IDUwLFxyXG4gICAgICBoYW5kbGVyOiBkcmFnR2VzdHVyZSxcclxuICAgICAgZGVmYXVsdHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtaW5pbWFsIG1vdmVtZW50IHRoYXQgaGF2ZSB0byBiZSBtYWRlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBnZXRzIHRyaWdnZXJlZFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWluRGlzdGFuY2VcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDEwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxMCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xyXG4gICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cclxuICAgICAgICAgKiBVc2VmdWwgdG8gYXZvaWQgYSBqZXJrLXN0YXJ0aW5nIGRyYWcsIHdoaWNoIGNhbiBtYWtlIGZpbmUtYWRqdXN0bWVudHNcclxuICAgICAgICAgKiB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IHRydWUsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNldCAwIGZvciB1bmxpbWl0ZWQsIGJ1dCB0aGlzIGNhbiBjb25mbGljdCB3aXRoIHRyYW5zZm9ybVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRyYWdNYXhUb3VjaGVzOiAxLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xyXG4gICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XHJcbiAgICAgICAgICogd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXHJcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja0hvcml6b250YWxcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRyYWdCbG9ja0hvcml6b250YWw6IGZhbHNlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzYW1lIGFzIGBkcmFnQmxvY2tIb3Jpem9udGFsYCwgYnV0IGZvciB2ZXJ0aWNhbCBtb3ZlbWVudFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tWZXJ0aWNhbFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBkcmFnTG9ja1RvQXhpcyBrZWVwcyB0aGUgZHJhZyBnZXN0dXJlIG9uIHRoZSBheGlzIHRoYXQgaXQgc3RhcnRlZCBvbixcclxuICAgICAgICAgKiBJdCBkaXNhbGxvd3MgdmVydGljYWwgZGlyZWN0aW9ucyBpZiB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gd2FzIGhvcml6b250YWwsIGFuZCB2aWNlIHZlcnNhLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6IGZhbHNlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ0xvY2tNaW5EaXN0YW5jZVxyXG4gICAgICAgICAqIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrTWluRGlzdGFuY2VcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDI1XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZHJhZ0xvY2tNaW5EaXN0YW5jZTogMjVcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KSgnZHJhZycpO1xyXG5cclxuICAvKipcclxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cclxuICAgKiBvbmx5IHVzYWJsZSBpZiB5b3Uga25vdyB3aGF0IHlvdXIgZG9pbmcuLi5cclxuICAgKlxyXG4gICAqIEBjbGFzcyBHZXN0dXJlXHJcbiAgICogQHN0YXRpY1xyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIEBldmVudCBnZXN0dXJlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkdlc3R1cmUgPSB7XHJcbiAgICBuYW1lOiAnZ2VzdHVyZScsXHJcbiAgICBpbmRleDogMTMzNyxcclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XHJcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggc3RheXMgYXQgdGhlIHNhbWUgcGxhY2UgZm9yIHggdGltZVxyXG4gICAqXHJcbiAgICogQGNsYXNzIEhvbGRcclxuICAgKiBAc3RhdGljXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IGhvbGRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgKi9cclxuICAoZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIHRpbWVyO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XHJcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxyXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50O1xyXG5cclxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xyXG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG4gICAgICAgIC8vIHNldCB0aGUgZ2VzdHVyZSBzbyB3ZSBjYW4gY2hlY2sgaW4gdGhlIHRpbWVvdXQgaWYgaXQgc3RpbGwgaXNcclxuICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGltZXIgYW5kIGlmIGFmdGVyIHRoZSB0aW1lb3V0IGl0IHN0aWxsIGlzIGhvbGQsXHJcbiAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmKGN1cnJlbnQgJiYgY3VycmVudC5uYW1lID09IG5hbWUpIHtcclxuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCBvcHRpb25zLmhvbGRUaW1lb3V0KTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcclxuICAgICAgICBpZihldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ib2xkID0ge1xyXG4gICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICBpbmRleDogMTAsXHJcbiAgICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCA1MDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBob2xkVGltZW91dDogNTAwLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtb3ZlbWVudCBhbGxvd2VkIHdoaWxlIGhvbGRpbmdcclxuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhvbGRUaHJlc2hvbGQ6IDJcclxuICAgICAgfSxcclxuICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcclxuICAgIH07XHJcbiAgfSkoJ2hvbGQnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyByZWxlYXNlZCBmcm9tIHRoZSBwYWdlXHJcbiAgICpcclxuICAgKiBAY2xhc3MgUmVsZWFzZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKi9cclxuICAvKipcclxuICAgKiBAZXZlbnQgcmVsZWFzZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5SZWxlYXNlID0ge1xyXG4gICAgbmFtZTogJ3JlbGVhc2UnLFxyXG4gICAgaW5kZXg6IEluZmluaXR5LFxyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcclxuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcclxuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXHJcbiAgICogZm9yIGJlc3QgdXNhZ2UsIHNldCBgcHJldmVudERlZmF1bHRgIChvbiB0aGUgZHJhZyBnZXN0dXJlKSB0byBgdHJ1ZWBcclxuICAgKiBgYGBgXHJcbiAgICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcclxuICAgKiAgICBjb25zb2xlLmxvZyhldik7XHJcbiAgICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAqICB9KTtcclxuICAgKiBgYGBgXHJcbiAgICpcclxuICAgKiBAY2xhc3MgU3dpcGVcclxuICAgKiBAc3RhdGljXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHN3aXBlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHN3aXBlbGVmdFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIEBldmVudCBzd2lwZXJpZ2h0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHN3aXBldXBcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgKi9cclxuICAvKipcclxuICAgKiBAZXZlbnQgc3dpcGVkb3duXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlN3aXBlID0ge1xyXG4gICAgbmFtZTogJ3N3aXBlJyxcclxuICAgIGluZGV4OiA0MCxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNaW5Ub3VjaGVzXHJcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICovXHJcbiAgICAgIHN3aXBlTWluVG91Y2hlczogMSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNYXhUb3VjaGVzXHJcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICovXHJcbiAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XHJcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WFxyXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgKiBAZGVmYXVsdCAwLjZcclxuICAgICAgICovXHJcbiAgICAgIHN3aXBlVmVsb2NpdHlYOiAwLjYsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogdmVydGljYWwgc3dpcGUgdmVsb2NpdHlcclxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXHJcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAqIEBkZWZhdWx0IDAuNlxyXG4gICAgICAgKi9cclxuICAgICAgc3dpcGVWZWxvY2l0eVk6IDAuNlxyXG4gICAgfSxcclxuXHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBzd2lwZUdlc3R1cmUoZXYsIGluc3QpIHtcclxuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcclxuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gaW5zdC5vcHRpb25zO1xyXG5cclxuICAgICAgICAvLyBtYXggdG91Y2hlc1xyXG4gICAgICAgIGlmKHRvdWNoZXMgPCBvcHRpb25zLnN3aXBlTWluVG91Y2hlcyB8fFxyXG4gICAgICAgICAgdG91Y2hlcyA+IG9wdGlvbnMuc3dpcGVNYXhUb3VjaGVzKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcclxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xyXG4gICAgICAgIGlmKGV2LnZlbG9jaXR5WCA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVggfHxcclxuICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcclxuICAgICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXHJcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XHJcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIFNpbmdsZSB0YXAgYW5kIGEgZG91YmxlIHRhcCBvbiBhIHBsYWNlXHJcbiAgICpcclxuICAgKiBAY2xhc3MgVGFwXHJcbiAgICogQHN0YXRpY1xyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIEBldmVudCB0YXBcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgKi9cclxuICAvKipcclxuICAgKiBAZXZlbnQgZG91YmxldGFwXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICovXHJcbiAgKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciBoYXNNb3ZlZCA9IGZhbHNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcclxuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXHJcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQsXHJcbiAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxyXG4gICAgICAgICAgc2luY2VQcmV2LFxyXG4gICAgICAgICAgZGlkRG91YmxlVGFwO1xyXG5cclxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xyXG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxyXG4gICAgICAgIGhhc01vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XHJcbiAgICAgICAgaGFzTW92ZWQgPSBoYXNNb3ZlZCB8fCAoZXYuZGlzdGFuY2UgPiBvcHRpb25zLnRhcE1heERpc3RhbmNlKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxyXG4gICAgICAgIGlmKCFVdGlscy5pblN0cihldi5zcmNFdmVudC50eXBlLCAnY2FuY2VsJykgJiYgZXYuZGVsdGFUaW1lIDwgb3B0aW9ucy50YXBNYXhUaW1lICYmICFoYXNNb3ZlZCkge1xyXG4gICAgICAgICAgLy8gcHJldmlvdXMgZ2VzdHVyZSwgZm9yIHRoZSBkb3VibGUgdGFwIHNpbmNlIHRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGdlc3R1cmUgZGV0ZWN0aW9uc1xyXG4gICAgICAgICAgc2luY2VQcmV2ID0gcHJldiAmJiBwcmV2Lmxhc3RFdmVudCAmJiBldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXA7XHJcbiAgICAgICAgICBkaWREb3VibGVUYXAgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBjaGVjayBpZiBkb3VibGUgdGFwXHJcbiAgICAgICAgICBpZihwcmV2ICYmIHByZXYubmFtZSA9PSBuYW1lICYmXHJcbiAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcclxuICAgICAgICAgICAgZXYuZGlzdGFuY2UgPCBvcHRpb25zLmRvdWJsZVRhcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcignZG91YmxldGFwJywgZXYpO1xyXG4gICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxyXG4gICAgICAgICAgaWYoIWRpZERvdWJsZVRhcCB8fCBvcHRpb25zLnRhcEFsd2F5cykge1xyXG4gICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRhcCA9IHtcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgaW5kZXg6IDEwMCxcclxuICAgICAgaGFuZGxlcjogdGFwR2VzdHVyZSxcclxuICAgICAgZGVmYXVsdHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtYXggdGltZSBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAyNTBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhEaXN0YW5jZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMTBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXBNYXhEaXN0YW5jZTogMTAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGFsd2F5cyB0cmlnZ2VyIHRoZSBgdGFwYCBldmVudCwgZXZlbiB3aGlsZSBkb3VibGUtdGFwcGluZ1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGFwQWx3YXlzOiB0cnVlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtYXggZGlzdGFuY2UgYmV0d2VlbiB0d28gdGFwc1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcclxuICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwSW50ZXJ2YWxcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDMwMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KSgndGFwJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcclxuICAgKi9cclxuICAvKipcclxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgdG91Y2hlZCBhdCB0aGUgcGFnZVxyXG4gICAqXHJcbiAgICogQGNsYXNzIFRvdWNoXHJcbiAgICogQHN0YXRpY1xyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIEBldmVudCB0b3VjaFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ub3VjaCA9IHtcclxuICAgIG5hbWU6ICd0b3VjaCcsXHJcbiAgICBpbmRleDogLUluZmluaXR5LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgYXQgdG91Y2hzdGFydCwgYW5kIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGJ5IGRpc2FibGluZyB0aGUgc2Nyb2xsaW5nIG9mIHRoZSBwYWdlLFxyXG4gICAgICAgKiBidXQgaXQgaW1wcm92ZXMgZ2VzdHVyZXMgbGlrZSB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxyXG4gICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXHJcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50RGVmYXVsdFxyXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICovXHJcbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXHJcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcclxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAqL1xyXG4gICAgICBwcmV2ZW50TW91c2U6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XHJcbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50TW91c2UgJiYgZXYucG9pbnRlclR5cGUgPT0gUE9JTlRFUl9NT1VTRSkge1xyXG4gICAgICAgIGV2LnN0b3BEZXRlY3QoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xyXG4gICAgICAgIGluc3QudHJpZ2dlcigndG91Y2gnLCBldik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xyXG4gICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxyXG4gICAqIGBwcmV2ZW50RGVmYXVsdGAgb3B0aW9uLlxyXG4gICAqXHJcbiAgICogQGNsYXNzIFRyYW5zZm9ybVxyXG4gICAqIEBzdGF0aWNcclxuICAgKi9cclxuICAvKipcclxuICAgKiBAZXZlbnQgdHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHRyYW5zZm9ybWVuZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwaW5jaGluXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHBpbmNob3V0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHJvdGF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAqL1xyXG4gIChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtR2VzdHVyZShldiwgaW5zdCkge1xyXG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XHJcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XHJcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XHJcbiAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxyXG4gICAgICAgIGlmKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNjYWxlVGhyZXNob2xkID0gTWF0aC5hYnMoMSAtIGV2LnNjYWxlKTtcclxuICAgICAgICB2YXIgcm90YXRpb25UaHJlc2hvbGQgPSBNYXRoLmFicyhldi5yb3RhdGlvbik7XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxyXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXHJcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcclxuICAgICAgICAgIHJvdGF0aW9uVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxyXG4gICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxyXG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcclxuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xyXG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxyXG5cclxuICAgICAgICAvLyB0cmlnZ2VyIHJvdGF0ZSBldmVudFxyXG4gICAgICAgIGlmKHJvdGF0aW9uVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XHJcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcclxuICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSkge1xyXG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcclxuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XHJcbiAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XHJcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xyXG4gICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICBpbmRleDogNDUsXHJcbiAgICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbWluaW1hbCBzY2FsZSBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcclxuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluU2NhbGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuMDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0cmFuc2Zvcm1NaW5TY2FsZTogMC4wMSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcm90YXRpb24gaW4gZGVncmVlc1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRyYW5zZm9ybU1pblJvdGF0aW9uOiAxXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBoYW5kbGVyOiB0cmFuc2Zvcm1HZXN0dXJlXHJcbiAgICB9O1xyXG4gIH0pKCd0cmFuc2Zvcm0nKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVEZXRlY3RvcjtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAb2JqZWN0IG9ucy5wbGF0Zm9ybVxyXG4gKiBAY2F0ZWdvcnkgdXRpbFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dVXRpbGl0eSBtZXRob2RzIHRvIGRldGVjdCBjdXJyZW50IHBsYXRmb3JtLlsvZW5dXHJcbiAqICAgW2phXeePvuWcqOWun+ihjOOBleOCjOOBpuOBhOOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOOCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAqL1xyXG5jbGFzcyBQbGF0Zm9ybSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbCBlbGVtZW50cyB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIHRoZSBhcHAgd2FzIHJ1bm5pbmcgb24gdGhpcyBwbGF0Zm9ybS5cclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fcmVuZGVyUGxhdGZvcm0gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzZWxlY3RcclxuICAgKiBAc2lnbmF0dXJlIHNlbGVjdChwbGF0Zm9ybSlcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBsYXRmb3JtIE5hbWUgb2YgdGhlIHBsYXRmb3JtLlxyXG4gICAqICAgW2VuXVBvc3NpYmxlIHZhbHVlcyBhcmU6IFwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiIG9yIFwid3BcIi5bL2VuXVxyXG4gICAqICAgW2phXVwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiLCBcIndwXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNldHMgdGhlIHBsYXRmb3JtIHVzZWQgdG8gcmVuZGVyIHRoZSBlbGVtZW50cy4gVXNlZnVsIGZvciB0ZXN0aW5nLlsvZW5dXHJcbiAgICogICBbamFd6KaB57Sg44KS5o+P55S744GZ44KL44Gf44KB44Gr5Yip55So44GZ44KL44OX44Op44OD44OI44OV44Kp44O844Og5ZCN44KS6Kit5a6a44GX44G+44GZ44CC44OG44K544OI44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBzZWxlY3QocGxhdGZvcm0pIHtcclxuICAgIGlmICh0eXBlb2YgcGxhdGZvcm0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXMuX3JlbmRlclBsYXRmb3JtID0gcGxhdGZvcm0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGlzV2ViVmlld1xyXG4gICAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxyXG4gICAqICAgW2phXUNvcmRvdmHlhoXjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNXZWJWaWV3KCkge1xyXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzV2ViVmlldygpIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgZG9tIGNvbnRlbnRzIGxvYWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gISEod2luZG93LmNvcmRvdmEgfHwgd2luZG93LnBob25lZ2FwIHx8IHdpbmRvdy5QaG9uZUdhcCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGlzSU9TXHJcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBpT1MuWy9lbl1cclxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNJT1MoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnaW9zJztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRcclxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZCgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBBbmRyb2lkLlsvZW5dXHJcbiAgICogICBbamFdQW5kcm9pZOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBpc0FuZHJvaWQoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYW5kcm9pZCc7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFBob25lXHJcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRQaG9uZSgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCBwaG9uZS5bL2VuXVxyXG4gICAqICAgW2phXUFuZHJvaWTmkLrluK/kuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNBbmRyb2lkUGhvbmUoKSB7XHJcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRUYWJsZXRcclxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFRhYmxldCgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCB0YWJsZXQuWy9lbl1cclxuICAgKiAgIFtqYV1BbmRyb2lk44K/44OW44Os44OD44OI5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzQW5kcm9pZFRhYmxldCgpIHtcclxuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBpc1dQKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ3dwJztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuIC9XaW4zMk5UfFdpbkNFL2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIC9XaW5kb3dzIFBob25lfElFTW9iaWxlfFdQRGVza3RvcC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9zIGlzSVBob25lXHJcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZSgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBob25lLlsvZW5dXHJcbiAgICogICBbamFdaVBob25l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzSVBob25lKCkge1xyXG4gICAgcmV0dXJuIC9pUGhvbmUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc0lQYWRcclxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBhZC5bL2VuXVxyXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNJUGFkKCkge1xyXG4gICAgcmV0dXJuIC9pUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNJUG9kKCkge1xyXG4gICAgcmV0dXJuIC9pUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaXNCbGFja0JlcnJ5XHJcbiAgICogQHNpZ25hdHVyZSBpc0JsYWNrQmVycnkoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEJsYWNrQmVycnkuWy9lbl1cclxuICAgKiAgIFtqYV1CbGFja0JlcnJ55LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzQmxhY2tCZXJyeSgpIHtcclxuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdibGFja2JlcnJ5JztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5L2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5fFJJTSBUYWJsZXQgT1N8QkIxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGlzT3BlcmFcclxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBPcGVyYS5bL2VuXVxyXG4gICAqICAgW2phXU9wZXJh5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzT3BlcmEoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnb3BlcmEnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuICghIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGlzRmlyZWZveFxyXG4gICAqIEBzaWduYXR1cmUgaXNGaXJlZm94KClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRmlyZWZveC5bL2VuXVxyXG4gICAqICAgW2phXUZpcmVmb3jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNGaXJlZm94KCkge1xyXG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2ZpcmVmb3gnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaXNTYWZhcmlcclxuICAgKiBAc2lnbmF0dXJlIGlzU2FmYXJpKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgU2FmYXJpLlsvZW5dXHJcbiAgICogICBbamFdU2FmYXJp5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzU2FmYXJpKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ3NhZmFyaSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaXNDaHJvbWVcclxuICAgKiBAc2lnbmF0dXJlIGlzQ2hyb21lKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21lLlsvZW5dXHJcbiAgICogICBbamFdQ2hyb21l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzQ2hyb21lKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2Nocm9tZSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gKCEhd2luZG93LmNocm9tZSAmJiAhKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKSAmJiAhKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc0lFXHJcbiAgICogQHNpZ25hdHVyZSBpc0lFKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXIuWy9lbl1cclxuICAgKiAgIFtqYV1JbnRlcm5ldCBFeHBsb3JlcuS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBpc0lFKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2llJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaXNFZGdlXHJcbiAgICogQHNpZ25hdHVyZSBpc0VkZ2UoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBFZGdlLlsvZW5dXHJcbiAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBpc0VkZ2UoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnZWRnZSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc0lPUzdhYm92ZVxyXG4gICAqIEBzaWduYXR1cmUgaXNJT1M3YWJvdmUoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgaU9TIHZlcnNpb24gaXMgNyBvciBhYm92ZS5bL2VuXVxyXG4gICAqICAgW2phXWlPUzfku6XkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNJT1M3YWJvdmUoKSB7XHJcbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuICgvaU9TL2kudGVzdChkZXZpY2UucGxhdGZvcm0pICYmIChwYXJzZUludChkZXZpY2UudmVyc2lvbi5zcGxpdCgnLicpWzBdKSA+PSA3KSk7XHJcbiAgICB9IGVsc2UgaWYoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XHJcbiAgICAgIGNvbnN0IHZlciA9IChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9cXGJbMC05XStfWzAtOV0rKD86X1swLTldKyk/XFxiLykgfHwgWycnXSlbMF0ucmVwbGFjZSgvXy9nLCAnLicpO1xyXG4gICAgICByZXR1cm4gKHBhcnNlSW50KHZlci5zcGxpdCgnLicpWzBdKSA+PSA3KTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuICBnZXRNb2JpbGVPUygpIHtcclxuICAgIGlmICh0aGlzLmlzQW5kcm9pZCgpKSB7XHJcbiAgICAgIHJldHVybiAnYW5kcm9pZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcclxuICAgICAgcmV0dXJuICdpb3MnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5pc1dQKCkpIHtcclxuICAgICAgcmV0dXJuICd3cCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuICdvdGhlcic7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0SU9TRGV2aWNlKCkge1xyXG4gICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xyXG4gICAgICByZXR1cm4gJ2lwaG9uZSc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLmlzSVBhZCgpKSB7XHJcbiAgICAgIHJldHVybiAnaXBhZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLmlzSVBvZCgpKSB7XHJcbiAgICAgIHJldHVybiAnaXBvZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuICduYSc7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFBsYXRmb3JtKCk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xyXG5cclxuLyoqXHJcbiAqIEBvYmplY3Qgb25zLm5vdGlmaWNhdGlvblxyXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXHJcbiAqIEBjb2RlcGVuIFF3d3h5cFxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIGFsZXJ0IGRpYWxvZ3MuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcclxuICpcclxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uYWxlcnQoKWBcclxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxyXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQoKWBcclxuICpcclxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZyBvbiBBbmRyb2lkIGRldmljZXMuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnSGVsbG8sIHdvcmxkIScpO1xyXG4gKlxyXG4gKiBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oJ0FyZSB5b3UgcmVhZHk/JylcclxuICogICAudGhlbihcclxuICogICAgIGZ1bmN0aW9uKGFuc3dlcikge1xyXG4gKiAgICAgICBpZiAoYW5zd2VyID09PSAxKSB7XHJcbiAqICAgICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnTGV0XFwncyBnbyEnKTtcclxuICogICAgICAgfVxyXG4gKiAgICAgfVxyXG4gKiAgICk7XHJcbiAqXHJcbiAqIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KCdIb3cgb2xkIGFyZSA/JylcclxuICogICAudGhlbihcclxuICogICAgIGZ1bmN0aW9uKGFnZSkge1xyXG4gKiAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdZb3UgYXJlICcgKyBhZ2UgKyAnIHllYXJzIG9sZC4nKTtcclxuICogICAgIH1cclxuICogICApO1xyXG4gKi9cclxuY29uc3Qgbm90aWZpY2F0aW9uID0ge307XHJcblxyXG5ub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nID0gZnVuY3Rpb24odGl0bGUsIG1lc3NhZ2UsXHJcbiAgYnV0dG9uTGFiZWxzLCBwcmltYXJ5QnV0dG9uSW5kZXgsIG1vZGlmaWVyLCBhbmltYXRpb24sIGlkLCBjYWxsYmFjayxcclxuICBtZXNzYWdlSXNIVE1MLCBjYW5jZWxhYmxlLCBwcm9tcHREaWFsb2csIGF1dG9mb2N1cywgcGxhY2Vob2xkZXIsXHJcbiAgZGVmYXVsdFZhbHVlLCBzdWJtaXRPbkVudGVyLCBjb21waWxlKSB7XHJcblxyXG4gIGNvbXBpbGUgPSBjb21waWxlIHx8IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0OyB9O1xyXG5cclxuICBjb25zdCB0aXRsZUVsZW1lbnRIVE1MID0gdHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJyA/ICc8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+PC9kaXY+JyA6ICcnO1xyXG5cclxuXHJcbiAgbGV0IGRpYWxvZ0VsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxyXG4gIDxvbnMtYWxlcnQtZGlhbG9nPlxyXG4gICAgJHt0aXRsZUVsZW1lbnRIVE1MfVxyXG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+PC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWZvb3RlclwiPjwvZGl2PlxyXG4gIDwvb25zLWFsZXJ0LWRpYWxvZz5gKTtcclxuXHJcbiAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShkaWFsb2dFbGVtZW50KTtcclxuXHJcbiAgaWYgKGlkKSB7XHJcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XHJcbiAgfVxyXG5cclxuICBsZXQgdGl0bGVFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XHJcbiAgbGV0IG1lc3NhZ2VFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcclxuICBsZXQgZm9vdGVyRWxlbWVudCA9IGRpYWxvZ0VsZW1lbnQucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1mb290ZXInKTtcclxuICBsZXQgaW5wdXRFbGVtZW50O1xyXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG5cclxuICByZXN1bHQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIHJlc3VsdC5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgIHJlc3VsdC5yZWplY3QgPSByZWplY3Q7XHJcbiAgfSk7XHJcblxyXG4gIG1vZGlmaWVyID0gbW9kaWZpZXIgfHwgZGlhbG9nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XHJcblxyXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aXRsZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aXRsZTtcclxuICB9XHJcblxyXG4gIHRpdGxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gIGRpYWxvZ0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhbmltYXRpb24nLCBhbmltYXRpb24pO1xyXG5cclxuICBpZiAobWVzc2FnZUlzSFRNTCkge1xyXG4gICAgbWVzc2FnZUVsZW1lbnQuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHByb21wdERpYWxvZykge1xyXG4gICAgaW5wdXRFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KCc8aW5wdXQgY2xhc3M9XCJ0ZXh0LWlucHV0IHRleHQtaW5wdXQtLXVuZGVyYmFyXCIgdHlwZT1cInRleHRcIj48L2lucHV0PicpO1xyXG5cclxuICAgIGlmIChtb2RpZmllcikge1xyXG4gICAgICBpbnB1dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChgdGV4dC1pbnB1dC0tJHttb2RpZmllcn1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIHBsYWNlaG9sZGVyKTtcclxuICAgIGlucHV0RWxlbWVudC52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgIGlucHV0RWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgIGlucHV0RWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTBweCc7XHJcblxyXG4gICAgbWVzc2FnZUVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRFbGVtZW50KTtcclxuXHJcbiAgICBpZiAoc3VibWl0T25FbnRlcikge1xyXG4gICAgICBpbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xyXG4gICAgICAgICAgZGlhbG9nRWxlbWVudC5oaWRlKHtcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0RWxlbWVudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoaW5wdXRFbGVtZW50LnZhbHVlKTtcclxuICAgICAgICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nRWxlbWVudCk7XHJcblxyXG4gIGNvbXBpbGUoZGlhbG9nRWxlbWVudCk7XHJcblxyXG4gIGlmIChidXR0b25MYWJlbHMubGVuZ3RoIDw9IDIpIHtcclxuICAgIGZvb3RlckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWZvb3Rlci0tb25lJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjcmVhdGVCdXR0b24gPSBmdW5jdGlvbihpKSB7XHJcbiAgICBsZXQgYnV0dG9uRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj48L2J1dHRvbj4nKTtcclxuICAgIGJ1dHRvbkVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYnV0dG9uTGFiZWxzW2ldKSk7XHJcblxyXG4gICAgaWYgKGkgPT0gcHJpbWFyeUJ1dHRvbkluZGV4KSB7XHJcbiAgICAgIGJ1dHRvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJ1dHRvbkxhYmVscy5sZW5ndGggPD0gMikge1xyXG4gICAgICBidXR0b25FbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1idXR0b24tLW9uZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgYnV0dG9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIGZhbHNlKTtcclxuXHJcbiAgICAgIGRpYWxvZ0VsZW1lbnQuaGlkZSh7XHJcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKHByb21wdERpYWxvZykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dEVsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpbnB1dEVsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soaSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGlhbG9nRWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBpbnB1dEVsZW1lbnQgPSBidXR0b25FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBidXR0b25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgZmFsc2UpO1xyXG4gICAgZm9vdGVyRWxlbWVudC5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcclxuICB9O1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbkxhYmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgY3JlYXRlQnV0dG9uKGkpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbmNlbGFibGUpIHtcclxuICAgIGRpYWxvZ0VsZW1lbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbiAgICBkaWFsb2dFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbmNlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAocHJvbXB0RGlhbG9nKSB7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgcmVzdWx0LnJlamVjdChudWxsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxsYmFjaygtMSk7XHJcbiAgICAgICAgcmVzdWx0LnJlamVjdCgtMSk7XHJcbiAgICAgIH1cclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIGlucHV0RWxlbWVudCA9IG51bGw7XHJcbiAgICAgIH0pO1xyXG4gICAgfSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgZGlhbG9nRWxlbWVudC5zaG93KHtcclxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGlucHV0RWxlbWVudCAmJiBwcm9tcHREaWFsb2cgJiYgYXV0b2ZvY3VzKSB7XHJcbiAgICAgICAgaW5wdXRFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgbWVzc2FnZUVsZW1lbnQgPSBmb290ZXJFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgaWYgKG1vZGlmaWVyKSB7XHJcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAnJyk7XHJcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBtb2RpZmllcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0LnByb21pc2U7XHJcbn07XHJcblxyXG5ub3RpZmljYXRpb24uX2FsZXJ0T3JpZ2luYWwgPSBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zID0ge30pIHtcclxuICB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyAob3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZSkgOiAob3B0aW9ucyA9IG1lc3NhZ2UpO1xyXG5cclxuICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICBidXR0b25MYWJlbDogJ09LJyxcclxuICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxyXG4gICAgdGl0bGU6ICdBbGVydCcsXHJcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7fVxyXG4gIH07XHJcblxyXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsZXJ0IGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2coXHJcbiAgICBvcHRpb25zLnRpdGxlLFxyXG4gICAgb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMubWVzc2FnZUhUTUwsXHJcbiAgICBbb3B0aW9ucy5idXR0b25MYWJlbF0sXHJcbiAgICAwLFxyXG4gICAgb3B0aW9ucy5tb2RpZmllcixcclxuICAgIG9wdGlvbnMuYW5pbWF0aW9uLFxyXG4gICAgb3B0aW9ucy5pZCxcclxuICAgIG9wdGlvbnMuY2FsbGJhY2ssXHJcbiAgICAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLFxyXG4gICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJycsICcnLCBmYWxzZSxcclxuICAgIG9wdGlvbnMuY29tcGlsZVxyXG4gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhbGVydFxyXG4gKiBAc2lnbmF0dXJlIGFsZXJ0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZC5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cclxuICogICBbZW5dQWxlcnQgbWVzc2FnZS5bL2VuXVxyXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgovmloflrZfliJfjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXHJcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UgaW4gSFRNTC5bL2VuXVxyXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxyXG4gKiAgIFtlbl1MYWJlbCBmb3IgY29uZmlybWF0aW9uIGJ1dHRvbi4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxyXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAsIGBcImZhZGVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXHJcbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIElELlsvZW5dXHJcbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cclxuICogICBbZW5dRGlhbG9nIHRpdGxlLiBEZWZhdWx0IGlzIGBcIkFsZXJ0XCJgLlsvZW5dXHJcbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS4iumDqOOBq+ihqOekuuOBmeOCi+OCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQWxlcnRcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cclxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cclxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXHJcbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxyXG4gKlxyXG4gKiAgICAgVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgY2FuIGJlIGVpdGhlciBzaW1wbGUgdGV4dCBvciBIVE1MLlxyXG4gKlxyXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XHJcbiAqXHJcbiAqICAgICBgYGBcclxuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG9wdGlvbnMpO1xyXG4gKiAgICAgYGBgXHJcbiAqXHJcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVxyXG4gKiAgICAg44Om44O844K244O844G444Oh44OD44K744O844K444KS6KaL44Gb44KL44Gf44KB44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXHJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXHJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXHJcbiAqICAgWy9qYV1cclxuICovXHJcbm5vdGlmaWNhdGlvbi5hbGVydCA9IG5vdGlmaWNhdGlvbi5fYWxlcnRPcmlnaW5hbDtcclxuXHJcbm5vdGlmaWNhdGlvbi5fY29uZmlybU9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gKG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2UpIDogKG9wdGlvbnMgPSBtZXNzYWdlKTtcclxuXHJcbiAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxyXG4gICAgcHJpbWFyeUJ1dHRvbkluZGV4OiAxLFxyXG4gICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXHJcbiAgICB0aXRsZTogJ0NvbmZpcm0nLFxyXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge30sXHJcbiAgICBjYW5jZWxhYmxlOiBmYWxzZVxyXG4gIH07XHJcblxyXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICBpZiAoIW9wdGlvbnMubWVzc2FnZSAmJiAhb3B0aW9ucy5tZXNzYWdlSFRNTCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtIGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2coXHJcbiAgICBvcHRpb25zLnRpdGxlLFxyXG4gICAgb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMubWVzc2FnZUhUTUwsXHJcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyxcclxuICAgIG9wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4LFxyXG4gICAgb3B0aW9ucy5tb2RpZmllcixcclxuICAgIG9wdGlvbnMuYW5pbWF0aW9uLFxyXG4gICAgb3B0aW9ucy5pZCxcclxuICAgIG9wdGlvbnMuY2FsbGJhY2ssXHJcbiAgICAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLFxyXG4gICAgb3B0aW9ucy5jYW5jZWxhYmxlLFxyXG4gICAgZmFsc2UsIGZhbHNlLCAnJywgJycsIGZhbHNlLFxyXG4gICAgb3B0aW9ucy5jb21waWxlXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNvbmZpcm1cclxuICogQHNpZ25hdHVyZSBjb25maXJtKG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZC5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cclxuICogICBbZW5dQ29uZmlybWF0aW9uIHF1ZXN0aW9uLlsvZW5dXHJcbiAqICAgW2phXeeiuuiqjeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cclxuICogICBbZW5dRGlhbG9nIGNvbnRlbnQgaW4gSFRNTC5bL2VuXVxyXG4gKiAgIFtqYV3norroqo3jg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxyXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBbXCJDYW5jZWxcIiwgXCJPS1wiXWAuWy9lbl1cclxuICogICBbamFd44Oc44K/44Oz44Gu44Op44OZ44Or44Gu6YWN5YiX44KS5oyH5a6a44GX44G+44GZ44CCW1wiQ2FuY2VsXCIsIFwiT0tcIl3jgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxyXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyBgMWAuWy9lbl1cclxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDEg44Gn44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxyXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIERlZmF1bHQgaXMgYGZhbHNlYC4gSWYgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgY2xpY2tpbmcgdGhlIGJhY2tncm91bmQgb3IgcHJlc3NpbmcgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cclxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxyXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cclxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxyXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXHJcbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJDb25maXJtXCJgLlsvZW5dXHJcbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQ29uZmlybVwi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxyXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxyXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gKiAgIFtlbl1cclxuICogICAgIEZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuXHJcbiAqICAgICBBcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGlzIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1cclxuICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxyXG4gKiAgICAg44GT44Gu6Zai5pWw44Gu5byV5pWw44Go44GX44Gm44CB5oq844GV44KM44Gf44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K55YCk44GM5rih44GV44KM44G+44GZ44CCXHJcbiAqICAgICDjgoLjgZfjg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgZ/loLTlkIjjgavjga8tMeOBjOa4oeOBleOCjOOBvuOBmeOAglxyXG4gKiAgIFsvamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIERpc3BsYXkgYSBkaWFsb2cgdG8gYXNrIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24uXHJcbiAqICAgICBUaGUgZGVmYXVsdCBidXR0b24gbGFiZWxzIGFyZSBgXCJDYW5jZWxcImAgYW5kIGBcIk9LXCJgIGJ1dCB0aGV5IGNhbiBiZSBjdXN0b21pemVkLlxyXG4gKlxyXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XHJcbiAqXHJcbiAqICAgICBgYGBcclxuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShtZXNzYWdlLCBvcHRpb25zKTtcclxuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShvcHRpb25zKTtcclxuICogICAgIGBgYFxyXG4gKlxyXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1cclxuICogICAgIOODpuODvOOCtuOBq+eiuuiqjeOCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxyXG4gKiAgICAg44OH44Kq44Or44Go44Gu44Oc44K/44Oz44Op44OZ44Or44Gv44CBXCJDYW5jZWxcIuOBqFwiT0tcIuOBp+OBmeOBjOOAgeOBk+OCjOOBr+OBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBp+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOBvuOBmeOAglxyXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxyXG4gKiAgIFsvamFdXHJcbiAqL1xyXG5ub3RpZmljYXRpb24uY29uZmlybSA9IG5vdGlmaWNhdGlvbi5fY29uZmlybU9yaWdpbmFsO1xyXG5cclxubm90aWZpY2F0aW9uLl9wcm9tcHRPcmlnaW5hbCA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XHJcblxyXG4gIHZhciBkZWZhdWx0cyA9IHtcclxuICAgIGJ1dHRvbkxhYmVsOiAnT0snLFxyXG4gICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXHJcbiAgICB0aXRsZTogJ0FsZXJ0JyxcclxuICAgIGRlZmF1bHRWYWx1ZTogJycsXHJcbiAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7fSxcclxuICAgIGNhbmNlbGFibGU6IGZhbHNlLFxyXG4gICAgYXV0b2ZvY3VzOiB0cnVlLFxyXG4gICAgc3VibWl0T25FbnRlcjogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb21wdCBkaWFsb2cgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKFxyXG4gICAgb3B0aW9ucy50aXRsZSxcclxuICAgIG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLm1lc3NhZ2VIVE1MLFxyXG4gICAgW29wdGlvbnMuYnV0dG9uTGFiZWxdLFxyXG4gICAgMCxcclxuICAgIG9wdGlvbnMubW9kaWZpZXIsXHJcbiAgICBvcHRpb25zLmFuaW1hdGlvbixcclxuICAgIG9wdGlvbnMuaWQsXHJcbiAgICBvcHRpb25zLmNhbGxiYWNrLFxyXG4gICAgIW9wdGlvbnMubWVzc2FnZSA/IHRydWUgOiBmYWxzZSxcclxuICAgIG9wdGlvbnMuY2FuY2VsYWJsZSxcclxuICAgIHRydWUsXHJcbiAgICBvcHRpb25zLmF1dG9mb2N1cyxcclxuICAgIG9wdGlvbnMucGxhY2Vob2xkZXIsXHJcbiAgICBvcHRpb25zLmRlZmF1bHRWYWx1ZSxcclxuICAgIG9wdGlvbnMuc3VibWl0T25FbnRlcixcclxuICAgIG9wdGlvbnMuY29tcGlsZVxyXG4gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBwcm9tcHRcclxuICogQHNpZ25hdHVyZSBwcm9tcHQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXHJcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGlucHV0IHZhbHVlIHdoZW4gdGhlIGRpYWxvZyBpcyBjbG9zZWQuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cclxuICogICBbZW5dUHJvbXB0IHF1ZXN0aW9uLlsvZW5dXHJcbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cclxuICogICBbZW5dRGlhbG9nIGNvbnRlbnQgaW4gSFRNTC5bL2VuXVxyXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxyXG4gKiAgIFtlbl1MYWJlbCBmb3IgY29uZmlybWF0aW9uIGJ1dHRvbi4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxyXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxyXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyBgMWAuWy9lbl1cclxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDEg44Gn44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxyXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIERlZmF1bHQgaXMgZmFsc2UuIFdoZW4gdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIGl0IHdpbGwgYmUgY2xvc2VkIGlmIHRoZSB1c2VyIHRhcHMgdGhlIGJhY2tncm91bmQgb3IgcHJlc3NlcyB0aGUgQW5kcm9pZCBiYWNrIGJ1dHRvbi5bL2VuXVxyXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gZmFsc2Ug44Gn44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxyXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cclxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxyXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXHJcbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJBbGVydFwiYC5bL2VuXVxyXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gXCJBbGVydFwiIOOBp+OBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cclxuICogICBbZW5dUGxhY2Vob2xkZXIgZm9yIHRoZSB0ZXh0IGlucHV0LlsvZW5dXHJcbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdXHJcbiAqICAgW2VuXURlZmF1bHQgdmFsdWUgZm9yIHRoZSB0ZXh0IGlucHV0LlsvZW5dXHJcbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b2ZvY3VzXVxyXG4gKiAgIFtlbl1BdXRvZm9jdXMgdGhlIGlucHV0IGVsZW1lbnQuIERlZmF1bHQgaXMgYHRydWVgLlsvZW5dXHJcbiAqICAgW2phXWlucHV06KaB57Sg44Gr6Ieq5YuV55qE44Gr44OV44Kp44O844Kr44K544GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cclxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cclxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICogICBbZW5dXHJcbiAqICAgICBGdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlxyXG4gKiAgICAgQXJndW1lbnQgZm9yIHRoZSBmdW5jdGlvbiBpcyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkIG9yIGBudWxsYCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1cclxuICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxyXG4gKiAgICAg6Zai5pWw44Gu5byV5pWw44Go44GX44Gm44CB44Kk44Oz44OX44OD44OI6KaB57Sg44Gu5Lit44Gu5YCk44GM5rih44GV44KM44G+44GZ44CC44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or44GV44KM44Gf5aC05ZCI44Gr44Gv44CBbnVsbOOBjOa4oeOBleOCjOOBvuOBmeOAglxyXG4gKiAgIFsvamFdXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cclxuICogICBbZW5dU3VibWl0IGF1dG9tYXRpY2FsbHkgd2hlbiBlbnRlciBpcyBwcmVzc2VkLiBEZWZhdWx0IGlzIGB0cnVlYC5bL2VuXVxyXG4gKiAgIFtqYV1FbnRlcuOBjOaKvOOBleOCjOOBn+mam+OBq+OBneOBrmZvcm3jgpJzdWJtaXTjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB3aXRoIGEgcHJvbXB0IHRvIGFzayB0aGUgdXNlciBhIHF1ZXN0aW9uLlxyXG4gKlxyXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XHJcbiAqXHJcbiAqICAgICBgYGBcclxuICogICAgIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQob3B0aW9ucyk7XHJcbiAqICAgICBgYGBcclxuICpcclxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdXHJcbiAqICAgICDjg6bjg7zjgrbjg7zjgavlhaXlipvjgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcclxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcclxuICogICBbL2phXVxyXG4gKi9cclxubm90aWZpY2F0aW9uLnByb21wdCA9IG5vdGlmaWNhdGlvbi5fcHJvbXB0T3JpZ2luYWw7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBub3RpZmljYXRpb247XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XHJcblxyXG5jb25zdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiA9IHtcclxuICBfdmFyaWFibGVzOiB7fSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXHJcbiAgICovXHJcbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYWJsZSBuYW1lIG11c3QgYmUgYSBzdHJpbmcuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhb3ZlcndyaXRlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBkZWZpbmVkLmApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgdmFyaWFibGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd8RnVuY3Rpb258bnVsbH1cclxuICAgKi9cclxuICBnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgaWYgKCF0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSB2YXJpYWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxyXG4gICAqL1xyXG4gIHJlbW92ZVZhcmlhYmxlOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgdmFyaWFibGVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldEFsbFZhcmlhYmxlczogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xyXG4gIH0sXHJcbiAgX3BhcnNlUGFydDogZnVuY3Rpb24ocGFydCkge1xyXG4gICAgbGV0IGMsXHJcbiAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxyXG4gICAgICBjdXJyZW50SW5kZXggPSAwO1xyXG5cclxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG5cclxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBlbXB0eSBzdHJpbmcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGMgPSBwYXJ0LmNoYXJBdChpKTtcclxuXHJcbiAgICAgIGlmIChjID09PSAnJCcgJiYgcGFydC5jaGFyQXQoaSArIDEpID09PSAneycpIHtcclxuICAgICAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSk7XHJcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudEluZGV4ID0gaTtcclxuICAgICAgICBpbkludGVycG9sYXRpb24gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGMgPT09ICd9Jykge1xyXG4gICAgICAgIGlmICghaW5JbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ30gbXVzdCBiZSBwcmVjZWVkZWQgYnkgJHsnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSk7XHJcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xyXG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluSW50ZXJwb2xhdGlvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgcGFydC5sZW5ndGgpKTtcclxuXHJcbiAgICByZXR1cm4gdG9rZW5zO1xyXG4gIH0sXHJcbiAgX3JlcGxhY2VUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcclxuICAgIGNvbnN0IHJlID0gL15cXCR7KC4qPyl9JC8sXHJcbiAgICAgIG1hdGNoID0gdG9rZW4ubWF0Y2gocmUpO1xyXG5cclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZ2V0VmFyaWFibGUobmFtZSk7XHJcblxyXG4gICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmlhYmxlIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0LmApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gdmFyaWFibGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcnYgPSB2YXJpYWJsZSgpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHJldHVybiBhIHN0cmluZy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBydjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiB0b2tlbjtcclxuICAgIH1cclxuICB9LFxyXG4gIF9yZXBsYWNlVG9rZW5zOiBmdW5jdGlvbih0b2tlbnMpIHtcclxuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcclxuICB9LFxyXG4gIF9wYXJzZUV4cHJlc3Npb246IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcclxuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcclxuICAgICAgLm1hcChcclxuICAgICAgICBmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApXHJcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXHJcbiAgICAgIC5tYXAodGhpcy5fcmVwbGFjZVRva2Vucy5iaW5kKHRoaXMpKVxyXG4gICAgICAubWFwKChwYXJ0KSA9PiBwYXJ0LmpvaW4oJycpKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gQW4gcGFnZSBhdHRyaWJ1dGUgZXhwcmVzc2lvbi5cclxuICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgKi9cclxuICBldmFsdWF0ZTogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xyXG4gICAgaWYgKCFleHByZXNzaW9uKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIERlZmluZSBkZWZhdWx0IHZhcmlhYmxlcy5cclxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XHJcbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdpT1NEZXZpY2UnLCBwbGF0Zm9ybS5nZXRJT1NEZXZpY2UoKSk7XHJcbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdydW50aW1lJywgKCkgPT4ge1xyXG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XHJcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcclxuXHJcbmNvbnN0IGludGVybmFsID0ge307XHJcblxyXG5pbnRlcm5hbC5jb25maWcgPSB7XHJcbiAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXHJcbiAgYW5pbWF0aW9uc0Rpc2FibGVkOiBmYWxzZVxyXG59O1xyXG5cclxuaW50ZXJuYWwubnVsbEVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4vKipcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xyXG4gIHJldHVybiAhIWludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5pbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTCA9IGh0bWwgPT4ge1xyXG4gIGh0bWwgPSAoJycgKyBodG1sKS50cmltKCk7XHJcblxyXG4gIGlmICghaHRtbC5tYXRjaCgvXjxvbnMtcGFnZS8pKSB7XHJcbiAgICBodG1sID0gJzxvbnMtcGFnZSBfbXV0ZWQ+JyArIGh0bWwgKyAnPC9vbnMtcGFnZT4nO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGh0bWw7XHJcbn07XHJcblxyXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcclxuICBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcclxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2spO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xyXG4gIH1cclxufTtcclxuXHJcbmludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsID0gYWN0aW9uID0+IHtcclxuICBjb25zdCBvblJlYWR5ID0gKCkgPT4ge1xyXG4gICAgaWYgKGludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIoKSkge1xyXG4gICAgICBhY3Rpb24oKTtcclxuICAgIH1cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgb25SZWFkeSk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xyXG4gIH0gZWxzZSBpZiAoWydjb21wbGV0ZScsICdpbnRlcmFjdGl2ZSddLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPT09IC0xKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIG9uUmVhZHkoKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvblJlYWR5KCk7XHJcbiAgfVxyXG59O1xyXG5cclxuaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9ICgpID0+IGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsKCkgJiYgcGxhdGZvcm0uaXNXZWJWaWV3KCkgJiYgcGxhdGZvcm0uaXNJT1M3YWJvdmUoKTtcclxuXHJcbmludGVybmFsLnRlbXBsYXRlU3RvcmUgPSB7XHJcbiAgX3N0b3JhZ2U6IHt9LFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XHJcbiAgICogQHJldHVybiB7U3RyaW5nL251bGx9IHRlbXBsYXRlXHJcbiAgICovXHJcbiAgZ2V0KGtleSkge1xyXG4gICAgcmV0dXJuIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSB8fCBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcclxuICAgKi9cclxuICBzZXQoa2V5LCB0ZW1wbGF0ZSkge1xyXG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldID0gdGVtcGxhdGU7XHJcbiAgfVxyXG59O1xyXG5cclxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ190ZW1wbGF0ZWxvYWRlZCcsIGZ1bmN0aW9uKGUpIHtcclxuICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10ZW1wbGF0ZScpIHtcclxuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KGUudGVtcGxhdGVJZCwgZS50ZW1wbGF0ZSk7XHJcbiAgfVxyXG59LCBmYWxzZSk7XHJcblxyXG53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvb25zLXRlbXBsYXRlXCJdJyk7XHJcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC90ZW1wbGF0ZVwiXScpO1xyXG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIl0nKTtcclxuXHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXIocXVlcnkpIHtcclxuICAgIGNvbnN0IHRlbXBsYXRlcyA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRlbXBsYXRlc1tpXS50ZXh0Q29udGVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59LCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICovXHJcbmludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICBjb25zdCBjYWNoZSA9IGludGVybmFsLnRlbXBsYXRlU3RvcmUuZ2V0KHBhZ2UpO1xyXG5cclxuICAgICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgY29uc3QgaHRtbCA9IHR5cGVvZiBjYWNoZSA9PT0gJ3N0cmluZycgPyBjYWNoZSA6IGNhY2hlWzFdO1xyXG4gICAgICAgIHJlc29sdmUoaHRtbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhZ2UsIHRydWUpO1xyXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgY29uc3QgaHRtbCA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSA0MDAgJiYgeGhyLnN0YXR1cyA8IDYwMCkge1xyXG4gICAgICAgICAgICByZWplY3QoaHRtbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShodG1sKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYWdlIGlzIG5vdCBmb3VuZDogJHtwYWdlfWApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqL1xyXG5pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xyXG4gIGNvbnN0IHBhZ2VzID0gcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZXZhbHVhdGUocGFnZSk7XHJcblxyXG4gIGNvbnN0IGdldFBhZ2UgPSAocGFnZSkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBwYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ011c3Qgc3BlY2lmeSBhIHBhZ2UuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHBhZ2UpXHJcbiAgICAgIC50aGVuKFxyXG4gICAgICAgIGZ1bmN0aW9uKGh0bWwpIHtcclxuICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICBpZiAocGFnZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICApXHJcbiAgICAgIC50aGVuKGh0bWwgPT4gaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCkpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcclxuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL2ludGVybmFsJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yRmFjdG9yeSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYW5pbWF0b3JzIFRoZSBkaWN0aW9uYXJ5IGZvciBhbmltYXRvciBjbGFzc2VzXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmJhc2VDbGFzc05hbWVdIFRoZSBuYW1lIG9mIHRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gbmFtZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcclxuICAgIHRoaXMuX2Jhc2VDbGFzcyA9IG9wdHMuYmFzZUNsYXNzO1xyXG4gICAgdGhpcy5fYmFzZUNsYXNzTmFtZSA9IG9wdHMuYmFzZUNsYXNzTmFtZSB8fCBvcHRzLmJhc2VDbGFzcy5uYW1lO1xyXG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcclxuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGFuaW1hdGlvbjogJyArIHRoaXMuX2FuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xyXG4gICAqIEByZXR1cm4ge09iamVjdC9udWxsfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcoanNvblN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVvZiBqc29uU3RyaW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKGpzb25TdHJpbmcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqL1xyXG4gIHNldEFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dIFRoZSBhbmltYXRpb24gbmFtZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXSBUaGUgYW5pbWF0aW9uIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdEFuaW1hdG9yIFRoZSBkZWZhdWx0IGFuaW1hdG9yIGluc3RhbmNlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBhbmltYXRvciBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIG5ld0FuaW1hdG9yKG9wdGlvbnMgPSB7fSwgZGVmYXVsdEFuaW1hdG9yKSB7XHJcblxyXG4gICAgbGV0IGFuaW1hdG9yID0gbnVsbDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpIHtcclxuICAgICAgcmV0dXJuIG9wdGlvbnMuYW5pbWF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBBbmltYXRvciA9IG51bGw7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgQW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcnNbb3B0aW9ucy5hbmltYXRpb25dO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghQW5pbWF0b3IgJiYgZGVmYXVsdEFuaW1hdG9yKSB7XHJcbiAgICAgIGFuaW1hdG9yID0gZGVmYXVsdEFuaW1hdG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgQW5pbWF0b3IgPSBBbmltYXRvciB8fCB0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXTtcclxuXHJcbiAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSB1dGlsLmV4dGVuZChcclxuICAgICAgICB7fSxcclxuICAgICAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zLFxyXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcclxuICAgICAgICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID8ge2R1cmF0aW9uOiAwLCBkZWxheTogMH0gOiB7fVxyXG4gICAgICApO1xyXG5cclxuICAgICAgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGFuaW1hdG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoYW5pbWF0b3IgaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJhbmltYXRvclwiIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiAnICsgdGhpcy5fYmFzZUNsYXNzTmFtZSArICcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFuaW1hdG9yO1xyXG4gIH1cclxufVxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XHJcbiAgICovXHJcbiAgc3RhdGljIGRpZmYobGFzdCwgY3VycmVudCkge1xyXG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XHJcbiAgICBjdXJyZW50ID0gbWFrZURpY3QoKCcnICsgY3VycmVudCkudHJpbSgpKTtcclxuXHJcbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XHJcbiAgICAgIGlmICghY3VycmVudFt0b2tlbl0pIHtcclxuICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBhZGRlZCA9IE9iamVjdC5rZXlzKGN1cnJlbnQpLnJlZHVjZSgocmVzdWx0LCB0b2tlbikgPT4ge1xyXG4gICAgICBpZiAoIWxhc3RbdG9rZW5dKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHthZGRlZCwgcmVtb3ZlZH07XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZURpY3QobW9kaWZpZXIpIHtcclxuICAgICAgY29uc3QgZGljdCA9IHt9O1xyXG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XHJcbiAgICAgIHJldHVybiBkaWN0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NMaXN0XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIGNsYXNzTGlzdCwgdGVtcGxhdGUpIHtcclxuICAgIGRpZmYuYWRkZWRcclxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxyXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBjbGFzc0xpc3QuYWRkKGtsYXNzKSk7XHJcblxyXG4gICAgZGlmZi5yZW1vdmVkXHJcbiAgICAgIC5tYXAobW9kaWZpZXIgPT4gdGVtcGxhdGUucmVwbGFjZSgvXFwqL2csIG1vZGlmaWVyKSlcclxuICAgICAgLmZvckVhY2goa2xhc3MgPT4gY2xhc3NMaXN0LnJlbW92ZShrbGFzcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhcHBseURpZmZUb0VsZW1lbnQoZGlmZiwgZWxlbWVudCwgc2NoZW1lKSB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gKGUsIHMpID0+IChlLm1hdGNoZXMgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvcikuY2FsbChlLCBzKTtcclxuICAgIGZvciAoY29uc3Qgc2VsZWN0b3IgaW4gc2NoZW1lKSB7XHJcbiAgICAgIGlmIChzY2hlbWUuaGFzT3duUHJvcGVydHkoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSAhc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikgPyBbZWxlbWVudF0gOiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCB0YXJnZXRFbGVtZW50c1tpXS5jbGFzc0xpc3QsIHNjaGVtZVtzZWxlY3Rvcl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXHJcbiAgICovXHJcbiAgc3RhdGljIG9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIGVsZW1lbnQsIHNjaGVtZSkge1xyXG4gICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYobGFzdCwgY3VycmVudCksIGVsZW1lbnQsIHNjaGVtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpbml0TW9kaWZpZXIoZWxlbWVudCwgc2NoZW1lKSB7XHJcbiAgICBjb25zdCBtb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xyXG4gICAgaWYgKHR5cGVvZiBtb2RpZmllciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoe1xyXG4gICAgICByZW1vdmVkOiBbXSxcclxuICAgICAgYWRkZWQ6IE1vZGlmaWVyVXRpbC5zcGxpdChtb2RpZmllcilcclxuICAgIH0sIGVsZW1lbnQsIHNjaGVtZSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc3BsaXQobW9kaWZpZXIpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbW9kaWZpZXIudHJpbSgpLnNwbGl0KC8gKy8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbiAhPT0gJycpO1xyXG4gIH1cclxufVxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XHJcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XHJcblxyXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdERlbGVnYXRlIHtcclxuXHJcbiAgY29uc3RydWN0b3IodXNlckRlbGVnYXRlLCB0ZW1wbGF0ZUVsZW1lbnQgPSBudWxsKSB7XHJcbiAgICBpZiAodHlwZW9mIHVzZXJEZWxlZ2F0ZSAhPT0gJ29iamVjdCcgfHwgdXNlckRlbGVnYXRlID09PSBudWxsKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdXNlckRlbGVnYXRlO1xyXG5cclxuICAgIGlmICghKHRlbXBsYXRlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpICYmIHRlbXBsYXRlRWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBFcnJvcignXCJ0ZW1wbGF0ZUVsZW1lbnRcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50IG9yIG51bGwuJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBnZXQgaXRlbUhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl91c2VyRGVsZWdhdGUuaXRlbUhlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzUmVuZGVyRnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX3JlbmRlcihpdGVtcywgaGVpZ2h0KSB7XHJcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlcihpdGVtcywgaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBBIGZ1bmN0aW9uIHRoYXQgdGFrZSBpdGVtIG9iamVjdCBhcyBwYXJhbWV0ZXIuXHJcbiAgICovXHJcbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBwYXJlbnQsIGRvbmUpIHtcclxuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgcGFyZW50LCBlbGVtZW50ID0+IGRvbmUoe2VsZW1lbnR9KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNyZWF0ZUl0ZW1Db250ZW50KGluZGV4LCB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQpO1xyXG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignY3JlYXRlSXRlbUNvbnRlbnQoKSBtdXN0IHJldHVybiBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGNvdW50SXRlbXMoKSB7XHJcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XHJcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICB0aHJvdyBFcnJvcignY291bnRJdGVtcygpIG11c3QgcmV0dXJuIGEgbnVtYmVyLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxyXG4gICAqL1xyXG4gIHVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pIHtcclxuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQoaW5kZXgsIGl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoaW5kZXgpIHtcclxuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGluZGV4KTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRocm93IEVycm9yKCdjYWxjdWxhdGVJdGVtSGVpZ2h0KCkgbXVzdCByZXR1cm4gYSBudW1iZXIuJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBoZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxyXG4gICAqL1xyXG4gIGRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKSB7XHJcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0UHJvdmlkZXIge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHdyYXBwZXJFbGVtZW50XHJcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iod3JhcHBlckVsZW1lbnQsIGRlbGVnYXRlKSB7XHJcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ1wiZGVsZWdhdGVcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBMYXp5UmVwZWF0RGVsZWdhdGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQgPSB3cmFwcGVyRWxlbWVudDtcclxuICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XHJcblxyXG4gICAgaWYgKHdyYXBwZXJFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0Jykge1xyXG4gICAgICB3cmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYXp5LWxpc3QnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYWdlQ29udGVudCA9IHV0aWwuZmluZFBhcmVudCh3cmFwcGVyRWxlbWVudCwgJy5wYWdlX19jb250ZW50Jyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ucy1sYXp5LXJlcGVhdCBtdXN0IGJlIGEgZGVzY2VuZGFudCBvZiBhbiA8b25zLXBhZ2U+IG9yIGFuIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdG9wUG9zaXRpb25zID0gW107XHJcbiAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0ge307XHJcblxyXG4gICAgaWYgKCF0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0ICYmICF0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KDApKSB7XHJcbiAgICAgIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICB0aGlzLl9vbkNoYW5nZSgpO1xyXG4gIH1cclxuXHJcbiAgX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fZGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KDAsIHRoaXMuX3dyYXBwZXJFbGVtZW50LCBpdGVtID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQ7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX2l0ZW1IZWlnaHQgPSBpdGVtLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmV0cnkgdG8gbWVhc3VyZSBvZmZzZXQgaGVpZ2h0XHJcbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgYW5ndWxhcjIgZGlyZWN0aXZlXHJcbiAgICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eTtcclxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBpZiAodGhpcy5faXRlbUhlaWdodCA9PSAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBzdGF0ZTogdGhpcy5faXRlbUhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gbGFzdFZpc2liaWxpdHk7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YXRpY0l0ZW1IZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCB8fCB0aGlzLl9pdGVtSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgX2NvdW50SXRlbXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY291bnRJdGVtcygpO1xyXG4gIH1cclxuXHJcbiAgX2dldEl0ZW1IZWlnaHQoaSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGljSXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGkpO1xyXG4gIH1cclxuXHJcbiAgX29uQ2hhbmdlKCkge1xyXG4gICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgfVxyXG5cclxuICByZWZyZXNoKCkge1xyXG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcclxuICAgIHRoaXMuX29uQ2hhbmdlKCk7XHJcbiAgfVxyXG5cclxuICBfcmVuZGVyKCkge1xyXG4gICAgaWYgKHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jaGVja0l0ZW1IZWlnaHQodGhpcy5fcmVuZGVyLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNJblZpZXcoKTtcclxuXHJcbiAgICBpZiAodGhpcy5fZGVsZWdhdGUuaGFzUmVuZGVyRnVuY3Rpb24gJiYgdGhpcy5fZGVsZWdhdGUuaGFzUmVuZGVyRnVuY3Rpb24oKSkge1xyXG4gICAgICB0aGlzLl9kZWxlZ2F0ZS5fcmVuZGVyKGl0ZW1zLCB0aGlzLl9saXN0SGVpZ2h0KTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qga2VlcCA9IHt9O1xyXG5cclxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaXRlbSk7XHJcbiAgICAgIGtlZXBbaXRlbS5pbmRleF0gPSB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4ga2VlcFtrZXldIHx8IHRoaXMuX3JlbW92ZUVsZW1lbnQoa2V5KSk7XHJcblxyXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fbGlzdEhlaWdodCArICdweCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtLmluZGV4XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0udG9wXHJcbiAgICovXHJcbiAgX3JlbmRlckVsZW1lbnQoe2luZGV4LCB0b3B9KSB7XHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICB0aGlzLl9kZWxlZ2F0ZS51cGRhdGVJdGVtKGluZGV4LCBpdGVtKTsgLy8gdXBkYXRlIGlmIGl0IGV4aXN0c1xyXG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgdGhpcy5fd3JhcHBlckVsZW1lbnQsIGl0ZW0gPT4ge1xyXG4gICAgICB1dGlsLmV4dGVuZChpdGVtLmVsZW1lbnQuc3R5bGUsIHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IHRvcCArICdweCcsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICByaWdodDogMFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdID0gaXRlbTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgX3JlbW92ZUVsZW1lbnQoaW5kZXgpIHtcclxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcclxuXHJcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XHJcblxyXG4gICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgIGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGl0ZW0uZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgX3JlbW92ZUFsbEVsZW1lbnRzKCkge1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4gdGhpcy5fcmVtb3ZlRWxlbWVudChrZXkpKTtcclxuICB9XHJcblxyXG4gIF9jYWxjdWxhdGVTdGFydEluZGV4KGN1cnJlbnQpIHtcclxuICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICBsZXQgZW5kID0gdGhpcy5faXRlbUNvdW50IC0gMTtcclxuXHJcbiAgICBpZiAodGhpcy5zdGF0aWNJdGVtSGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBwYXJzZUludCgtY3VycmVudCAvIHRoaXMuc3RhdGljSXRlbUhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgaW5kZXggYXQgdG9wIG9mIHNjcmVlbiBzbyB3ZSBjYW4gc3BlZWQgdXAgcmVuZGVyaW5nLlxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50ICsgdGhpcy5fdG9wUG9zaXRpb25zW21pZGRsZV07XHJcblxyXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSAwICYmIHZhbHVlICsgdGhpcy5fZ2V0SXRlbUhlaWdodChtaWRkbGUpID4gMCkge1xyXG4gICAgICAgIHJldHVybiBtaWRkbGU7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID49IDApIHtcclxuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKCkge1xyXG4gICAgY29uc3QgbCA9IE1hdGgubWluKHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgsIHRoaXMuX2l0ZW1Db3VudCk7XHJcbiAgICB0aGlzLl90b3BQb3NpdGlvbnNbMF0gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDEsIGw7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdGhpcy5fdG9wUG9zaXRpb25zW2kgLSAxXSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZ2V0SXRlbXNJblZpZXcoKSB7XHJcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICBjb25zdCBsaW1pdCA9IDQgKiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBvZmZzZXQ7XHJcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2NvdW50SXRlbXMoKTtcclxuXHJcbiAgICBpZiAoY291bnQgIT09IHRoaXMuX2l0ZW1Db3VudCl7XHJcbiAgICAgIHRoaXMuX2l0ZW1Db3VudCA9IGNvdW50O1xyXG4gICAgICB0aGlzLl9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpID0gTWF0aC5tYXgoMCwgdGhpcy5fY2FsY3VsYXRlU3RhcnRJbmRleChvZmZzZXQpIC0gMzApO1xyXG5cclxuICAgIGNvbnN0IGl0ZW1zID0gW107XHJcbiAgICBmb3IgKHZhciB0b3AgPSB0aGlzLl90b3BQb3NpdGlvbnNbaV07IGkgPCBjb3VudCAmJiB0b3AgPCBsaW1pdDsgaSsrKSB7XHJcbiAgICAgIGlmIChpID49IHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgpIHsgLy8gcGVyZiBvcHRpbWl6YXRpb25cclxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xyXG4gICAgICBpdGVtcy5wdXNoKHt0b3AsIGluZGV4OiBpfSk7XHJcbiAgICAgIHRvcCArPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGlzdEhlaWdodCA9IHRvcDtcclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbiAgfVxyXG5cclxuICBfZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XHJcbiAgICBsZXQgdGltZW91dDtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICBpZiAoY2FsbE5vdykge1xyXG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9LCB3YWl0KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIF9kb3VibGVGaXJlT25Ub3VjaGVuZCgpIHtcclxuICAgIHRoaXMuX3JlbmRlcigpO1xyXG4gICAgdGhpcy5fZGVib3VuY2UodGhpcy5fcmVuZGVyLmJpbmQodGhpcyksIDEwMCk7XHJcbiAgfVxyXG5cclxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB1dGlsLmJpbmRMaXN0ZW5lcnModGhpcywgWydfb25DaGFuZ2UnLCAnX2RvdWJsZUZpcmVPblRvdWNoZW5kJ10pO1xyXG5cclxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XHJcbiAgICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9kZWJvdW5jZSh0aGlzLl9ib3VuZE9uQ2hhbmdlLCAzMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcclxuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcclxuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX3JlbW92ZUFsbEVsZW1lbnRzKCk7XHJcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9wYXJlbnRFbGVtZW50ID0gdGhpcy5fZGVsZWdhdGUgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zID0gbnVsbDtcclxuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgfVxyXG59XHJcblxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XHJcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi9hbmltYXRvci1mYWN0b3J5JztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQge0xhenlSZXBlYXRQcm92aWRlciwgTGF6eVJlcGVhdERlbGVnYXRlfSBmcm9tICcuL2xhenktcmVwZWF0JztcclxuXHJcbmludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcclxuaW50ZXJuYWwuTW9kaWZpZXJVdGlsID0gTW9kaWZpZXJVdGlsO1xyXG5pbnRlcm5hbC5MYXp5UmVwZWF0UHJvdmlkZXIgPSBMYXp5UmVwZWF0UHJvdmlkZXI7XHJcbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cclxuICAgKiBAY2F0ZWdvcnkgdXRpbFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXHJcbiAgICogICBbamFd55S76Z2i44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz5qSc55+l44Gu44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gm44GE44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBjb25zdCBvYmogPSB7XHJcbiAgICAvKipcclxuICAgICAqIEBldmVudCBjaGFuZ2VcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZXMuWy9lbl1cclxuICAgICAqICAgW2phXeODh+ODkOOCpOOCueOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNQb3J0cmFpdFxyXG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cclxuICAgICAqICAgW2phXeePvuWcqOOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Gu5aC05ZCI44GrdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgb25cclxuICAgICAqIEBzaWduYXR1cmUgb24oZXZlbnROYW1lLCBsaXN0ZW5lcilcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXHJcbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cclxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cclxuICAgICAqICAgW2phXeOBk+OBruOCpOODmeODs+ODiOOBjOeZuueBq+OBleOCjOOBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgb25jZVxyXG4gICAgICogQHNpZ25hdHVyZSBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQncyBvbmx5IHRyaWdnZXJlZCBvbmNlLlsvZW5dXHJcbiAgICAgKiAgW2phXeS4gOW6puOBoOOBkeWRvOOBs+WHuuOBleOCjOOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXHJcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxyXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxyXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBvZmZcclxuICAgICAqIEBzaWduYXR1cmUgb2ZmKGV2ZW50TmFtZSwgW2xpc3RlbmVyXSlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuIElmIHRoZSBsaXN0ZW5lciBpcyBub3Qgc3BlY2lmaWVkIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5bL2VuXVxyXG4gICAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgILjgoLjgZfjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgarjgYvjgaPjgZ/loLTlkIjjgavjga/jgIHjgZ3jga7jgqTjg5njg7Pjg4jjgavntJDjgaXjgY/lhajjgabjga7jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgYzliYrpmaTjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cclxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cclxuICAgICAqICAgW2phXeWJiumZpOOBmeOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyBhY3R1YWwgaW1wbGVtZW50YXRpb24gdG8gZGV0ZWN0IGlmIHdoZXRoZXIgY3VycmVudCBzY3JlZW4gaXMgcG9ydHJhaXQgb3Igbm90XHJcbiAgICBfaXNQb3J0cmFpdDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcclxuICAgICAqIEBzaWduYXR1cmUgaXNQb3J0cmFpdCgpXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cclxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgb3Igbm90LlsvZW5dXHJcbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICAgKi9cclxuICAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5faXNQb3J0cmFpdCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgaXNMYW5kc2NhcGVcclxuICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgbW9kZS5bL2VuXVxyXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG9yIG5vdC5bL2VuXVxyXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgICAqL1xyXG4gICAgaXNMYW5kc2NhcGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRPTUNvbnRlbnRMb2FkZWQuYmluZCh0aGlzKSwgZmFsc2UpO1xyXG5cclxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCBmYWxzZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfb25ET01Db250ZW50TG9hZGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5faW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbigpO1xyXG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcbiAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xyXG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSAwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDkwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gdGhpcy5faXNQb3J0cmFpdCgpO1xyXG5cclxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGRpbWVuc2lvbnMgdG8gY2hhbmdlIGJlY2F1c2VcclxuICAgICAgLy8gb2YgQW5kcm9pZCBpbmNvbnNpc3RlbmN5LlxyXG4gICAgICBsZXQgbkl0ZXIgPSAwO1xyXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICBuSXRlcisrO1xyXG5cclxuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgY29uc3QgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKChpc1BvcnRyYWl0ICYmIHcgPD0gaCkgfHxcclxuICAgICAgICAgICAoIWlzUG9ydHJhaXQgJiYgdyA+PSBoKSkge1xyXG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuSXRlciA9PT0gNTApIHtcclxuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgMjApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSdW4gb24gbm90IG1vYmlsZSBicm93c2VyLlxyXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBNaWNyb0V2ZW50Lm1peGluKG9iaik7XHJcblxyXG4gIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjcmVhdGUoKS5faW5pdCgpO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuY29uc3Qgc29mdHdhcmVLZXlib2FyZCA9IG5ldyBNaWNyb0V2ZW50KCk7XHJcbnNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcclxuXHJcbmNvbnN0IG9uU2hvdyA9ICgpID0+IHtcclxuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gdHJ1ZTtcclxuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ3Nob3cnKTtcclxufTtcclxuXHJcbmNvbnN0IG9uSGlkZSA9ICgpID0+IHtcclxuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XHJcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdoaWRlJyk7XHJcbn07XHJcblxyXG5jb25zdCBiaW5kRXZlbnRzID0gKCkgPT4ge1xyXG4gIGlmICh0eXBlb2YgS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFydGlubW9zZS9jb3Jkb3ZhLWtleWJvYXJkL2Jsb2IvOTVmM2RhM2EzOGQ4ZjhlMWZhNDFmYmY0MDE0NTM1MmMxMzUzNWEwMC9SRUFETUUubWRcclxuICAgIEtleWJvYXJkLm9uc2hvdyA9IG9uU2hvdztcclxuICAgIEtleWJvYXJkLm9uaGlkZSA9IG9uSGlkZTtcclxuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBLZXlib2FyZC5pc1Zpc2libGV9KTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZHJpZnR5Y28vaW9uaWMtcGx1Z2lucy1rZXlib2FyZC9ibG9iL2NhMjdlY2YvUkVBRE1FLm1kXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIG9uSGlkZSk7XHJcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmlzVmlzaWJsZX0pO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuY29uc3Qgbm9QbHVnaW5FcnJvciA9ICgpID0+IHtcclxuICBjb25zb2xlLndhcm4oJ29ucy1rZXlib2FyZDogQ29yZG92YSBLZXlib2FyZCBwbHVnaW4gaXMgbm90IHByZXNlbnQuJyk7XHJcbn07XHJcblxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcclxuICBpZiAoIWJpbmRFdmVudHMoKSkge1xyXG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtYWN0aXZlXScpIHx8XHJcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtaW5hY3RpdmVdJykpIHtcclxuICAgICAgbm9QbHVnaW5FcnJvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xyXG4gIH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzb2Z0d2FyZUtleWJvYXJkO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xyXG5cclxuXHJcbmNvbnN0IHV0aWwgPSB7XHJcbiAgX3JlYWR5OiBmYWxzZSxcclxuXHJcbiAgX2RvbUNvbnRlbnRMb2FkZWQ6IGZhbHNlLFxyXG5cclxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XHJcbiAgICB1dGlsLl9kb21Db250ZW50TG9hZGVkID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcclxuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xyXG4gICAgICAgIHV0aWwuX3JlYWR5ID0gdHJ1ZTtcclxuICAgICAgfSwgZmFsc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcclxuICAgIGlmICghdGhpcy5fZG9tQ29udGVudExvYWRlZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XHJcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbihmbikge1xyXG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcclxuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4gdXRpbC5fb25ET01Db250ZW50TG9hZGVkKCksIGZhbHNlKTtcclxuXHJcbmNvbnN0IEhhbmRsZXJSZXBvc2l0b3J5ID0ge1xyXG4gIF9zdG9yZToge30sXHJcblxyXG4gIF9nZW5JZDogKCgpID0+IHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIHJldHVybiAoKSA9PiBpKys7XHJcbiAgfSkoKSxcclxuXHJcbiAgc2V0OiBmdW5jdGlvbihlbGVtZW50LCBoYW5kbGVyKSB7XHJcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcclxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XHJcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBoYW5kbGVyO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZF07XHJcbiAgICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xyXG5cclxuICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9zdG9yZVtpZF07XHJcbiAgfSxcclxuXHJcbiAgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcclxuXHJcbiAgICByZXR1cm4gISF0aGlzLl9zdG9yZVtpZF07XHJcbiAgfVxyXG59O1xyXG5cclxuY2xhc3MgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9ib3VuZENhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXHJcbiAgICovXHJcbiAgZW5hYmxlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcclxuICAgICAgdXRpbC5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XHJcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNhYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxyXG4gICAqL1xyXG4gIGRpc2FibGUoKSB7XHJcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XHJcbiAgICAgIHV0aWwucmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xyXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmUgYSAnYmFja2J1dHRvbicgZXZlbnQgbWFudWFsbHkuXHJcbiAgICovXHJcbiAgZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpIHtcclxuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBldmVudC5pbml0RXZlbnQoJ2JhY2tidXR0b24nLCB0cnVlLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgX2NhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2FsbGJhY2spIHtcclxuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVyID0ge1xyXG4gICAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxyXG4gICAgICBfZWxlbWVudDogZWxlbWVudCxcclxuXHJcbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHNldExpc3RlbmVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnNldChlbGVtZW50LCB0aGlzKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KSA9PT0gdGhpcztcclxuICAgICAgfSxcclxuXHJcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGhhbmRsZXIuZW5hYmxlKCk7XHJcblxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XHJcbiAgICBjb25zdCB0cmVlID0gdGhpcy5fY2FwdHVyZVRyZWUoKTtcclxuXHJcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcclxuXHJcbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KTtcclxuICAgIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KGVsZW1lbnQpKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgY2FsbFBhcmVudEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQocGFyZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIF9jYXB0dXJlVHJlZSgpIHtcclxuICAgIHJldHVybiBjcmVhdGVUcmVlKGRvY3VtZW50LmJvZHkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyZWUoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgY2hpbGRyZW46IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5T2YoZWxlbWVudC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uKGNoaWxkRWxlbWVudCkge1xyXG5cclxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKGNoaWxkRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRyZWUoY2hpbGRFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICBpZiAocmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKHJlc3VsdC5lbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xyXG4gICAgICAgIH0pKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFycmF5T2YodGFyZ2V0KSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldFtpXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSkge1xyXG4gICAgcmV0dXJuIGZpbmQodHJlZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZChub2RlKSB7XHJcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBmaW5kKG5vZGUuY2hpbGRyZW5bMF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5lbGVtZW50O1xyXG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcclxuICAgICAgICBpZiAoIWxlZnQpIHtcclxuICAgICAgICAgIHJldHVybiByaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxlZnRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobGVmdCwgJycpLnpJbmRleCwgMTApO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJpZ2h0LCAnJykuekluZGV4LCAxMCk7XHJcblxyXG4gICAgICAgIGlmICghaXNOYU4obGVmdFopICYmICFpc05hTihyaWdodFopKSB7XHJcbiAgICAgICAgICByZXR1cm4gbGVmdFogPiByaWdodFogPyBsZWZ0IDogcmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcHR1cmluZyBiYWNrYnV0dG9uLWhhbmRsZXIgaXMgZmFpbHVyZS4nKTtcclxuICAgICAgfSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIoKTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBvbnNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcclxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcclxuXHJcbmxldCBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcclxuXHJcbi8vIE1vZGlmaWVyc1xyXG5jb25zdCBtb2RpZmllcnNNYXAgPSB7XHJcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcclxuICAnbGlnaHQnOiAnbWF0ZXJpYWwtLWZsYXQnLFxyXG4gICdvdXRsaW5lJzogJ21hdGVyaWFsLS1mbGF0JyxcclxuICAnY3RhJzogJycsXHJcbiAgJ2xhcmdlLS1xdWlldCc6ICdtYXRlcmlhbC0tZmxhdCBsYXJnZScsXHJcbiAgJ2xhcmdlLS1jdGEnOiAnbGFyZ2UnLFxyXG4gICdub2JvcmRlcic6ICcnLFxyXG4gICdjaGV2cm9uJzogJycsXHJcbiAgJ3RhcHBhYmxlJzogJydcclxufTtcclxuXHJcbmNvbnN0IHBsYXRmb3JtcyA9IHt9O1xyXG5cclxucGxhdGZvcm1zLmFuZHJvaWQgPSBlbGVtZW50ID0+IHtcclxuXHJcbiAgaWYgKCEvb25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtcHJvZ3Jlc3MvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmXHJcbiAgICAhL21hdGVyaWFsLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSkge1xyXG5cclxuICAgIGNvbnN0IG9sZE1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XHJcblxyXG4gICAgY29uc3QgbmV3TW9kaWZpZXIgPSBvbGRNb2RpZmllci50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkoZSkgPyBtb2RpZmllcnNNYXBbZV0gOiBlKTtcclxuICAgIG5ld01vZGlmaWVyLnVuc2hpZnQoJ21hdGVyaWFsJyk7XHJcblxyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXIuam9pbignICcpLnRyaW0oKSk7XHJcbiAgfVxyXG5cclxuICAvLyBFZmZlY3RzXHJcbiAgaWYgKC9vbnMtYnV0dG9ufG9ucy1saXN0LWl0ZW18b25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtdGFiJC8udGVzdChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcclxuICAgICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJylcclxuICAgICYmICF1dGlsLmZpbmRDaGlsZChlbGVtZW50LCAnb25zLXJpcHBsZScpKSB7XHJcblxyXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QtaXRlbScpIHtcclxuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpKSB7XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFwcGFibGUnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5wbGF0Zm9ybXMuaW9zID0gZWxlbWVudCA9PiB7XHJcblxyXG4gLy8gTW9kaWZpZXJzXHJcbiBpZiAoL21hdGVyaWFsLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSkge1xyXG4gICB1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpO1xyXG5cclxuICAgaWYgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsLS1mbGF0JykpIHtcclxuICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdsYXJnZScpKSA/ICdsYXJnZS0tcXVpZXQnIDogJ3F1aWV0Jyk7XHJcbiAgIH1cclxuXHJcbiAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcclxuICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcclxuICAgfVxyXG4gfVxyXG5cclxuIC8vIEVmZmVjdHNcclxuIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcclxuICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QtaXRlbScpIHtcclxuICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XHJcbiAgIH1cclxuXHJcbiAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcclxuIH1cclxufTtcclxuXHJcbmNvbnN0IHVubG9ja2VkID0ge1xyXG4gIGFuZHJvaWQ6IHRydWVcclxufTtcclxuXHJcbmNvbnN0IHByZXBhcmVBdXRvU3R5bGUgPSAoZWxlbWVudCwgZm9yY2UpID0+IHtcclxuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcclxuICAgIGNvbnN0IG1vYmlsZU9TID0gb25zUGxhdGZvcm0uZ2V0TW9iaWxlT1MoKTtcclxuICAgIGlmIChwbGF0Zm9ybXMuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpICYmICh1bmxvY2tlZC5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgfHwgZm9yY2UpKSB7XHJcbiAgICAgIHBsYXRmb3Jtc1ttb2JpbGVPU10oZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGlzRW5hYmxlZDogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCxcclxuICBlbmFibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlLFxyXG4gIGRpc2FibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSBmYWxzZSxcclxuICBwcmVwYXJlOiBwcmVwYXJlQXV0b1N0eWxlXHJcbn07XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBpID0gMDtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gaSsrO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogRG9vciBsb2NraW5nIHN5c3RlbS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2ddXHJcbiAqL1xyXG5jbGFzcyBEb29yTG9jayB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5fbG9ja0xpc3QgPSBbXTtcclxuICAgIHRoaXMuX3dhaXRMaXN0ID0gW107XHJcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYSBsb2NrLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXHJcbiAgICovXHJcbiAgbG9jaygpIHtcclxuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcclxuICAgICAgdGhpcy5fdW5sb2NrKHVubG9jayk7XHJcbiAgICB9O1xyXG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xyXG4gICAgdGhpcy5fbG9ja0xpc3QucHVzaCh1bmxvY2spO1xyXG4gICAgdGhpcy5fbG9nKCdsb2NrOiAnICsgKHVubG9jay5pZCkpO1xyXG5cclxuICAgIHJldHVybiB1bmxvY2s7XHJcbiAgfVxyXG5cclxuICBfdW5sb2NrKGZuKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2tMaXN0LmluZGV4T2YoZm4pO1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIGxvY2sgbGlzdC4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9sb2NrTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgdGhpcy5fbG9nKCd1bmxvY2s6ICcgKyBmbi5pZCk7XHJcblxyXG4gICAgdGhpcy5fdHJ5VG9GcmVlV2FpdExpc3QoKTtcclxuICB9XHJcblxyXG4gIF90cnlUb0ZyZWVXYWl0TGlzdCgpIHtcclxuICAgIHdoaWxlICghdGhpcy5pc0xvY2tlZCgpICYmIHRoaXMuX3dhaXRMaXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3Igd2FpdGluZyB1bmxvY2tlZCBkb29yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtcyB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIG9uIHVubG9ja2luZyB0aGUgZG9vciBjb21wbGV0ZWx5LlxyXG4gICAqL1xyXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcclxuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNhbGxiYWNrIHBhcmFtIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XHJcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNMb2NrZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9ja0xpc3QubGVuZ3RoID4gMDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERvb3JMb2NrO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5jb25zdCByZWFkeU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbmZ1bmN0aW9uIGlzQ29udGVudFJlYWR5KGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlYWR5TWFwLmhhcyhlbGVtZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpIHtcclxuICByZWFkeU1hcC5zZXQoZWxlbWVudCwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKSB7XHJcbiAgaWYgKCFxdWV1ZU1hcC5oYXMoZWxlbWVudCkpIHtcclxuICAgIHF1ZXVlTWFwLnNldChlbGVtZW50LCBbXSk7XHJcbiAgfVxyXG4gIHF1ZXVlTWFwLmdldChlbGVtZW50KS5wdXNoKGZuKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3VtZVF1ZXVlKGVsZW1lbnQpIHtcclxuICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZU1hcC5nZXQoZWxlbWVudCwgW10pIHx8IFtdO1xyXG4gIHF1ZXVlTWFwLmRlbGV0ZShlbGVtZW50KTtcclxuICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGVudFJlYWR5KGVsZW1lbnQsIGZuKSB7XHJcbiAgYWRkQ2FsbGJhY2soZWxlbWVudCwgZm4pO1xyXG5cclxuICBpZiAoaXNDb250ZW50UmVhZHkoZWxlbWVudCkpIHtcclxuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XHJcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XHJcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XHJcbiAgfSk7XHJcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XHJcblxyXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cclxuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xyXG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xyXG4gIH0pO1xyXG59XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xyXG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XHJcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcclxuaW1wb3J0IG5vdGlmaWNhdGlvbiBmcm9tICcuL25vdGlmaWNhdGlvbic7XHJcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcclxuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4vb3JpZW50YXRpb24nO1xyXG5pbXBvcnQgc29mdHdhcmVLZXlib2FyZCBmcm9tICcuL3NvZnR3YXJlLWtleWJvYXJkJztcclxuaW1wb3J0IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XHJcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcclxuaW1wb3J0IGFuaW1hdGlvbk9wdGlvbnNQYXJzZXIgZnJvbSAnLi9hbmltYXRpb24tb3B0aW9ucy1wYXJzZXInO1xyXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcclxuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4vZG9vcmxvY2snO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XHJcblxyXG4vKipcclxuICogQG9iamVjdCBvbnNcclxuICogQGNhdGVnb3J5IHV0aWxcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2phXU9uc2VuIFVJ44Gn5Yip55So44Gn44GN44KL44Kw44Ot44O844OQ44Or44Gq44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cclxuICogICBbZW5dQSBnbG9iYWwgb2JqZWN0IHRoYXQncyB1c2VkIGluIE9uc2VuIFVJLiBbL2VuXVxyXG4gKi9cclxuY29uc3Qgb25zID0ge307XHJcblxyXG5vbnMuX3V0aWwgPSB1dGlsO1xyXG5vbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXI7XHJcbm9ucy5faW50ZXJuYWwgPSBpbnRlcm5hbDtcclxub25zLkdlc3R1cmVEZXRlY3RvciA9IEdlc3R1cmVEZXRlY3Rvcjtcclxub25zLnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbm9ucy5zb2Z0d2FyZUtleWJvYXJkID0gc29mdHdhcmVLZXlib2FyZDtcclxub25zLnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0gUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb247XHJcbm9ucy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG5vbnMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xyXG5vbnMuX2FuaW1hdGlvbk9wdGlvbnNQYXJzZXIgPSBhbmltYXRpb25PcHRpb25zUGFyc2VyO1xyXG5vbnMuX2F1dG9TdHlsZSA9IGF1dG9TdHlsZTtcclxub25zLl9Eb29yTG9jayA9IERvb3JMb2NrO1xyXG5vbnMuX2NvbnRlbnRSZWFkeSA9IGNvbnRlbnRSZWFkeTtcclxuXHJcbm9ucy5fcmVhZHlMb2NrID0gbmV3IERvb3JMb2NrKCk7XHJcblxyXG5vbnMucGxhdGZvcm0uc2VsZWN0KCh3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9wbGF0Zm9ybT0oW1xcdy1dKykvKSB8fCBbXSlbMV0pO1xyXG5cclxud2FpdERldmljZVJlYWR5KCk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpc1JlYWR5XHJcbiAqIEBzaWduYXR1cmUgaXNSZWFkeSgpXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxyXG4gKiAgIFtqYV3liJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dUmV0dXJucyB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXHJcbiAqICAgW2phXU9uc2VuIFVJ44GM44GZ44Gn44Gr5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cclxuICovXHJcbm9ucy5pc1JlYWR5ID0gKCkgPT4ge1xyXG4gIHJldHVybiAhb25zLl9yZWFkeUxvY2suaXNMb2NrZWQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xyXG4gKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxyXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxyXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cclxuICovXHJcbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcmVhZHlcclxuICogQHNpZ25hdHVyZSByZWFkeShjYWxsYmFjaylcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cclxuICogICBbZW5dTWV0aG9kIHVzZWQgdG8gd2FpdCBmb3IgYXBwIGluaXRpYWxpemF0aW9uLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdW50aWwgT25zZW4gVUkgaGFzIGJlZW4gY29tcGxldGVseSBpbml0aWFsaXplZC5bL2VuXVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXHJcbiAqICAgW2phXU9uc2VuIFVJ44GM5Yid5pyf5YyW44GM5a6M5LqG44GX44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICovXHJcbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcclxuICBpZiAob25zLmlzUmVhZHkoKSkge1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb25zLl9yZWFkeUxvY2sud2FpdFVubG9jayhjYWxsYmFjayk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxyXG4gKiBAc2lnbmF0dXJlIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIobGlzdGVuZXIpXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC5bL2VuXVxyXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgYzmirzjgZXjgozjgZ/mmYLjgavlrp/ooYzjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dU2V0IGRlZmF1bHQgaGFuZGxlciBmb3IgZGV2aWNlIGJhY2sgYnV0dG9uLlsvZW5dXHJcbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOBn+OCgeOBruODh+ODleOCqeODq+ODiOOBruODj+ODs+ODieODqeOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXHJcbiAqL1xyXG5vbnMuc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIuc2V0TGlzdGVuZXIobGlzdGVuZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXHJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFtlbl1EaXNhYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLlsvZW5dXHJcbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgarjgYTjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxyXG4gKi9cclxub25zLmRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcclxuICogQHNpZ25hdHVyZSBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBbZW5dRW5hYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLlsvZW5dXHJcbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgovjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxyXG4gKi9cclxub25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5lbmFibGUoKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbFxyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXUVuYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxyXG4gKiAgIFtqYV1pT1M35Lul5LiK44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cclxuICovXHJcbm9ucy5lbmFibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcclxuICBpZiAob25zLmlzUmVhZHkoKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xyXG4gIH1cclxuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbCA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcclxuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxyXG4gKiAgIFtqYV1pT1M35Lul5LiK44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS54Sh5Yq544Gr44GX44G+44GZ44CCWy9qYV1cclxuICovXHJcbm9ucy5kaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XHJcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcclxuICB9XHJcbiAgb25zLl9pbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGRpc2FibGVBbmltYXRpb25zXHJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dRGlzYWJsZSBhbGwgYW5pbWF0aW9ucy4gQ291bGQgYmUgaGFuZHkgZm9yIHRlc3RpbmcgYW5kIG9sZGVyIGRldmljZXMuWy9lbl1cclxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cclxuICovXHJcbm9ucy5kaXNhYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcclxuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZW5hYmxlQW5pbWF0aW9uc1xyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUFuaW1hdGlvbnMoKVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dRW5hYmxlIGFuaW1hdGlvbnMgKGRlZmF1bHQpLlsvZW5dXHJcbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAqL1xyXG5vbnMuZW5hYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcclxuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3R5bGluZ1xyXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBdXRvU3R5bGluZygpXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1EaXNhYmxlIGF1dG9tYXRpYyBzdHlsaW5nLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqL1xyXG5vbnMuZGlzYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZGlzYWJsZTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXHJcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0eWxpbmcoKVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKi9cclxub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZW5hYmxlO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcclxuICogQHNpZ25hdHVyZSBmb3JjZVBsYXRmb3JtU3R5bGluZyhwbGF0Zm9ybSlcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybSBOZXcgcGxhdGZvcm0gdG8gc3R5bGUgdGhlIGVsZW1lbnRzLlxyXG4gKi9cclxub25zLmZvcmNlUGxhdGZvcm1TdHlsaW5nID0gbmV3UGxhdGZvcm0gPT4ge1xyXG4gIG9ucy5lbmFibGVBdXRvU3R5bGluZygpO1xyXG4gIG9ucy5wbGF0Zm9ybS5zZWxlY3QobmV3UGxhdGZvcm0gfHwgJ2lvcycpO1xyXG5cclxuICBvbnMuX3V0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcclxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWlmJykge1xyXG4gICAgICAgIGVsZW1lbnQuX3BsYXRmb3JtVXBkYXRlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLm1hdGNoKC9eb25zLS9pKSkge1xyXG4gICAgICAgIG9ucy5fYXV0b1N0eWxlLnByZXBhcmUoZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcclxuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqL1xyXG5vbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuICBpZiAoIXBhZ2UpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xyXG4gICAgaHRtbCA9IGh0bWwubWF0Y2goLzxvbnMtcG9wb3Zlci9naSkgPyBgPGRpdj4ke2h0bWx9PC9kaXY+YCA6IGA8b25zLXBvcG92ZXI+JHtodG1sfTwvb25zLXBvcG92ZXI+YDtcclxuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xyXG5cclxuICAgIGNvbnN0IHBvcG92ZXIgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLXBvcG92ZXInKTtcclxuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUocG9wb3Zlcik7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXIpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICBvcHRpb25zLmxpbmsocG9wb3Zlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvcG92ZXI7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjcmVhdGVQb3BvdmVyXHJcbiAqIEBzaWduYXR1cmUgY3JlYXRlUG9wb3ZlcihwYWdlLCBbb3B0aW9uc10pXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXHJcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cclxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXHJcbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJlbnRTY29wZV1cclxuICogICBbZW5dUGFyZW50IHNjb3BlIG9mIHRoZSBkaWFsb2cuIFVzZWQgdG8gYmluZCBtb2RlbHMgYW5kIGFjY2VzcyBzY29wZSBtZXRob2RzIGZyb20gdGhlIGRpYWxvZy5bL2VuXVxyXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cclxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1DcmVhdGUgYSBwb3BvdmVyIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxyXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxyXG4gKi9cclxub25zLmNyZWF0ZVBvcG92ZXIgPSBvbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqL1xyXG5vbnMuX2NyZWF0ZURpYWxvZ09yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG4gIGlmICghcGFnZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHVybCBtdXN0IGJlIGRlZmluZWQuJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XHJcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1kaWFsb2c+JHtodG1sfTwvb25zLWRpYWxvZz5gO1xyXG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XHJcblxyXG4gICAgY29uc3QgZGlhbG9nID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1kaWFsb2cnKTtcclxuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoZGlhbG9nKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgb3B0aW9ucy5saW5rKGRpYWxvZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpYWxvZztcclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNyZWF0ZURpYWxvZ1xyXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZURpYWxvZyhwYWdlLCBbb3B0aW9uc10pXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXHJcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cclxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXHJcbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxyXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxyXG4gKi9cclxub25zLmNyZWF0ZURpYWxvZyA9IG9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWw7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gKi9cclxub25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG4gIGlmICghcGFnZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHVybCBtdXN0IGJlIGRlZmluZWQuJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XHJcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1hbGVydC1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1hbGVydC1kaWFsb2c+JHtodG1sfTwvb25zLWFsZXJ0LWRpYWxvZz5gO1xyXG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XHJcblxyXG4gICAgY29uc3QgYWxlcnREaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWFsZXJ0LWRpYWxvZycpO1xyXG4gICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShhbGVydERpYWxvZyk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFsZXJ0RGlhbG9nKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgb3B0aW9ucy5saW5rKGFsZXJ0RGlhbG9nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWxlcnREaWFsb2c7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjcmVhdGVBbGVydERpYWxvZ1xyXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZUFsZXJ0RGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcclxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1hbGVydC1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxyXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgYWxlcnQgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cclxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1DcmVhdGUgYSBhbGVydCBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXHJcbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXHJcbiAqL1xyXG5vbnMuY3JlYXRlQWxlcnREaWFsb2cgPSBvbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWw7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua1xyXG4gKi9cclxub25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBsaW5rKSB7XHJcbiAgY29uc3QgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xyXG5cclxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgZWxlbWVudHNcclxuICAgICAgLmZpbHRlcihlbGVtZW50ID0+ICFlbGVtZW50LmdldEF0dHJpYnV0ZSgncGFnZScpKVxyXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnb25zLWxvYWRpbmctcGxhY2Vob2xkZXInLCBwYWdlKTtcclxuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XHJcbiAgICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cy4nKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyXHJcbiAqIEBzaWduYXR1cmUgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihwYWdlKVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxyXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGVsZW1lbnQuWy9lbl1cclxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXUlmIG5vIHBhZ2UgaXMgZGVmaW5lZCBmb3IgdGhlIGBvbnMtbG9hZGluZy1wbGFjZWhvbGRlcmAgYXR0cmlidXRlIGl0IHdpbGwgd2FpdCBmb3IgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIHRoZSBwYWdlLlsvZW5dXHJcbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxyXG4gKi9cclxub25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJPcmlnaW5hbDtcclxuXHJcbm9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgb25zLnJlYWR5KCgpID0+IHtcclxuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcclxuXHJcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59O1xyXG5cclxub25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24oZWxlbWVudCwgcGFnZSwgbGluaykge1xyXG4gIGxpbmsgPSBsaW5rIHx8IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHsgZG9uZSgpOyB9O1xyXG4gIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xyXG5cclxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XHJcbiAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudEVsZW1lbnQpO1xyXG5cclxuICAgIGxpbmsoY29udGVudEVsZW1lbnQsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB9KTtcclxuXHJcbiAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGVkIHRvIHJlc29sdmUgcGxhY2Vob2xkZXI6ICcgKyBlcnJvcik7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XHJcbiAgY29uc3QgdW5sb2NrRGV2aWNlUmVhZHkgPSBvbnMuX3JlYWR5TG9jay5sb2NrKCk7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ1dlYkNvbXBvbmVudHNSZWFkeScsICgpID0+IHtcclxuICAgIGlmIChvbnMuaXNXZWJWaWV3KCkpIHtcclxuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgdW5sb2NrRGV2aWNlUmVhZHksIGZhbHNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XHJcbiAgICB9XHJcbiAgfSwgZmFsc2UpO1xyXG59XHJcblxyXG53aW5kb3cuX3N1cGVyU2VjcmV0T25zID0gb25zO1xyXG5leHBvcnQgZGVmYXVsdCBvbnM7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoKSB7XHJcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY29uc3QgQmFzZUVsZW1lbnQgPSAoKSA9PiB7fTtcclxuICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgcmV0dXJuIEJhc2VFbGVtZW50O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRWxlbWVudCBleHRlbmRzIGdldEVsZW1lbnRDbGFzcygpIHtcclxufVxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy10ZW1wbGF0ZVxyXG4gKiBAY2F0ZWdvcnkgdGVtcGxhdGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgRGVmaW5lIGEgc2VwYXJhdGUgSFRNTCBmcmFnbWVudCBhbmQgdXNlIGFzIGEgdGVtcGxhdGUuXHJcbiAqXHJcbiAqICAgICBUaGVzZSB0ZW1wbGF0ZXMgY2FuIGJlIGxvYWRlZCBhcyBwYWdlcyBpbiBgPG9ucy1uYXZpZ2F0b3I+YCwgYDxvbnMtdGFiYmFyPmAgYW5kIGA8b25zLXNwbGl0dGVyPmAuIFRoZXkgY2FuIGFsc28gYmUgdXNlZCB0byBnZW5lcmF0ZSBkaWFsb2dzLlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBqOOBl+OBpuS9v+eUqOOBmeOCi+OBn+OCgeOBrkhUTUzjg5Xjg6njgrDjg6Hjg7Pjg4jjgpLlrprnvqnjgZfjgb7jgZnjgILjgZPjga7opoHntKDjgadIVE1M44KS5a6j6KiA44GZ44KL44Go44CBaWTlsZ7mgKfjgavmjIflrprjgZfjgZ/lkI3liY3jgpJwYWdl44GuVVJM44Go44GX44Gmb25zLW5hdmlnYXRvcuOBquOBqeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBi+OCieWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXHJcbiAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcclxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxyXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcclxuICogICBbZW5dVGhlIGA8b25zLW5hdmlnYXRvcj5gIGNvbXBvbmVudCBlbmFibGVzIHN0YWNrIGJhc2VkIG5hdmlnYXRpb24uWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQHNlZWFsc28gb25zLXRhYmJhclxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gYWRkIHRhYiBuYXZpZ2F0aW9uLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgZHJhZ2dhYmxlIG1lbnUgb3IgY29sdW1uIGJhc2VkIGxheW91dC5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cclxuICogICA8b25zLXBhZ2U+XHJcbiAqICAgICBQYWdlIGNvbnRlbnRcclxuICogICA8L29ucy1wYWdlPlxyXG4gKiA8L29ucy10ZW1wbGF0ZT5cclxuICpcclxuICogPG9ucy1uYXZpZ2F0b3IgcGFnZT1cImZvb2Jhci5odG1sXCI+XHJcbiAqIDwvb25zLW5hdmlnYXRvcj5cclxuICovXHJcbmNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXHJcbiAgICogIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLmlubmVySFRNTDtcclxuXHJcbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ190ZW1wbGF0ZWxvYWRlZCcsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XHJcbiAgICBldmVudC50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XHJcbiAgICBldmVudC50ZW1wbGF0ZUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNUZW1wbGF0ZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy10ZW1wbGF0ZScsIHtcclxuICBwcm90b3R5cGU6IFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnb25zL29yaWVudGF0aW9uJztcclxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLWlmXHJcbiAqIEBjYXRlZ29yeSBjb25kaXRpb25hbFxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWZcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgQ29uZGl0aW9uYWxseSBkaXNwbGF5IGNvbnRlbnQgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSwgZGV2aWNlIG9yaWVudGF0aW9uIG9yIGJvdGguXHJcbiAqXHJcbiAqICAgICBTb21ldGltZXMgaXQgaXMgdXNlZnVsIHRvIGNvbmRpdGlvbmFsbHkgaGlkZSBvciBzaG93IGNlcnRhaW4gY29tcG9uZW50cyBiYXNlZCBvbiBwbGF0Zm9ybS4gV2hlbiBydW5uaW5nIG9uIGlPUyB0aGUgYDxvbnMtaWY+YCBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGhpZGUgdGhlIGA8b25zLWZhYj5gIGVsZW1lbnQuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGd1aWRlIFV0aWxpdHlBUElzXHJcbiAqICAgW2VuXU90aGVyIHV0aWxpdHkgQVBJc1svZW5dXHJcbiAqICAgW2phXeS7luOBruODpuODvOODhuOCo+ODquODhuOCo0FQSVsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtcGFnZT5cclxuICogICA8b25zLWlmIG9yaWVudGF0aW9uPVwibGFuZHNjYXBlXCI+XHJcbiAqICAgICBMYW5kc2NhcGUgdmlldyFcclxuICogICA8L29ucy1pZj5cclxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiYW5kcm9pZFwiPlxyXG4gKiAgICAgVGhpcyBpcyBBbmRyb2lkLlxyXG4gKiAgIDwvb25zLWlmPlxyXG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJpb3Mgb3RoZXJcIj5cclxuICogICAgIFRoaXMgaXMgbm90IEFuZHJvaWQuXHJcbiAqICAgPC9vbnMtaWY+XHJcbiAqIDwvb25zLXBhZ2U+XHJcbiAqL1xyXG5jbGFzcyBDb25kaXRpb25hbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgcGxhdGZvcm1cclxuICAgKiBAaW5pdG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BhY2Utc2VwYXJhdGVkIHBsYXRmb3JtIG5hbWVzLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImlvc1wiYCwgYFwiYW5kcm9pZFwiYCwgYFwid2luZG93c1wiYCBhbmQgYFwib3RoZXJcImAuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgb3JpZW50YXRpb25cclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dRWl0aGVyIGBcInBvcnRyYWl0XCJgIG9yIGBcImxhbmRzY2FwZVwiYC5bL2VuXVxyXG4gICAqICBbamFdcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZfjgb7jgZlbL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICBpZiAocGxhdGZvcm0uX3JlbmRlclBsYXRmb3JtICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcclxuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcclxuICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcclxuICAgIGlmIChuYW1lID09PSAnb3JpZW50YXRpb24nKSB7XHJcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xyXG4gIH1cclxuXHJcbiAgX3BsYXRmb3JtVXBkYXRlKCkge1xyXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSA/ICcnIDogJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgX2lzQWxsb3dlZFBsYXRmb3JtKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcclxuICB9XHJcblxyXG4gIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xyXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvcmllbnRhdGlvbicpICYmIHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcclxuICAgICAgY29uc3QgY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcmllbnRhdGlvbicpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKSA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcclxuXHJcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IChjb25kaXRpb25hbE9yaWVudGF0aW9uID09PSBjdXJyZW50T3JpZW50YXRpb24pID8gJycgOiAnbm9uZSc7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zQ29uZGl0aW9uYWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtaWYnLCB7XHJcbiAgcHJvdG90eXBlOiBDb25kaXRpb25hbEVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuZXhwb3J0IGNsYXNzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcclxuICAgIHRoaXMudGltaW5nID0gdGltaW5nO1xyXG4gICAgdGhpcy5kZWxheSA9IGRlbGF5O1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxyXG4gICAqL1xyXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XHJcbiAgICBkb25lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXHJcbiAgICovXHJcbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcclxuICAgIGRvbmUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XHJcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDAuOSwgMC45LCAxLjApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDAuOSwgMC45LCAxLjApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJT1NBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZHVyYXRpb24gPSAwLjIsIGRlbGF5ID0gMH0gPSB7fSkge1xyXG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XHJcbmltcG9ydCB7QWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xyXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcclxuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XHJcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xyXG5cclxuY29uc3Qgc2NoZW1lID0ge1xyXG4gICcuYWxlcnQtZGlhbG9nJzogJ2FsZXJ0LWRpYWxvZy0tKicsXHJcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxyXG4gICcuYWxlcnQtZGlhbG9nLXRpdGxlJzogJ2FsZXJ0LWRpYWxvZy10aXRsZS0tKicsXHJcbiAgJy5hbGVydC1kaWFsb2ctY29udGVudCc6ICdhbGVydC1kaWFsb2ctY29udGVudC0tKicsXHJcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxyXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcclxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLW9uZSc6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUtLSonLFxyXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLW9uZS0tKicsXHJcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsLS0qJyxcclxuICAnLmFsZXJ0LWRpYWxvZy1tYXNrJzogJ2FsZXJ0LWRpYWxvZy1tYXNrLS0qJ1xyXG59O1xyXG5cclxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcclxuICAnbm9uZSc6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXHJcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIDogSU9TQWxlcnREaWFsb2dBbmltYXRvcixcclxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXHJcbn07XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLWFsZXJ0LWRpYWxvZ1xyXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIEFsZXJ0IGRpYWxvZyB0aGF0IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgc2NyZWVuLiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgcXVlc3Rpb25zLCB3YXJuaW5ncyBvciBlcnJvciBtZXNzYWdlcyB0byB0aGUgdXNlci4gVGhlIHRpdGxlLCBjb250ZW50IGFuZCBidXR0b25zIGNhbiBiZSBlYXNpbHkgY3VzdG9taXplZCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHN3aXRjaCBzdHlsZSBiYXNlZCBvbiB0aGUgcGxhdGZvcm0uXHJcbiAqXHJcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVBbGVydERpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAY29kZXBlbiBRd3d4eXBcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcclxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGd1aWRlIFVzaW5nQWxlcnRcclxuICogICBbZW5dTGVhcm4gaG93IHRvIHVzZSB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXHJcbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS9v+OBhOaWueOBruino+iqrOOAglsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1kaWFsb2dcclxuICogICBbZW5db25zLWRpYWxvZyBjb21wb25lbnRbL2VuXVxyXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQHNlZWFsc28gb25zLXBvcG92ZXJcclxuICogICBbZW5db25zLXBvcG92ZXIgY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy5ub3RpZmljYXRpb25cclxuICogICBbZW5dVXNpbmcgb25zLm5vdGlmaWNhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5bL2VuXVxyXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1hbGVydC1kaWFsb2cgaWQ9XCJhbGVydC1kaWFsb2dcIj5cclxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cclxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRlbnRcIj5cclxuICogICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcclxuICogICA8L2Rpdj5cclxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWZvb3RlclwiPlxyXG4gKiAgICAgPGJ1dHRvbiBpZD1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj5PSzwvYnV0dG9uPlxyXG4gKiAgIDwvZGl2PlxyXG4gKiA8L29ucy1hbGVydC1kaWFsb2c+XHJcbiAqIDxzY3JpcHQ+XHJcbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FsZXJ0LWRpYWxvZycpLnNob3coKTtcclxuICogPC9zY3JpcHQ+XHJcbiAqL1xyXG5jbGFzcyBBbGVydERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVzaG93XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXHJcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXHJcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644KS5q2i44KB44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHBvc3RzaG93XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcclxuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHByZWhpZGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxyXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcclxuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcclxuICAgKiAgIFtlbl1FeGVjdXRlIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGhpZGluZy5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCiOOBhuOBqOOBmeOCi+OBruOCkuatouOCgeOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwb3N0aGlkZVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXHJcbiAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcclxuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXHJcbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXHJcbiAgICogIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxyXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlZmF1bHQgZGVmYXVsdFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXHJcbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjgafjga9cIm5vbmVcIuOBi1wiZGVmYXVsdFwi44GM5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xyXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXHJcbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIi5bL2VuXVxyXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0IF9tYXNrKCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nLW1hc2snKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0IF9kaWFsb2coKSB7XHJcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2cnKTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldCBfdGl0bGVFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctdGl0bGUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcclxuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xyXG5cclxuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XHJcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcclxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xyXG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXHJcbiAgICAgIGJhc2VDbGFzczogQWxlcnREaWFsb2dBbmltYXRvcixcclxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0FsZXJ0RGlhbG9nQW5pbWF0b3InLFxyXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBlY3RlZCByZXN1bHQgYWZ0ZXIgY29tcGlsZTpcclxuICAgICAqXHJcbiAgICAgKiA8b25zLWFsZXJ0LWRpYWxvZyBzdHlsZT1cIm5vbmVcIj5cclxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCI+PC9kaXY+XHJcbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2dcIj5cclxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxyXG4gICAgICogICA8L2Rpdj5cclxuICAgICAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cclxuICAgICAqL1xyXG5cclxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9tYXNrICYmICF0aGlzLl9kaWFsb2cpIHtcclxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fbWFzaykge1xyXG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLW1hc2snKTtcclxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5jaGlsZHJlblswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcclxuICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2cnKTtcclxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZGlhbG9nLCBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZywgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJykpIHtcclxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctY29udGFpbmVyJyk7XHJcbiAgICAgIHRoaXMuX2RpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHJcbiAgICB0aGlzLl9kaWFsb2cuc3R5bGUuekluZGV4ID0gMjAwMDE7XHJcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xyXG5cclxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XHJcbiAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKTtcclxuICAgIH1cclxuXHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NhbmNlbGFibGUnLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FuY2VsYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzaG93XHJcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjga7jga/jgIFcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxyXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNob3cgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxyXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1BIGBQcm9taXNlYCBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcclxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxyXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxyXG4gICAgKTtcclxuXHJcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XHJcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxyXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhbmNlbCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghY2FuY2VsKSB7XHJcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcxJztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XHJcblxyXG4gICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHNob3cnLCB7YWxlcnREaWFsb2c6IHRoaXN9KTtcclxuXHJcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGhpZGVcclxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXHJcbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1IaWRlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cclxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcclxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxyXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxyXG4gICAgKTtcclxuXHJcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWhpZGUnLCB7XHJcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxyXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhbmNlbCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghY2FuY2VsKSB7XHJcbiAgICAgIGNvbnN0IHRyeUhpZGUgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHVubG9jaygpO1xyXG5cclxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2FsZXJ0RGlhbG9nOiB0aGlzfSk7XHJcblxyXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVoaWRlIGV2ZW50LicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHZpc2libGVcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cclxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCB2aXNpYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXHJcbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgX2NhbmNlbCgpIHtcclxuICAgIGlmICh0aGlzLmNhbmNlbGFibGUgJiYgIXRoaXMuX3J1bm5pbmcpIHtcclxuICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XHJcbiAgICAgIHRoaXMuaGlkZSh7XHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xyXG5cclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcclxuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBPbnNBbGVydERpYWxvZ0VsZW1lbnQgPSB3aW5kb3cuT25zQWxlcnREaWFsb2dFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJywge1xyXG4gIHByb3RvdHlwZTogQWxlcnREaWFsb2dFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxyXG4gKi9cclxuT25zQWxlcnREaWFsb2dFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xyXG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFsZXJ0RGlhbG9nQW5pbWF0b3IpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zQWxlcnREaWFsb2dFbGVtZW50LkFsZXJ0RGlhbG9nQW5pbWF0b3InKTtcclxuICB9XHJcbiAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xyXG59O1xyXG5cclxuT25zQWxlcnREaWFsb2dFbGVtZW50LkFsZXJ0RGlhbG9nQW5pbWF0b3IgPSBBbGVydERpYWxvZ0FuaW1hdG9yO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbnZhciBzY2hlbWUgPSB7XHJcbiAgJyc6ICdiYWNrLWJ1dHRvbi0tKicsXHJcbiAgJy5iYWNrLWJ1dHRvbl9faWNvbic6ICdiYWNrLWJ1dHRvbi0tKl9faWNvbicsXHJcbiAgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnOiAnYmFjay1idXR0b24tLSpfX2xhYmVsJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy1iYWNrLWJ1dHRvblxyXG4gKiBAY2F0ZWdvcnkgdG9vbGJhclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dXHJcbiAqICAgICBCYWNrIGJ1dHRvbiBjb21wb25lbnQgZm9yIGA8b25zLXRvb2xiYXI+YC4gUHV0IGl0IGluIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIGA8b25zLXRvb2xiYXI+YC5cclxuICpcclxuICogICAgIEl0IHdpbGwgZmluZCB0aGUgcGFyZW50IGA8b25zLW5hdmlnYXRvcj5gIGVsZW1lbnQgYW5kIHBvcCBhIHBhZ2Ugd2hlbiBjbGlja2VkLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc3BlY2lmeWluZyB0aGUgYG9uQ2xpY2tgIHByb3BlcnR5LlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBjb2RlcGVuIGFIbUdMXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXHJcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXHJcbiAqICAgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dXHJcbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxyXG4gKiAgIFtlbl1vbnMtbmF2aWdhdG9yIGNvbXBvbmVudFsvZW5dXHJcbiAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAZ3VpZGUgQWRkaW5nYXRvb2xiYXJcclxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXHJcbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXHJcbiAqIEBndWlkZSBSZXR1cm5pbmdmcm9tYXBhZ2VcclxuICogICBbZW5dUmV0dXJuaW5nIGZyb20gYSBwYWdlWy9lbl1cclxuICogICBbamFd5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KLWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy10b29sYmFyPlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XHJcbiAqICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cclxuICogICA8L2Rpdj5cclxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XHJcbiAqICAgICBUaXRsZVxyXG4gKiAgIDxkaXY+XHJcbiAqIDwvb25zLXRvb2xiYXI+XHJcbiAqL1xyXG5cclxuY2xhc3MgQmFja0J1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYmFjayBidXR0b24uWy9lbl1cclxuICAgKiAgW2phXeODkOODg+OCr+ODnOOCv+ODs+OBruimi+OBn+ebruOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9vcHRpb25zID0ge307XHJcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYmFjay1idXR0b24nKTtcclxuXHJcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2xhYmVsJykpIHtcclxuICAgICAgY29uc3QgbGFiZWwgPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9fbGFiZWwnKTtcclxuXHJcbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcclxuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9faWNvbicpKSB7XHJcbiAgICAgIGNvbnN0IGljb24gPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9faWNvbicpO1xyXG5cclxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5jaGlsZHJlblswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlxyXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBcIi1pb3NcIiBvciBcIi1tZFwiXHJcbiAgICogICAgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gXCJsaWZ0LWlvc1wiLCBcImxpZnQtbWRcIi4gRGVmYXVsdHMgdmFsdWVzIGFyZSBcInNsaWRlLWlvc1wiIGFuZCBcImZhZGUtbWRcIi5cclxuICAgKiAgIFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXHJcbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5jYWxsYmFja1xyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5yZWZyZXNoXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIHBvcFBhZ2UgYWN0aW9uLlsvZW5dXHJcbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBvcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgfVxyXG5cclxuICBzZXQgb3B0aW9ucyhvYmplY3QpIHtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb25DbGlja1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBfb25DbGljaygpIHtcclxuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcclxuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGNvbnN0IG5hdmlnYXRvciA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLW5hdmlnYXRvcicpO1xyXG4gICAgICBpZiAobmF2aWdhdG9yKSB7XHJcbiAgICAgICAgbmF2aWdhdG9yLnBvcFBhZ2UodGhpcy5vcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xyXG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNCYWNrQnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWJhY2stYnV0dG9uJywge1xyXG4gIHByb3RvdHlwZTogQmFja0J1dHRvbkVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5cclxuY29uc3Qgc2NoZW1lID0geycnOiAnYm90dG9tLWJhci0tKid9O1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy1ib3R0b20tdG9vbGJhclxyXG4gKiBAY2F0ZWdvcnkgdG9vbGJhclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dVG9vbGJhciBjb21wb25lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuWy9lbl1cclxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cclxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XHJcbiAqICAgW2VuXU1ha2UgdGhlIHRvb2xiYXIgdHJhbnNwYXJlbnQuWy9lbl1cclxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICogQHNlZWFsc28gb25zLXRvb2xiYXIgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGd1aWRlIEFkZGluZ2F0b29sYmFyXHJcbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxyXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLWJvdHRvbS10b29sYmFyPlxyXG4gKiAgIENvbnRlbnRcclxuICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XHJcbiAqL1xyXG5jbGFzcyBCb3R0b21Ub29sYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxyXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruimi+OBn+ebruOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYm90dG9tLWJhcicpO1xyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuXHJcbiAgICB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpO1xyXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCkpO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCk7XHJcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSk7XHJcbiAgfVxyXG5cclxuICBfdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSB7XHJcbiAgICBjb25zdCBwYWdlID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtcGFnZScpO1xyXG5cclxuICAgIGlmIChwYWdlICYmIHBhZ2UgIT09IHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICBwYWdlLl9yZWdpc3RlckJvdHRvbVRvb2xiYXIodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcclxuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxud2luZG93Lk9uc0JvdHRvbVRvb2xiYXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtYm90dG9tLXRvb2xiYXInLCB7XHJcbiAgcHJvdG90eXBlOiBCb3R0b21Ub29sYmFyRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdidXR0b24tLSonfTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtYnV0dG9uXHJcbiAqIEBjYXRlZ29yeSBidXR0b25cclxuICogQG1vZGlmaWVyIG91dGxpbmVcclxuICogICBbZW5dQnV0dG9uIHdpdGggb3V0bGluZSBhbmQgdHJhbnNwYXJlbnQgYmFja2dyb3VuZFsvZW5dXHJcbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuaMgeOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBtb2RpZmllciBsaWdodFxyXG4gKiAgIFtlbl1CdXR0b24gdGhhdCBkb2Vzbid0IHN0YW5kIG91dC5bL2VuXVxyXG4gKiAgIFtqYV3nm67nq4vjgZ/jgarjgYTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAbW9kaWZpZXIgcXVpZXRcclxuICogICBbZW5dQnV0dG9uIHdpdGggbm8gb3V0bGluZSBhbmQgb3IgYmFja2dyb3VuZC4uWy9lbl1cclxuICogICBbamFd5p6g57ea44KE6IOM5pmv44GM54Sh44GE5paH5a2X44Gg44GR44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICogQG1vZGlmaWVyIGN0YVxyXG4gKiAgIFtlbl1CdXR0b24gdGhhdCByZWFsbHkgc3RhbmRzIG91dC5bL2VuXVxyXG4gKiAgIFtqYV3nm67nq4vjgaTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAbW9kaWZpZXIgbGFyZ2VcclxuICogICBbZW5dTGFyZ2UgYnV0dG9uIHRoYXQgY292ZXJzIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlsvZW5dXHJcbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi+Wkp+OBjeOBquODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBtb2RpZmllciBsYXJnZS0tcXVpZXRcclxuICogICBbZW5dTGFyZ2UgcXVpZXQgYnV0dG9uLlsvZW5dXHJcbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi3F1aWV044Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICogQG1vZGlmaWVyIGxhcmdlLS1jdGFcclxuICogICBbZW5dTGFyZ2UgY2FsbCB0byBhY3Rpb24gYnV0dG9uLlsvZW5dXHJcbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi2N0YeODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxyXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gYnV0dG9uWy9lbl1cclxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44OzWy9qYV1cclxuICogQG1vZGlmaWVyIG1hdGVyaWFsLS1mbGF0XHJcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBmbGF0IGJ1dHRvblsvZW5dXHJcbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODleODqeODg+ODiOODnOOCv+ODs1svamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIEJ1dHRvbiBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgYnV0dG9uIGluIGEgdG9vbGJhciwgdXNlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgb3IgYDxvbnMtYmFjay1idXR0b24+YCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYXMgYSBNYXRlcmlhbCBEZXNpZ24gYnV0dG9uIHdpdGggYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFd44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44CC44OE44O844Or44OQ44O844Gr44Oc44K/44Oz44KS6Kit572u44GZ44KL5aC05ZCI44Gv44CBb25zLXRvb2xiYXItYnV0dG9u44KC44GX44GP44Gvb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/55So44GX44G+44GZ44CCWy9qYV1cclxuICogQGNvZGVwZW4gaExheXhcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2J1dHRvblxyXG4gKiBAZ3VpZGUgQnV0dG9uIFtlbl1HdWlkZSBmb3IgYDxvbnMtYnV0dG9uPmBbL2VuXVtqYV08b25zLWJ1dHRvbj7jga7kvb/jgYTmlrlbL2phXVxyXG4gKiBAZ3VpZGUgT3ZlcnJpZGluZ0NTU3N0eWxlcyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1idXR0b24gbW9kaWZpZXI9XCJsYXJnZS0tY3RhXCI+XHJcbiAqICAgVGFwIE1lXHJcbiAqIDwvb25zLWJ1dHRvbj5cclxuICovXHJcblxyXG5jbGFzcyBCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cclxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3QuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgY2FzZSAnbW9kaWZpZXInOlxyXG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdyaXBwbGUnOlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgYnV0dG9uIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbicpO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVJpcHBsZSgpIHtcclxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc0J1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1idXR0b24nLCB7XHJcbiAgcHJvdG90eXBlOiBCdXR0b25FbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuY29uc3Qgc2NoZW1lID0geycnOiAnY2Fyb3VzZWwtaXRlbS0tKid9O1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy1jYXJvdXNlbC1pdGVtXHJcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dXHJcbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGNvZGVwZW4geGJiek9RXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxyXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWxcclxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cclxuICogICBbamFdPG9ucy1jYXJvdXNlbD7jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cclxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XHJcbiAqICAgIC4uLlxyXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XHJcbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxyXG4gKiAgICAuLi5cclxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxyXG4gKiA8L29ucy1jYXJvdXNlbD5cclxuICovXHJcbmNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcclxuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc0Nhcm91c2VsSXRlbUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1jYXJvdXNlbC1pdGVtJywge1xyXG4gIHByb3RvdHlwZTogQ2Fyb3VzZWxJdGVtRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XHJcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xyXG5cclxuY29uc3QgVmVydGljYWxNb2RlVHJhaXQgPSB7XHJcblxyXG4gIF9nZXRTY3JvbGxEZWx0YTogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWTtcclxuICB9LFxyXG5cclxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVk7XHJcbiAgfSxcclxuXHJcbiAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5fY3VycmVudEVsZW1lbnRTaXplKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XHJcbiAgfSxcclxuXHJcbiAgX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtOiBmdW5jdGlvbihzY3JvbGwpIHtcclxuICAgIHJldHVybiAndHJhbnNsYXRlM2QoMHB4LCAnICsgLXNjcm9sbCArICdweCwgMHB4KSc7XHJcbiAgfSxcclxuXHJcbiAgX3VwZGF0ZURpbWVuc2lvbkRhdGE6IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xyXG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgfSxcclxuXHJcbiAgX3VwZGF0ZU9mZnNldDogZnVuY3Rpb24oKXtcclxuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XHJcbiAgICAgIGNvbnN0IGhlaWdodCA9ICh0aGlzLl9kaW1lbnNpb25zLmhlaWdodCB8fCAwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdUb3AsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcclxuICAgICAgdGhpcy5fb2Zmc2V0ID0gLShoZWlnaHQgLSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkpIC8gMjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfbGF5b3V0Q2Fyb3VzZWxJdGVtczogZnVuY3Rpb24oKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCk7XHJcblxyXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xyXG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgY2hpbGRyZW5baV0uc3R5bGUuaGVpZ2h0ID0gc2l6ZUF0dHI7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IChpICogc2l6ZUluZm8ubnVtYmVyKSArIHNpemVJbmZvLnVuaXQ7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3NldHVwOiBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xyXG4gICAgdGhpcy5fdXBkYXRlT2Zmc2V0KCk7XHJcbiAgICB0aGlzLl9sYXlvdXRDYXJvdXNlbEl0ZW1zKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgSG9yaXpvbnRhbE1vZGVUcmFpdCA9IHtcclxuXHJcbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRTY3JvbGxWZWxvY2l0eTogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIHJldHVybiBldmVudC5nZXN0dXJlLnZlbG9jaXR5WDtcclxuICB9LFxyXG5cclxuICBfZ2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcclxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xyXG4gIH0sXHJcblxyXG4gIF9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybTogZnVuY3Rpb24oc2Nyb2xsKSB7XHJcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyAtc2Nyb2xsICsgJ3B4LCAwcHgsIDBweCknO1xyXG4gIH0sXHJcblxyXG4gIF91cGRhdGVEaW1lbnNpb25EYXRhOiBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcclxuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIH0sXHJcblxyXG4gIF91cGRhdGVPZmZzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xyXG4gICAgICBjb25zdCB3aWR0aCA9ICh0aGlzLl9kaW1lbnNpb25zLndpZHRoIHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0xlZnQsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xyXG4gICAgICB0aGlzLl9vZmZzZXQgPSAtKHdpZHRoIC0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpKSAvIDI7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX2xheW91dENhcm91c2VsSXRlbXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xyXG5cclxuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcclxuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndpZHRoID0gc2l6ZUF0dHI7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAoaSAqIHNpemVJbmZvLm51bWJlcikgKyBzaXplSW5mby51bml0O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9zZXR1cDogZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbkRhdGEoKTtcclxuICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xyXG4gICAgdGhpcy5fbGF5b3V0Q2Fyb3VzZWxJdGVtcygpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcclxuICogQGNhdGVnb3J5IGNhcm91c2VsXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIENhcm91c2VsIGNvbXBvbmVudC4gQSBjYXJvdXNlbCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IHNldmVyYWwgaXRlbXMgaW4gdGhlIHNhbWUgc3BhY2UuXHJcbiAqXHJcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBjb2RlcGVuIHhiYnpPUVxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcclxuICogQHNlZWFsc28gb25zLWNhcm91c2VsLWl0ZW1cclxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXHJcbiAqICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGd1aWRlIFVzaW5nQ2Fyb3VzZWxcclxuICogICBbZW5dTGVhcm4gaG93IHRvIHVzZSB0aGUgY2Fyb3VzZWwgY29tcG9uZW50LlsvZW5dXHJcbiAqICAgW2phXWNhcm91c2Vs44Kz44Oz44Od44O844ON44Oz44OI44Gu5L2/44GE5pa5Wy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XHJcbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxyXG4gKiAgICAuLi5cclxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxyXG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cclxuICogICAgLi4uXHJcbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cclxuICogPC9vbnMtY2Fyb3VzZWw+XHJcbiAqL1xyXG5jbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGhhcyBjaGFuZ2VkLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxyXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcclxuICAgKiAgIFtlbl1DdXJyZW50IGFjdGl2ZSBpbmRleC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50Lmxhc3RBY3RpdmVJbmRleFxyXG4gICAqICAgW2VuXVByZXZpb3VzIGFjdGl2ZSBpbmRleC5bL2VuXVxyXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCByZWZyZXNoXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXHJcbiAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxyXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IG92ZXJzY3JvbGxcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBjYXJvdXNlbCBoYXMgYmVlbiBvdmVyc2Nyb2xsZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzjgqrjg7zjg5Djg7zjgrnjgq/jg63jg7zjg6vjgZfjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXHJcbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXHJcbiAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcclxuICAgKiAgIFtlbl1DdXJyZW50IGFjdGl2ZSBpbmRleC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxyXG4gICAqICAgW2VuXUNhbiBiZSBvbmUgb2YgZWl0aGVyIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIG9yIFwicmlnaHRcIi5bL2VuXVxyXG4gICAqICAgW2phXeOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBleOCjOOBn+aWueWQkeOBjOW+l+OCieOCjOOBvuOBmeOAglwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCLjga7jgYTjgZrjgozjgYvjga7mlrnlkJHjgYzmuKHjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxyXG4gICAqICAgW2VuXVRha2VzIGEgPGNvZGU+UHJvbWlzZTwvY29kZT4gb2JqZWN0IGFzIGFuIGFyZ3VtZW50LiBUaGUgY2Fyb3VzZWwgd2lsbCBub3Qgc2Nyb2xsIGJhY2sgdW50aWwgdGhlIHByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjga9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS5byV5pWw44Go44GX44Gm5Y+X44GR5Y+W44KK44G+44GZ44CC5rih44GX44GfUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOBjHJlc29sdmXjgZXjgozjgovjgYtyZWplY3TjgZXjgozjgovjgb7jgafjgIHjgqvjg6vjg7zjgrvjg6vjga/jgrnjgq/jg63jg7zjg6vjg5Djg4Pjgq/jgZfjgb7jgZvjgpPjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXHJcbiAgICogICBbamFd44Kr44Or44O844K744Or44Gu5pa55ZCR44KS5oyH5a6a44GX44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYtcInZlcnRpY2FsXCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJcImhvcml6b250YWxcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZnVsbHNjcmVlblxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBjb3ZlciB0aGUgd2hvbGUgc2NyZWVuLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CBYWJzb2x1dGXjg53jgrjjgrfjg6fjg7PjgpLkvb/jgaPjgabjgqvjg6vjg7zjgrvjg6vjgYzoh6rli5XnmoTjgavnlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIHNjcm9sbGFibGUgb3ZlciB0aGUgZWRnZS4gSXQgd2lsbCBib3VuY2UgYmFjayB3aGVuIHJlbGVhc2VkLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBjZW50ZXJlZFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB6YG444KT44Gn44GE44KLb25zLWNhcm91c2VsLWl0ZW3jga/jgqvjg6vjg7zjgrvjg6vjga7nnJ/jgpPkuK3jgbjooYzjgY3jgb7jgZnjgILpoIXnm67jgYzjgqvjg6vjg7zjgrvjg6vjgojjgorjgoLlsI/jgZXjgYTloLTlkIjjgavjga7jgb/jgIHjgZPjgozjga/kvr/liKnjgafjgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGl0ZW0td2lkdGhcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIHdpZHRoLiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJob3Jpem9udGFsXCIuWy9lbl1cclxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS1oZWlnaHRcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3MgaGVpZ2h0LiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJ2ZXJ0aWNhbFwiLlsvZW5dXHJcbiAgICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcInZlcnRpY2FsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2Nyb2xsZWQgdG8gdGhlIGNsb3Nlc3QgaXRlbSBib3JkZXIgd2hlbiByZWxlYXNlZC5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsLXJhdGlvXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgICBbZW5dQSBudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDEuMCB0aGF0IHNwZWNpZmllcyBob3cgbXVjaCB0aGUgdXNlciBtdXN0IGRyYWcgdGhlIGNhcm91c2VsIGluIG9yZGVyIGZvciBpdCB0byBhdXRvIHNjcm9sbCB0byB0aGUgbmV4dCBpdGVtLlsvZW5dXHJcbiAgICogICAgW2phXTAuMOOBi+OCiTEuMOOBvuOBp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCq+ODq+ODvOOCu+ODq+OBruimgee0oOOCkuOBqeOCjOOBkOOCieOBhOOBruWJsuWQiOOBvuOBp+ODieODqeODg+OCsOOBmeOCi+OBqOasoeOBruimgee0oOOBq+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBjYW4gYmUgc2Nyb2xsZWQgYnkgZHJhZyBvciBzd2lwZS5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZHJhZ+OChHRvdWNo44KEc3dpcGXjgpLlj5fjgZHku5jjgZHjgarjgY/jgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGluaXRpYWwtaW5kZXhcclxuICAgKiBAaW5pdG9ubHlcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXHJcbiAgICogICBbamFd5pyA5Yid44Gr6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpIw5aeL44G+44KK44Gu44Kk44Oz44OH44OD44Kv44K544Gn5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI5YCk44GvIDAg44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXJlZnJlc2hcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGVuIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggd2hlbiB0aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGNoYW5nZS5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeWtkOimgee0oOOBruaVsOOBjOWkieOCj+OCi+OBqOOCq+ODq+ODvOOCu+ODq+OBr+iHquWLleeahOOBq+abtOaWsOOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcclxuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cclxuICAgKi9cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcclxuICAgIHRoaXMuX3Njcm9sbCA9IDA7XHJcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xyXG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcclxuXHJcbiAgICB0aGlzLl9ib3VuZE9uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kT25SZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XHJcbiAgfVxyXG5cclxuICBfb25SZXNpemUoKSB7XHJcbiAgICBjb25zdCBpID0gdGhpcy5fc2Nyb2xsIC8gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xyXG4gICAgZGVsZXRlIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcclxuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XHJcbiAgfVxyXG5cclxuICBfb25EaXJlY3Rpb25DaGFuZ2UoKSB7XHJcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XHJcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dYID0gJ2F1dG8nO1xyXG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WSA9ICcnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1ggPSAnJztcclxuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICBfc2F2ZUxhc3RTdGF0ZSgpIHtcclxuICAgIHRoaXMuX2xhc3RTdGF0ZSA9IHtcclxuICAgICAgZWxlbWVudFNpemU6IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSxcclxuICAgICAgY2Fyb3VzZWxFbGVtZW50Q291bnQ6IHRoaXMuaXRlbUNvdW50LFxyXG4gICAgICB3aWR0aDogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5pdGVtQ291bnRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICovXHJcbiAgX2dldENhcm91c2VsSXRlbVNpemUoKSB7XHJcbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XHJcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xyXG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xyXG5cclxuICAgIGlmIChzaXplSW5mby51bml0ID09PSAnJScpIHtcclxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2l6ZUluZm8ubnVtYmVyIC8gMTAwICogZWxlbWVudFNpemUpO1xyXG4gICAgfSBlbHNlIGlmIChzaXplSW5mby51bml0ID09PSAncHgnKSB7XHJcbiAgICAgIHJldHVybiBzaXplSW5mby5udW1iZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cclxuICBfZ2V0SW5pdGlhbEluZGV4KCkge1xyXG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaW5pdGlhbC1pbmRleCcpLCAxMCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGluZGV4KSkge1xyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oaW5kZXgsIHRoaXMuaXRlbUNvdW50IC0gMSksIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCkge1xyXG4gICAgY29uc3QgYXR0ck5hbWUgPSAnaXRlbS0nICsgKHRoaXMuX2lzVmVydGljYWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyk7XHJcbiAgICBjb25zdCBpdGVtU2l6ZUF0dHIgPSAoJycgKyB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpLnRyaW0oKTtcclxuXHJcbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBfZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplKSB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gc2l6ZS5tYXRjaCgvXihcXGQrKShweHwlKS8pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG51bWJlcjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxyXG4gICAgICB1bml0OiBtYXRjaGVzWzJdLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIF9zZXR1cEluaXRpYWxJbmRleCgpIHtcclxuICAgIHRoaXMuX3Njcm9sbCA9ICh0aGlzLl9vZmZzZXQgfHwgMCkgKyB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgKiB0aGlzLl9nZXRJbml0aWFsSW5kZXgoKTtcclxuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2dldEluaXRpYWxJbmRleCgpO1xyXG4gICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlSW5kZXhcclxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZUluZGV4KGluZGV4LCBbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICogICBbZW5dVGhlIGluZGV4IHRoYXQgdGhlIGNhcm91c2VsIHNob3VsZCBiZSBzZXQgdG8uWy9lbl1cclxuICAgKiAgIFtqYV1jYXJvdXNlbOimgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXHJcbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBpbmRleCBvZiB0aGUgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIHRvIHNob3cuWy9lbl1cclxuICAgKiAgIFtqYV3ooajnpLrjgZnjgotvbnMtY2Fyb3VzZWwtaXRlbeOCkmluZGV444Gn5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50LlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXHJcbiAgICAgIHsgZHVyYXRpb246IDAuMywgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyB9LFxyXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXHJcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIDoge31cclxuICAgICk7XHJcblxyXG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSk7XHJcbiAgICBjb25zdCBzY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogaW5kZXg7XHJcbiAgICBjb25zdCBtYXggPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcclxuXHJcbiAgICB0aGlzLl9zY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCwgb3B0aW9ucykudGhlbigoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XHJcbiAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVJbmRleCgpXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZfjgabjgYTjgovjgqvjg6vjg7zjgrvjg6vopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgYzov5TjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZXjgozjgabjgYTjgotvbnMtY2Fyb3VzZWwtaXRlbeimgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XHJcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSAodGhpcy5fb2Zmc2V0IHx8IDApO1xyXG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudDtcclxuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XHJcblxyXG4gICAgaWYgKHNjcm9sbCA8IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBpZiAoc2l6ZSAqIGkgPD0gc2Nyb2xsICYmIHNpemUgKiAoaSArIDEpID4gc2Nyb2xsKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBtYXggY2Fyb3VzZWwgaW5kZXhcclxuICAgIHJldHVybiBpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBuZXh0XHJcbiAgICogQHNpZ25hdHVyZSBuZXh0KFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXHJcbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXHJcbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNob3cgbmV4dCBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cclxuICAgKiAgIFtqYV3mrKHjga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgbmV4dChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgKyAxLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgcHJldlxyXG4gICAqIEBzaWduYXR1cmUgcHJldihbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXHJcbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxyXG4gICAqICAgW2phXeWJjeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBwcmV2KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSAtIDEsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBfaXNFbmFibGVkQ2hhbmdlRXZlbnQoKSB7XHJcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XHJcbiAgICBjb25zdCBjYXJvdXNlbEl0ZW1TaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmF1dG9TY3JvbGwgJiYgZWxlbWVudFNpemUgPT09IGNhcm91c2VsSXRlbVNpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIF9pc1ZlcnRpY2FsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSA9PT0gJ3ZlcnRpY2FsJztcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtkcmFnTWluRGlzdGFuY2U6IDF9KTtcclxuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB0aGlzLnJlZnJlc2goKSk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XHJcbiAgICB0aGlzLl91cGRhdGVBdXRvUmVmcmVzaCgpO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGw7XHJcblxyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25SZXNpemUsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVN3aXBlYWJsZSgpIHtcclxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcclxuICAgICAgaWYgKHRoaXMuc3dpcGVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24nLCB0aGlzLl9ib3VuZE9uRHJhZyk7XHJcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93bicsIHRoaXMuX2JvdW5kT25EcmFnKTtcclxuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlQXV0b1JlZnJlc2goKSB7XHJcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKSB7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKSB7XHJcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldEFjdGl2ZUluZGV4KCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2xhc3RBY3RpdmVJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XHJcbiAgICAgIGNvbnN0IGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcclxuICAgICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gY3VycmVudEluZGV4O1xyXG5cclxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xyXG4gICAgICAgIGNhcm91c2VsOiB0aGlzLFxyXG4gICAgICAgIGFjdGl2ZUluZGV4OiBjdXJyZW50SW5kZXgsXHJcbiAgICAgICAgbGFzdEFjdGl2ZUluZGV4OiBsYXN0QWN0aXZlSW5kZXhcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25EcmFnKGV2ZW50KSB7XHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmRpcmVjdGlvbjtcclxuICAgIGlmICgodGhpcy5faXNWZXJ0aWNhbCgpICYmIChkaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpKSB8fCAoIXRoaXMuX2lzVmVydGljYWwoKSAmJiAoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgIHRoaXMuX2xhc3REcmFnRXZlbnQgPSBldmVudDtcclxuXHJcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCk7XHJcbiAgICB0aGlzLl9zY3JvbGxUbyhzY3JvbGwpO1xyXG4gICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcclxuICB9XHJcblxyXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcclxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLl9zY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KSAhPT0gMCkge1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5faXNPdmVyU2Nyb2xsKHRoaXMuX3Njcm9sbCkpIHtcclxuICAgICAgbGV0IHdhaXRGb3JBY3Rpb24gPSBmYWxzZTtcclxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvdmVyc2Nyb2xsJywge1xyXG4gICAgICAgIGNhcm91c2VsOiB0aGlzLFxyXG4gICAgICAgIGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KCksXHJcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uKCksXHJcbiAgICAgICAgd2FpdFRvUmV0dXJuOiAocHJvbWlzZSkgPT4ge1xyXG4gICAgICAgICAgd2FpdEZvckFjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCF3YWl0Rm9yQWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9zdGFydE1vbWVudHVtU2Nyb2xsKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gbnVsbDtcclxuXHJcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhaXRcclxuICAgKi9cclxuICBfbWl4aW4odHJhaXQpIHtcclxuICAgIE9iamVjdC5rZXlzKHRyYWl0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICB0aGlzW2tleV0gPSB0cmFpdFtrZXldO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIF9zdGFydE1vbWVudHVtU2Nyb2xsKCkge1xyXG4gICAgaWYgKHRoaXMuX2xhc3REcmFnRXZlbnQpIHtcclxuICAgICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRTY3JvbGxWZWxvY2l0eSh0aGlzLl9sYXN0RHJhZ0V2ZW50KTtcclxuICAgICAgY29uc3QgZHVyYXRpb24gPSAwLjM7XHJcbiAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0gZHVyYXRpb24gKiAxMDAgKiB2ZWxvY2l0eTtcclxuICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oXHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsICsgKHRoaXMuX2dldFNjcm9sbERlbHRhKHRoaXMuX2xhc3REcmFnRXZlbnQpID4gMCA/IC1zY3JvbGxEZWx0YSA6IHNjcm9sbERlbHRhKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy5fc2Nyb2xsID0gc2Nyb2xsO1xyXG5cclxuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0odGhpcy5fc2Nyb2xsKVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5wbGF5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKSB7XHJcbiAgICBjb25zdCBtYXggPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuYXV0b1Njcm9sbCkge1xyXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcclxuICAgIH1cclxuICAgIGxldCBhcnIgPSBbXTtcclxuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XHJcbiAgICBjb25zdCBuYnJPZkl0ZW1zID0gdGhpcy5pdGVtQ291bnQ7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYnJPZkl0ZW1zOyBpKyspIHtcclxuICAgICAgaWYgKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0IDwgbWF4KSB7XHJcbiAgICAgICAgYXJyLnB1c2goaSAqIHNpemUgKyB0aGlzLl9vZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhcnIucHVzaChtYXgpO1xyXG5cclxuICAgIGFyci5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgIGxlZnQgPSBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsKTtcclxuICAgICAgcmlnaHQgPSBNYXRoLmFicyhyaWdodCAtIHNjcm9sbCk7XHJcblxyXG4gICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXJyID0gYXJyLmZpbHRlcihmdW5jdGlvbihpdGVtLCBwb3MpIHtcclxuICAgICAgcmV0dXJuICFwb3MgfHwgaXRlbSAhPSBhcnJbcG9zIC0gMV07XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBsYXN0U2Nyb2xsID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ICogc2l6ZSArIHRoaXMuX29mZnNldDtcclxuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xyXG4gICAgbGV0IHJlc3VsdCA9IGFyclswXTtcclxuXHJcbiAgICBpZiAoc2Nyb2xsUmF0aW8gPD0gdGhpcy5hdXRvU2Nyb2xsUmF0aW8pIHtcclxuICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcclxuICAgIH0gZWxzZSBpZiAoc2Nyb2xsUmF0aW8gPCAxLjApIHtcclxuICAgICAgaWYgKGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGFyclsxXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHJlc3VsdCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICovXHJcbiAgX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXHJcbiAgICAgIC5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWNhcm91c2VsLWl0ZW0nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRcclxuICAgKi9cclxuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGlzT3ZlcnNjcm9sbGFibGUgPSB0aGlzLm92ZXJzY3JvbGxhYmxlO1xyXG5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZVNjcm9sbCA9IChzY3JvbGwpID0+IHtcclxuICAgICAgY29uc3QgcmF0aW8gPSAwLjM1O1xyXG5cclxuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcclxuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IE1hdGgucm91bmQoc2Nyb2xsICogcmF0aW8pIDogMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XHJcbiAgICAgIGlmIChtYXhTY3JvbGwgPCBzY3JvbGwpIHtcclxuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IG1heFNjcm9sbCArIE1hdGgucm91bmQoKHNjcm9sbCAtIG1heFNjcm9sbCkgKiByYXRpbykgOiBtYXhTY3JvbGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzY3JvbGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkpXHJcbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb24gICE9PSAnbm9uZScgPyBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgOiB7fSlcclxuICAgICAgICAucGxheSgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2NhbGN1bGF0ZU1heFNjcm9sbCgpIHtcclxuICAgIGNvbnN0IG1heCA9IHRoaXMuaXRlbUNvdW50ICogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIC0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxyXG4gIH1cclxuXHJcbiAgX2lzT3ZlclNjcm9sbChzY3JvbGwpIHtcclxuICAgIGlmIChzY3JvbGwgPCAwIHx8IHNjcm9sbCA+IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgX2dldE92ZXJTY3JvbGxEaXJlY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGwgPD0gMCA/ICd1cCcgOiAnZG93bic7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKSB7XHJcbiAgICBjb25zdCBkdXJhdGlvbiA9IDAuNDtcclxuXHJcbiAgICBpZiAodGhpcy5fc2Nyb2xsIDwgMCkge1xyXG4gICAgICBhbmltaXQodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybSgwKVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjQsIC4xLCAxKSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5wbGF5KCk7XHJcbiAgICAgIHRoaXMuX3Njcm9sbCA9IDA7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcclxuXHJcbiAgICBpZiAobWF4U2Nyb2xsIDwgdGhpcy5fc2Nyb2xsKSB7XHJcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtKG1heFNjcm9sbClcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAucGxheSgpO1xyXG4gICAgICB0aGlzLl9zY3JvbGwgPSBtYXhTY3JvbGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgaXRlbUNvdW50XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgbnVtYmVyIG9mIGNhcm91c2VsIGl0ZW1zLlsvZW5dXHJcbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgaXRlbUNvdW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCByZWZyZXNoXHJcbiAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxyXG4gICAqICAgW2phXeODrOOCpOOCouOCpuODiOOChOWGhemDqOOBrueKtuaFi+OCkuacgOaWsOOBruOCguOBruOBq+abtOaWsOOBl+OBvuOBmeOAgm9ucy1jYXJvdXNlbC1pdGVt44KS5YuV55qE44Gr5aKX44KE44GX44Gf44KK44CBb25zLWNhcm91c2Vs44Gu5aSn44GN44GV44KS5YuV55qE44Gr5aSJ44GI44KL6Zqb44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICByZWZyZXNoKCkge1xyXG4gICAgLy8gQnVnIGZpeFxyXG4gICAgaWYgKHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSA9PT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbWl4aW4odGhpcy5faXNWZXJ0aWNhbCgpID8gVmVydGljYWxNb2RlVHJhaXQgOiBIb3Jpem9udGFsTW9kZVRyYWl0KTtcclxuICAgIHRoaXMuX3NldHVwKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2xhc3RTdGF0ZSAmJiB0aGlzLl9sYXN0U3RhdGUud2lkdGggPiAwKSB7XHJcbiAgICAgIGxldCBzY3JvbGwgPSB0aGlzLl9zY3JvbGw7Ly8gLSB0aGlzLl9vZmZzZXQ7XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNPdmVyU2Nyb2xsKHNjcm9sbCkpIHtcclxuICAgICAgICB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Njcm9sbCkge1xyXG4gICAgICAgICAgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHNjcm9sbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zYXZlTGFzdFN0YXRlKCk7XHJcblxyXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywge2Nhcm91c2VsOiB0aGlzfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGZpcnN0XHJcbiAgICogQHNpZ25hdHVyZSBmaXJzdCgpXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXHJcbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxyXG4gICAqICAgW2phXeacgOWIneOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBmaXJzdChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCgwLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgbGFzdFxyXG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXHJcbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXHJcbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNob3cgbGFzdCBvbnMtY2Fyb3VzZWwgaXRlbS5bL2VuXVxyXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBsYXN0KG9wdGlvbnMpIHtcclxuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoXHJcbiAgICAgIE1hdGgubWF4KHRoaXMuaXRlbUNvdW50IC0gMSwgMCksIG9wdGlvbnNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fcHJlcGFyZUV2ZW50TGlzdGVuZXJzKCk7XHJcblxyXG4gICAgdGhpcy5fc2V0dXAoKTtcclxuICAgIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCk7XHJcblxyXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xyXG5cclxuICAgIC8vIEZpeCByZW5kZXJpbmcgZ2xpdGNoIG9uIEFuZHJvaWQgNC4xXHJcbiAgICBpZiAodGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcclxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMucmVmcmVzaCgpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcclxuICAgICAgICB0aGlzLl91cGRhdGVTd2lwZWFibGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYXV0by1yZWZyZXNoJzpcclxuICAgICAgICB0aGlzLl91cGRhdGVBdXRvUmVmcmVzaCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxyXG4gICAgICAgIHRoaXMuX29uRGlyZWN0aW9uQ2hhbmdlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBhdXRvU2Nyb2xsUmF0aW9cclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGF1dG8gc2Nyb2xsIHJhdGlvLiBbL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgYXV0b1Njcm9sbFJhdGlvKCkge1xyXG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycpO1xyXG5cclxuICAgIGlmICghYXR0cikge1xyXG4gICAgICByZXR1cm4gMC41O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gcGFyc2VGbG9hdChhdHRyKTtcclxuICAgIGlmIChzY3JvbGxSYXRpbyA8IDAuMCB8fCBzY3JvbGxSYXRpbyA+IDEuMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmF0aW8uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzTmFOKHNjcm9sbFJhdGlvKSA/IDAuNSA6IHNjcm9sbFJhdGlvO1xyXG4gIH1cclxuXHJcbiAgc2V0IGF1dG9TY3JvbGxSYXRpbyhyYXRpbykge1xyXG4gICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nLCByYXRpbyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgc3dpcGVhYmxlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5ddHJ1ZSBpZiB0aGUgY2Fyb3VzZWwgaXMgc3dpcGVhYmxlLlsvZW5dXHJcbiAgICogICBbamFdc3dpcGVhYmxl44Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IHN3aXBlYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBzZXQgc3dpcGVhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBhdXRvU2Nyb2xsXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5ddHJ1ZSBpZiBhdXRvIHNjcm9sbCBpcyBlbmFibGVkLlsvZW5dXHJcbiAgICogICBbamFd44Kq44O844OI44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IGF1dG9TY3JvbGwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XHJcbiAgfVxyXG5cclxuICBzZXQgYXV0b1Njcm9sbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhdXRvLXNjcm9sbCcsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IG92ZXJzY3JvbGxhYmxlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXHJcbiAgICogICBbamFdb3ZlcnNjcm9sbOOBp+OBjeOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBvdmVyc2Nyb2xsYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnb3ZlcnNjcm9sbGFibGUnKTtcclxuICB9XHJcblxyXG4gIHNldCBvdmVyc2Nyb2xsYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdvdmVyc2Nyb2xsYWJsZScsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBjZW50ZXJlZFxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGNlbnRlcmVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXWNlbnRlcmVk54q25oWL44Gr44Gq44Gj44Gm44GE44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IGNlbnRlcmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjZW50ZXJlZCcpO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNlbnRlcmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NlbnRlcmVkJywgdmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc0Nhcm91c2VsRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWNhcm91c2VsJywge1xyXG4gIHByb3RvdHlwZTogQ2Fyb3VzZWxFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtY29sXHJcbiAqIEBjYXRlZ29yeSBncmlkXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgY29sdW1uIGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtcm93PmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cclxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBub3RlXHJcbiAqICAgW2VuXUZvciBBbmRyb2lkIDQuMyBhbmQgZWFybGllciwgYW5kIGlPUzYgYW5kIGVhcmxpZXIsIHdoZW4gdXNpbmcgbWl4ZWQgYWxpZ25tZW50IHdpdGggb25zLXJvdyBhbmQgb25zLWNvbHVtbiwgdGhleSBtYXkgbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuIFlvdSBjYW4gdXNlIG9ubHkgb25lIGFsaWdubWVudC5bL2VuXVxyXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXHJcbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxyXG4gKiBAZ3VpZGUgbGF5b3V0aW5nIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVtqYV3jg6zjgqTjgqLjgqbjg4jmqZ/og71bL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtcm93XHJcbiAqICAgW2VuXVRoZSBgPG9ucy1yb3c+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBvZiBgPG9ucy1jb2w+YC5bL2VuXVxyXG4gKiAgIFtqYV1vbnMtcm9344Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1yb3c+XHJcbiAqICAgPG9ucy1jb2wgd2lkdGg9XCI1MHB4XCI+PG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj48L29ucy1jb2w+XHJcbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cclxuICogPC9vbnMtcm93PlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAYXR0cmlidXRlIHZlcnRpY2FsLWFsaWduXHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1WZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIGNvbHVtbi4gVmFsaWQgdmFsdWVzIGFyZSBcInRvcFwiLCBcImNlbnRlclwiLCBhbmQgXCJib3R0b21cIi5bL2VuXVxyXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICovXHJcblxyXG4vKipcclxuICogQGF0dHJpYnV0ZSB3aWR0aFxyXG4gKiBAdHlwZSB7U3RyaW5nfVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgY3NzIHdpZHRoIHZhbHVlcyAoXCIxMCVcIiwgXCI1MHB4XCIpLlsvZW5dXHJcbiAqICAgW2phXeOCq+ODqeODoOOBruaoquW5heOCkuaMh+WumuOBmeOCi+OAguODkeODvOOCu+ODs+ODiOOCguOBl+OBj+OBr+ODlOOCr+OCu+ODq+OBp+aMh+WumuOBl+OBvuOBme+8iDEwJeOChDUwcHjvvInjgIJbL2phXVxyXG4gKi9cclxuY2xhc3MgQ29sdW1uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVdpZHRoKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICd3aWR0aCcpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVXaWR0aCgpIHtcclxuICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xyXG4gICAgaWYgKHR5cGVvZiB3aWR0aCAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHdpZHRoID0gKCcnICsgd2lkdGgpLnRyaW0oKTtcclxuICAgICAgd2lkdGggPSB3aWR0aC5tYXRjaCgvXlxcZCskLykgPyB3aWR0aCArICclJyA6IHdpZHRoO1xyXG5cclxuICAgICAgdGhpcy5zdHlsZS53ZWJraXRCb3hGbGV4ID0gJzAnO1xyXG4gICAgICB0aGlzLnN0eWxlLndlYmtpdEZsZXggPSAnMCAwICcgKyB3aWR0aDtcclxuICAgICAgdGhpcy5zdHlsZS5tb3pCb3hGbGV4ID0gJzAnO1xyXG4gICAgICB0aGlzLnN0eWxlLm1vekZsZXggPSAnMCAwICcgKyB3aWR0aDtcclxuICAgICAgdGhpcy5zdHlsZS5tc0ZsZXggPSAnMCAwICcgKyB3aWR0aDtcclxuICAgICAgdGhpcy5zdHlsZS5mbGV4ID0gJzAgMCAnICsgd2lkdGg7XHJcbiAgICAgIHRoaXMuc3R5bGUubWF4V2lkdGggPSB3aWR0aDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNDb2xFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtY29sJywge1xyXG4gIHByb3RvdHlwZTogQ29sdW1uRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5leHBvcnQgY2xhc3MgRGlhbG9nQW5pbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcclxuICAgIHRoaXMudGltaW5nID0gdGltaW5nO1xyXG4gICAgdGhpcy5kZWxheSA9IGRlbGF5O1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxyXG4gICAqL1xyXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XHJcbiAgICBkb25lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXHJcbiAgICovXHJcbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcclxuICAgIGRvbmUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5kcm9pZERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xyXG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxyXG4gICAgICAgIC5zYXZlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJT1NEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcclxuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgIGFuaW1pdC5ydW5BbGwoXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBkaWFsb2cuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2xpZGVEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XHJcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtMzUwJSwgMCknLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTUwJSwgMCknLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxyXG4gICAgICAgIC5zYXZlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTUwJSwgMCknXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtMzUwJSwgMCknXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xyXG5pbXBvcnQge0RpYWxvZ0FuaW1hdG9yLCBJT1NEaWFsb2dBbmltYXRvciwgQW5kcm9pZERpYWxvZ0FuaW1hdG9yLCBTbGlkZURpYWxvZ0FuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcclxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XHJcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnLmRpYWxvZyc6ICdkaWFsb2ctLSonLFxyXG4gICcuZGlhbG9nLWNvbnRhaW5lcic6ICdkaWFsb2ctY29udGFpbmVyLS0qJyxcclxuICAnLmRpYWxvZy1tYXNrJzogJ2RpYWxvZy1tYXNrLS0qJ1xyXG59O1xyXG5cclxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcclxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZERpYWxvZ0FuaW1hdG9yIDogSU9TRGlhbG9nQW5pbWF0b3IsXHJcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxyXG4gICdzbGlkZSc6IFNsaWRlRGlhbG9nQW5pbWF0b3IsXHJcbiAgJ25vbmUnOiBEaWFsb2dBbmltYXRvclxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy1kaWFsb2dcclxuICogQGNhdGVnb3J5IGRpYWxvZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dXHJcbiAqICAgICBEaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLiBBcyBvcHBvc2VkIHRvIHRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50LCB0aGlzIGNvbXBvbmVudCBjYW4gY29udGFpbiBhbnkga2luZCBvZiBjb250ZW50LlxyXG4gKlxyXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGA8b25zLmNyZWF0ZURpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cclxuICpcclxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXHJcbiAqXHJcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZGlzcGxheWVkIGFzIE1hdGVyaWFsIERlc2lnbiB3aGVuIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBkZXZpY2UuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXHJcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXHJcbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBjb2RlcGVuIHp4eGFHYVxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXHJcbiAqIEBndWlkZSBVc2luZ0RpYWxvZ1xyXG4gKiAgIFtlbl1MZWFybiBob3cgdG8gdXNlIHRoZSBkaWFsb2cgY29tcG9uZW50LlsvZW5dXHJcbiAqICAgW2phXeODgOOCpOOCouODreOCsOOCs+ODs+ODneODvOODjeODs+ODiOOBruS9v+OBhOaWuVsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcclxuICogICBbZW5dYDxvbnMtYWxlcnQtZGlhbG9nPmAgY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXHJcbiAqICAgW2VuXWA8b25zLXBvcG92ZXI+YCBjb21wb25lbnRbL2VuXVxyXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtZGlhbG9nIGlkPVwiZGlhbG9nXCI+XHJcbiAqICAgPHA+VGhpcyBpcyBhIGRpYWxvZyE8L3A+XHJcbiAqIDwvb25zLWRpYWxvZz5cclxuICpcclxuICogPHNjcmlwdD5cclxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xyXG4gKiA8L3NjcmlwdD5cclxuICovXHJcbmNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVzaG93XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXHJcbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXHJcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHBvc3RzaG93XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cclxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHByZWhpZGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cclxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcclxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6Z2e6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHBvc3RoaWRlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cclxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXHJcbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXHJcbiAgICogIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxyXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlZmF1bHQgZGVmYXVsdFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXHJcbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xyXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXHJcbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxyXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGdldCBfbWFzaygpIHtcclxuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XHJcbiAgfVxyXG5cclxuICBnZXQgX2RpYWxvZygpIHtcclxuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZycpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XHJcblxyXG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcclxuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xyXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XHJcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcclxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcclxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0RpYWxvZ0FuaW1hdG9yJyxcclxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcblxyXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgIC8qIEV4cGVjdGVkIHJlc3VsdDpcclxuICAgICAqICAgPG9ucy1kaWFsb2c+XHJcbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XHJcbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZ1wiPlxyXG4gICAgICogICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1jb250YWluZXJcIj4uLi48L2Rpdj5cclxuICAgICAqICAgICA8L2Rpdj5cclxuICAgICAqICAgPC9vbnMtZGlhbG9nPlxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcclxuICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xyXG5cclxuICAgICAgZGlhbG9nLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX21hc2spIHtcclxuICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XHJcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlhbG9nLnN0eWxlLnpJbmRleCA9IDIwMDAxO1xyXG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJywgJycpO1xyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cclxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBfY2FuY2VsKCkge1xyXG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSAmJiAhdGhpcy5fcnVubmluZykge1xyXG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgdGhpcy5oaWRlKHtcclxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkaWFsb2ctY2FuY2VsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2hvd1xyXG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXHJcbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXHJcbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxyXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cclxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkumWi+OBjeOBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcclxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxyXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxyXG4gICAgKTtcclxuXHJcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XHJcbiAgICAgIGRpYWxvZzogdGhpcyxcclxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjYW5jZWwgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIWNhbmNlbCkge1xyXG4gICAgICBjb25zdCB0cnlTaG93ID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcclxuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB0aGlzLl9tYXNrLnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFuaW1hdG9yLnNob3codGhpcywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHVubG9jaygpO1xyXG5cclxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2RpYWxvZzogdGhpc30pO1xyXG5cclxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeVNob3coKSkpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlc2hvdyBldmVudC4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaGlkZVxyXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXHJcbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cclxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxyXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgaGlkZShvcHRpb25zID0ge30pIHtcclxuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxyXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXHJcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXHJcbiAgICApO1xyXG5cclxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcclxuICAgICAgZGlhbG9nOiB0aGlzLFxyXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhbmNlbCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghY2FuY2VsKSB7XHJcbiAgICAgIGNvbnN0IHRyeUhpZGUgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHVubG9jaygpO1xyXG5cclxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2RpYWxvZzogdGhpc30pO1xyXG5cclxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeUhpZGUoKSkpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlaGlkZSBldmVudC4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXHJcbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgdmlzaWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NhbmNlbGFibGUnLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FuY2VsYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcclxuXHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwuYmluZCh0aGlzKSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XHJcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgT25zRGlhbG9nRWxlbWVudCA9IHdpbmRvdy5PbnNEaWFsb2dFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtZGlhbG9nJywge1xyXG4gIHByb3RvdHlwZTogRGlhbG9nRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcclxuICovXHJcbk9uc0RpYWxvZ0VsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uKG5hbWUsIEFuaW1hdG9yKSB7XHJcbiAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zRGlhbG9nRWxlbWVudC5EaWFsb2dBbmltYXRvcicpO1xyXG4gIH1cclxuICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XHJcbn07XHJcblxyXG5PbnNEaWFsb2dFbGVtZW50LkRpYWxvZ0FuaW1hdG9yID0gRGlhbG9nQW5pbWF0b3I7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxuXHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7XHJcbiAgJyc6ICdmYWItLSonXHJcbn07XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLWZhYlxyXG4gKiBAY2F0ZWdvcnkgZmFiXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxyXG4gKlxyXG4gKiAgICAgSXQgY2FuIGJlIGRpc3BsYXllZCBlaXRoZXIgYXMgYW4gaW5saW5lIGVsZW1lbnQgb3IgaW4gb25lIG9mIHRoZSBjb3JuZXJzLiBOb3JtYWxseSBpdCB3aWxsIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGxvd2VyIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9mYWJcclxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcclxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQgaXMgYSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIHRoYXQgZGlzcGxheXMgYSBtZW51IHdoZW4gdGFwcGVkLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqL1xyXG5jbGFzcyBGYWJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cclxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dVGhlIHBvc2l0aW9uIG9mIHRoZSBidXR0b24uIFNob3VsZCBiZSBhIHN0cmluZyBsaWtlIGBcImJvdHRvbSByaWdodFwiYCBvciBgXCJ0b3AgbGVmdFwiYC4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgbm90IGRlZmluZWQgaXQgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcblxyXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWInKTtcclxuXHJcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuZmFiX19pY29uJykpIHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYWJfX2ljb24nKTtcclxuXHJcbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1yaXBwbGUnKSB7XHJcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XHJcblxyXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG4gICAgdGhpcy5zaG93KCk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcclxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncmlwcGxlJzpcclxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncG9zaXRpb24nOlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfc2hvdygpIHtcclxuICAgIHRoaXMuc2hvdygpO1xyXG4gIH1cclxuXHJcbiAgX2hpZGUoKSB7XHJcbiAgICB0aGlzLmhpZGUoKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVSaXBwbGUoKSB7XHJcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XHJcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXHJcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXHJcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxyXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxyXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcclxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxyXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xyXG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xyXG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxyXG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxyXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcclxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxyXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcclxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XHJcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxyXG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XHJcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxyXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzaG93XHJcbiAgICogQHNpZ25hdHVyZSBzaG93KClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVNob3cgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgc2hvdyhvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcclxuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaGlkZVxyXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1IaWRlIHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXHJcbiAgICogIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XHJcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHZpc2libGVcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXHJcbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgdmlzaWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9PT0gJ3NjYWxlKDEpJyAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgdG9nZ2xlXHJcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgYnV0dG9uLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICB0b2dnbGUoKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc0ZhYkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1mYWInLCB7XHJcbiAgcHJvdG90eXBlOiBGYWJFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLWdlc3R1cmUtZGV0ZWN0b3JcclxuICogQGNhdGVnb3J5IGdlc3R1cmVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXUNvbXBvbmVudCB0byBkZXRlY3QgZmluZ2VyIGdlc3R1cmVzIHdpdGhpbiB0aGUgd3JhcHBlZCBlbGVtZW50LiBTZWUgdGhlIGd1aWRlIGZvciBtb3JlIGRldGFpbHMuWy9lbl1cclxuICogICBbamFd6KaB57Sg5YaF44Gu44K444Kn44K544OB44Oj44O85pON5L2c44KS5qSc55+l44GX44G+44GZ44CC6Kmz44GX44GP44Gv44Ks44Kk44OJ44KS5Y+C54Wn44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cclxuICogQGd1aWRlIERldGVjdGluZ0Zpbmdlckdlc3R1cmVzXHJcbiAqICAgW2VuXURldGVjdGluZyBmaW5nZXIgZ2VzdHVyZXNbL2VuXVxyXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjga7mpJznn6VbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLWdlc3R1cmUtZGV0ZWN0b3Igc3R5bGU9XCJoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlO1wiPlxyXG4gKiAgIC4uLlxyXG4gKiA8L29ucy1nZXN0dXJlLWRldGVjdG9yPlxyXG4gKi9cclxuY2xhc3MgR2VzdHVyZURldGVjdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc0dlc3R1cmVEZXRlY3RvckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1nZXN0dXJlLWRldGVjdG9yJywge1xyXG4gIHByb3RvdHlwZTogR2VzdHVyZURldGVjdG9yRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtaWNvblxyXG4gKiBAY2F0ZWdvcnkgaWNvblxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dXHJcbiAqICAgICBEaXNwbGF5cyBhbiBpY29uLiBUaGUgZm9sbG93aW5nIGljb24gc3VpdGVzIGFyZSBhdmFpbGFibGU6XHJcbiAqXHJcbiAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXHJcbiAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbS8pXHJcbiAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBjb2RlcGVuIHhBaHZnXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pY29uXHJcbiAqIEBndWlkZSBVc2luZ0ljb25zIFtlbl1Vc2luZyBpY29uc1svZW5dW2phXeOCouOCpOOCs+ODs+OCkuS9v+OBhlsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtaWNvblxyXG4gKiAgIGljb249XCJtZC1jYXJcIlxyXG4gKiAgIHNpemU9XCIyMHB4XCJcclxuICogICBzdHlsZT1cImNvbG9yOiByZWRcIj5cclxuICogPC9vbnMtaWNvbj5cclxuICpcclxuICogPG9ucy1idXR0b24+XHJcbiAqICAgPG9ucy1pY29uIGljb249XCJtZC1jYXJcIj48L29ucy1pY29uPlxyXG4gKiAgIENhclxyXG4gKiA8L29ucy1idXR0b24+XHJcbiAqL1xyXG5jbGFzcyBJY29uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBpY29uXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1cclxuICAgKiAgICAgVGhlIGljb24gbmFtZS4gYFwibWQtXCJgIHByZWZpeCBmb3IgTWF0ZXJpYWwgSWNvbnMsIGBcImZhLVwiYCBmb3IgRm9udCBBd2Vzb21lIGFuZCBgXCJpb24tXCJgIHByZWZpeCBmb3IgSW9uaWNvbnMuXHJcbiAgICpcclxuICAgKiAgICAgU2VlIGFsbCBhdmFpbGFibGUgaWNvbnMgb24gdGhlaXIgcmVzcGVjdGl2ZSBzaXRlczpcclxuICAgKlxyXG4gICAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXHJcbiAgICogICAgICogW0lvbmljb25zXShodHRwOi8vaW9uaWNvbnMuY29tKVxyXG4gICAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxyXG4gICAqXHJcbiAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxyXG4gICAqXHJcbiAgICogICAgIFRoZSBjb2RlOlxyXG4gICAqXHJcbiAgICogICAgIGBgYFxyXG4gICAqICAgICA8b25zLWljb25cclxuICAgKiAgICAgICBpY29uPVwiaW9uLWVkaXQsIG1hdGVyaWFsOm1kLWVkaXRcIj5cclxuICAgKiAgICAgPC9vbnMtaWNvbj5cclxuICAgKiAgICAgYGBgXHJcbiAgICpcclxuICAgKiAgICAgd2lsbCBkaXNwbGF5IGBcIm1kLWVkaXRcImAgZm9yIE1hdGVyaWFsIERlc2lnbiBhbmQgYFwiaW9uLWVkaXRcImAgYXMgdGhlIGRlZmF1bHQgaWNvbi5cclxuICAgKiAgIFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBzaXplXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1cclxuICAgKiAgICAgVGhlIHNpemVzIG9mIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIGxnLCAyeCwgM3gsIDR4LCA1eCwgb3IgaW4gdGhlIHNpemUgaW4gcGl4ZWxzLlxyXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cclxuICAgKlxyXG4gICAqICAgICBUaGUgY29kZTpcclxuICAgKlxyXG4gICAqICAgICBgYGBcclxuICAgKiAgICAgPG9ucy1pY29uXHJcbiAgICogICAgICAgaWNvbj1cImlvbi1lZGl0XCJcclxuICAgKiAgICAgICBzaXplPVwiMzJweCwgbWF0ZXJpYWw6MjRweFwiPlxyXG4gICAqICAgICA8L29ucy1pY29uPlxyXG4gICAqICAgICBgYGBcclxuICAgKlxyXG4gICAqICAgICB3aWxsIHJlbmRlciBhcyBhIGAyNHB4YCBpY29uIGlmIHRoZSBgXCJtYXRlcmlhbFwiYCBtb2RpZmllciBpcyBwcmVzZW50IGFuZCBgMzJweGAgb3RoZXJ3aXNlLlxyXG4gICAqICAgWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxyXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBl+OBpuihqOekuuOBl+OBvuOBmeOAgjkwLCAxODAsIDI3MOOBi+OCieaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtd2lkdGhcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dV2hlbiB1c2VkIGluIGEgbGlzdCwgeW91IHdhbnQgdGhlIGljb25zIHRvIGhhdmUgdGhlIHNhbWUgd2lkdGggc28gdGhhdCB0aGV5IGFsaWduIHZlcnRpY2FsbHkgYnkgZGVmaW5pbmcgdGhpcyBhdHRyaWJ1dGUuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgc3BpblxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNwZWNpZnkgd2hldGhlciB0aGUgaWNvbiBzaG91bGQgYmUgc3Bpbm5pbmcuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKFsnaWNvbicsICdzaXplJywgJ21vZGlmaWVyJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZSgpIHtcclxuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcclxuICAgIGNvbnN0IHtjbGFzc0xpc3QsIHN0eWxlfSA9IHRoaXMuX2J1aWxkQ2xhc3NBbmRTdHlsZSh0aGlzLl9nZXRBdHRyaWJ1dGUoJ2ljb24nKSwgdGhpcy5fZ2V0QXR0cmlidXRlKCdzaXplJykpO1xyXG4gICAgdXRpbC5leHRlbmQodGhpcy5zdHlsZSwgc3R5bGUpO1xyXG5cclxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XHJcbiAgfVxyXG5cclxuICBfZ2V0QXR0cmlidXRlKGF0dHIpIHtcclxuICAgIGNvbnN0IHBhcnRzID0gKHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpIHx8ICcnKS5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICBjb25zdCBkZWYgPSBwYXJ0c1swXTtcclxuICAgIGxldCBtZCA9IHBhcnRzWzFdO1xyXG4gICAgbWQgPSAobWQgfHwgJycpLnNwbGl0KC9cXHMqOlxccyovKTtcclxuICAgIHJldHVybiAodXRpbC5oYXNNb2RpZmllcih0aGlzLCBtZFswXSkgPyBtZFsxXSA6IGRlZikgfHwgJyc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgdW5uZWVkZWQgY2xhc3MgdmFsdWUuXHJcbiAgICovXHJcbiAgX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKSB7XHJcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdClcclxuICAgICAgLmZpbHRlcihjbGFzc05hbWUgPT4gL14oZmEkfGZhLXxpb24tfHptZGktKS8udGVzdChjbGFzc05hbWUpKVxyXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xyXG5cclxuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnem1kaScpO1xyXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvbnMtaWNvbi0taW9uJyk7XHJcbiAgfVxyXG5cclxuICBfYnVpbGRDbGFzc0FuZFN0eWxlKGljb25OYW1lLCBzaXplKSB7XHJcbiAgICBjb25zdCBjbGFzc0xpc3QgPSBbJ29ucy1pY29uJ107XHJcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xyXG5cclxuICAgIC8vIEljb25cclxuICAgIGlmIChpY29uTmFtZS5pbmRleE9mKCdpb24tJykgPT09IDApIHtcclxuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xyXG4gICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLWlvbicpO1xyXG4gICAgfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdmYS0nKSA9PT0gMCkge1xyXG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XHJcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYScpO1xyXG4gICAgfSBlbHNlIGlmKGljb25OYW1lLmluZGV4T2YoJ21kLScpID09PSAwKSAge1xyXG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xyXG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaS0nICsgaWNvbk5hbWUuc3BsaXQoL1xcLSguKyk/LylbMV0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XHJcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgaWNvbk5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpemVcclxuICAgIGlmIChzaXplLm1hdGNoKC9eWzEtNV14fGxnJC8pKSB7XHJcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgc2l6ZSk7XHJcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtc2l6ZScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzTGlzdDogY2xhc3NMaXN0LFxyXG4gICAgICBzdHlsZTogc3R5bGVcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zSWNvbkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1pY29uJywge1xyXG4gIHByb3RvdHlwZTogSWNvbkVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXHJcblxyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IHtMYXp5UmVwZWF0RGVsZWdhdGUsIExhenlSZXBlYXRQcm92aWRlcn0gZnJvbSAnb25zL2ludGVybmFsL2xhenktcmVwZWF0JztcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcclxuICogQGNhdGVnb3J5IGxhenktcmVwZWF0XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cclxuICogICAgIEl0IGRvZXMgdGhhdCBieSBcImxhemlseVwiIGxvYWRpbmcgZWxlbWVudHMgaW50byB0aGUgRE9NIHdoZW4gdGhleSBjb21lIGludG8gdmlldyBhbmRcclxuICogICAgIHJlbW92aW5nIGl0ZW1zIGZyb20gdGhlIERPTSB3aGVuIHRoZXkgYXJlIG5vdCB2aXNpYmxlLlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVxyXG4gKiAgICAg44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI5YaF44Gn5o+P55S744GV44KM44KL44Ki44Kk44OG44Og44GuRE9N6KaB57Sg44Gu6Kqt44G/6L6844G/44Gv44CB55S76Z2i44Gr6KaL44GI44Gd44GG44Gr44Gq44Gj44Gf5pmC44G+44Gn6Ieq5YuV55qE44Gr6YGF5bu244GV44KM44CBXHJcbiAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcclxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+OBhuOBk+OBqOOBp+OAgeODkeODleOCqeODvOODnuODs+OCueOCkuWKo+WMluOBleOBm+OCi+OBk+OBqOeEoeOBl+OBq+W3qOWkp+OBquaVsOOBruimgee0oOOCkuaPj+eUu+OBp+OBjeOBvuOBmeOAglxyXG4gKiAgIFsvamFdXHJcbiAqIEBjb2RlcGVuIFF3ckdCbVxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGF6eS1yZXBlYXRcclxuICogQHNlZWFsc28gb25zLWxpc3RcclxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxyXG4gKiAgIFtqYV1gPG9ucy1saXN0PmDopoHntKDjga/jg6rjgrnjg4jjgpLmj4/nlLvjgZnjgovjga7jgavkvb/jgo/jgozjgb7jgZnjgIJbL2phXVxyXG4gKiBAZ3VpZGUgVXNpbmdMYXp5UmVwZWF0XHJcbiAqICAgW2VuXUhvdyB0byB1c2UgTGF6eSBSZXBlYXRbL2VuXVxyXG4gKiAgIFtqYV3jg6zjgqTjgrjjg7zjg6rjg5Tjg7zjg4jjga7kvb/jgYTmlrlbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8c2NyaXB0PlxyXG4gKiAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XHJcbiAqICAgICB2YXIgbGF6eVJlcGVhdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNsaXN0Jyk7XHJcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xyXG4gKiAgICAgIGNyZWF0ZUl0ZW1Db250ZW50OiBmdW5jdGlvbihpLCB0ZW1wbGF0ZSkge1xyXG4gKiAgICAgICAgdmFyIGRvbSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcclxuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xyXG4gKlxyXG4gKiAgICAgICAgcmV0dXJuIGRvbTtcclxuICogICAgICB9LFxyXG4gKiAgICAgIGNvdW50SXRlbXM6IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICAgcmV0dXJuIDEwMDAwMDAwO1xyXG4gKiAgICAgIH0sXHJcbiAqICAgICAgZGVzdHJveUl0ZW06IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XHJcbiAqICAgICAgICBjb25zb2xlLmxvZygnRGVzdHJveWVkIGl0ZW0gd2l0aCBpbmRleDogJyArIGluZGV4KTtcclxuICogICAgICB9XHJcbiAqICAgICB9O1xyXG4gKiAgIH0pO1xyXG4gKiA8L3NjcmlwdD5cclxuICpcclxuICogPG9ucy1saXN0IGlkPVwibGlzdFwiPlxyXG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XHJcbiAqICAgICA8b25zLWxpc3QtaXRlbT48L29ucy1saXN0LWl0ZW0+XHJcbiAqICAgPC9vbnMtbGF6eS1yZXBlYXQ+XHJcbiAqIDwvb25zLWxpc3Q+XHJcbiAqL1xyXG5jbGFzcyBMYXp5UmVwZWF0RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24odGhpcyk7XHJcblxyXG4gICAgLy8gbm90IHZlcnkgZ29vZCBpZGVhIGFuZCBhbHNvIG5vdCBkb2N1bWVudGVkXHJcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RlbGVnYXRlJykpIHtcclxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGVcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BlY2lmeSBhIGRlbGVnYXRlIG9iamVjdCB0byBsb2FkIGFuZCB1bmxvYWQgaXRlbSBlbGVtZW50cy5bL2VuXVxyXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNyZWF0ZUl0ZW1Db250ZW50XHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVxyXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgSFRNTEVsZW1lbnRgLlxyXG4gICAqXHJcbiAgICogICAgIFRvIGhlbHAgcmVuZGVyaW5nIHRoZSBlbGVtZW50LCB0aGUgY3VycmVudCBpbmRleCBhbmQgYSB0ZW1wbGF0ZSBpcyBzdXBwbGllZCBhcyBhcmd1bWVudHMuIFRoZSB0ZW1wbGF0ZSBpcyB0aGUgaW5pdGlhbCBjb250ZW50IG9mIHRoZSBgPG9ucy1sYXp5LXJlcGVhdD5gIGVsZW1lbnQuXHJcbiAgICogICBbL2VuXVxyXG4gICAqICAgW2phXVxyXG4gICAqICAgICDjgZPjga7plqLmlbDjga9gSFRNTEVsZW1lbnRg44KS6L+U44GX44Gm44GP44Gg44GV44GE44CCXHJcbiAgICogICAgIOimgee0oOOCkueUn+aIkOOBl+OChOOBmeOBj+OBmeOCi+OBn+OCgeOBq+OAgeePvuWcqOOBruOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueOBqOODhuODs+ODl+ODrOODvOODiOOBjOW8leaVsOOBq+a4oeOBleOCjOOBvuOBmeOAglxyXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXHJcbiAgICogICBbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY291bnRJdGVtc1xyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TaG91bGQgcmV0dXJuIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3QuWy9lbl1cclxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodFxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1cclxuICAgKiAgICAgU2hvdWxkIHJldHVybiB0aGUgaGVpZ2h0IG9mIGFuIGl0ZW0uIFRoZSBpbmRleCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cclxuICAgKlxyXG4gICAqICAgICBUaGlzIGlzIGltcG9ydGFudCB3aGVuIHJlbmRlcmluZyBsaXN0cyB3aGVyZSB0aGUgaXRlbXMgaGF2ZSBkaWZmZXJlbnQgaGVpZ2h0LlxyXG4gICAqXHJcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXHJcbiAgICogICBbL2VuXVxyXG4gICAqICAgW2phXVxyXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxyXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgIHjgZ3jgozjgZ7jgozjga7jgqLjgqTjg6DjgYzpgZXjgaPjgZ/pq5jjgZXjgpLmjIHjgaTjg6rjgrnjg4jjgpLjg6zjg7Pjg4Djg6rjg7PjgrDjgZnjgovpmpvjgavph43opoHjgafjgZnjgIJcclxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44Kq44OX44K344On44OK44Or44Gn44GZ44CC44KC44GX44GT44Gu6Zai5pWw44GM54Sh44GE5aC05ZCI44Gr44Gv44CBXHJcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxyXG4gICAqICAgWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmRlc3Ryb3lJdGVtXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVxyXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiAgICAgVGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsIGJ1dCBtYXkgYmUgaW1wb3J0YW50IGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cclxuICAgKiAgIFsvZW5dXHJcbiAgICogICBbamFdXHJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OAgeOBguOCi+OCouOCpOODhuODoOOBjERPTeODhOODquODvOOBi+OCiemZpOOBi+OCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOBvuOBmeOAglxyXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcclxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44Kq44OX44K344On44OK44Or44Gn44GZ44GM44CB5ZCE44Ki44Kk44OG44Og44Gu5b6M5Yem55CG44GM5b+F6KaB44Gq5aC05ZCI44Gr44Gv44Oh44Oi44Oq44O844Oq44O844Kv44KS6YG/44GR44KL44Gf44KB44Gr6YeN6KaB44Gn44GZ44CCXHJcbiAgICogICBbL2phXVxyXG4gICAqL1xyXG5cclxuICBzZXQgZGVsZWdhdGUodXNlckRlbGVnYXRlKSB7XHJcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlRWxlbWVudCAmJiB0aGlzLmNoaWxkcmVuWzBdKSB7XHJcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xyXG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyID0gbmV3IExhenlSZXBlYXRQcm92aWRlcih0aGlzLnBhcmVudEVsZW1lbnQsIGRlbGVnYXRlKTtcclxuICB9XHJcblxyXG4gIGdldCBkZWxlZ2F0ZSgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwcm9wZXJ0eSBjYW4gb25seSBiZSB1c2VkIHRvIHNldCB0aGUgZGVsZWdhdGUgb2JqZWN0LicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCByZWZyZXNoXHJcbiAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxyXG4gICAqICAgW2phXeODquOCueODiOOCkuabtOaWsOOBl+OBvuOBmeOAguOCguOBl+ODh+ODvOOCv+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+OBr+OBk+OBruODoeOCveODg+ODieOCkuS9v+OBo+OBpuOBj+OBoOOBleOBhOOAglsvamFdXHJcbiAgICovXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciAmJiB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIucmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAodGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyKSB7XHJcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxud2luZG93Lk9uc0xhenlSZXBlYXRFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbGF6eS1yZXBlYXQnLCB7XHJcbiAgcHJvdG90eXBlOiBMYXp5UmVwZWF0RWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0X19oZWFkZXItLSonfTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1oZWFkZXJcclxuICogQGNhdGVnb3J5IGxpc3RcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXUhlYWRlciBlbGVtZW50IGZvciBsaXN0IGl0ZW1zLiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnQuWy9lbl1cclxuICogICBbamFd44Oq44K544OI6KaB57Sg44Gr5L2/55So44GZ44KL44OY44OD44OA44O855So44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3TjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudFsvZW5dXHJcbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdC1pdGVtPmAgY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBndWlkZSBVc2luZ0xpc3QgW2VuXVVzaW5nIGxpc3RzWy9lbl1bamFd44Oq44K544OI44KS5L2/44GGWy9qYV1cclxuICogQGNvZGVwZW4geXhjQ3RcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXHJcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBoZWFkZXIuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1saXN0PlxyXG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cclxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxyXG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XHJcbiAqIDwvb25zLWxpc3Q+XHJcbiAqL1xyXG5jbGFzcyBMaXN0SGVhZGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaGVhZGVyLlsvZW5dXHJcbiAgICogICBbamFd44OY44OD44OA44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faGVhZGVyJyk7XHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcblxyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xyXG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zTGlzdEhlYWRlckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1saXN0LWhlYWRlcicsIHtcclxuICBwcm90b3R5cGU6IExpc3RIZWFkZXJFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7XHJcbiAgJy5saXN0X19pdGVtJzogJ2xpc3RfX2l0ZW0tLSonLFxyXG4gICcubGlzdF9faXRlbV9fbGVmdCc6ICdsaXN0X19pdGVtLS0qX19sZWZ0JyxcclxuICAnLmxpc3RfX2l0ZW1fX2NlbnRlcic6ICdsaXN0X19pdGVtLS0qX19jZW50ZXInLFxyXG4gICcubGlzdF9faXRlbV9fcmlnaHQnOiAnbGlzdF9faXRlbS0tKl9fcmlnaHQnLFxyXG4gICcubGlzdF9faXRlbV9fbGFiZWwnOiAnbGlzdF9faXRlbS0tKl9fbGFiZWwnLFxyXG4gICcubGlzdF9faXRlbV9fdGl0bGUnOiAnbGlzdF9faXRlbS0tKl9fdGl0bGUnLFxyXG4gICcubGlzdF9faXRlbV9fc3VidGl0bGUnOiAnbGlzdF9faXRlbS0tKl9fc3VidGl0bGUnLFxyXG4gICcubGlzdF9faXRlbV9fdGh1bWJuYWlsJzogJ2xpc3RfX2l0ZW0tLSpfX3RodW1ibmFpbCcsXHJcbiAgJy5saXN0X19pdGVtX19pY29uJzogJ2xpc3RfX2l0ZW0tLSpfX2ljb24nXHJcbn07XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLWxpc3QtaXRlbVxyXG4gKiBAY2F0ZWdvcnkgbGlzdFxyXG4gKiBAbW9kaWZpZXIgdGFwcGFibGVcclxuICogICBbZW5dTWFrZSB0aGUgbGlzdCBpdGVtIGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gaXQncyB0YXBwZWQuIE9uIGlPUyBpdCBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBcInRhcHBhYmxlXCIgYW5kIFwidGFwLWJhY2tncm91bmQtY29sb3JcIiBhdHRyaWJ1dGUgZm9yIGJldHRlciBiZWhhdmlvciB3aGVuIHNjcm9sbGluZy5bL2VuXVxyXG4gKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZfjgZ/mmYLjgavlirnmnpzjgYzooajnpLrjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gKiBAbW9kaWZpZXIgY2hldnJvblxyXG4gKiAgIFtlbl1EaXNwbGF5IGEgY2hldnJvbiBhdCB0aGUgcmlnaHQgZW5kIG9mIHRoZSBsaXN0IGl0ZW0gYW5kIG1ha2UgaXQgY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiB0YXBwZWQuIFRoZSBjaGV2cm9uIGlzIG5vdCBkaXNwbGF5ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBtb2RpZmllciBsb25nZGl2aWRlclxyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQG1vZGlmaWVyIG5vZGl2aWRlclxyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcclxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgcmVwcmVzZW50cyBlYWNoIGl0ZW0gaW4gdGhlIGxpc3QuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5cclxuICpcclxuICogICAgIFRoZSBsaXN0IGl0ZW0gaXMgY29tcG9zZWQgb2YgdGhyZWUgcGFydHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgYGxlZnRgLCBgY2VudGVyYCBhbmQgYHJpZ2h0YCBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBsaXN0IGl0ZW1zIGlzIHByb3Blcmx5IGFsaWduZWQuXHJcbiAqXHJcbiAqICAgICBgYGBcclxuICogICAgIDxvbnMtbGlzdC1pdGVtPlxyXG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPkxlZnQ8L2Rpdj5cclxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPkNlbnRlcjwvZGl2PlxyXG4gKiAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5SaWdodDwvZGl2PlxyXG4gKiAgICAgPC9vbnMtbGlzdC1pdGVtPlxyXG4gKiAgICAgYGBgXHJcbiAqXHJcbiAqICAgICBUaGVyZSBpcyBhbHNvIGEgbnVtYmVyIG9mIGNsYXNzZXMgKHByZWZpeGVkIHdpdGggYGxpc3RfX2l0ZW1fXypgKSB0aGF0IGhlbHAgd2hlbiBwdXR0aW5nIHRoaW5ncyBsaWtlIGljb25zIGFuZCB0aHVtYm5haWxzIGludG8gdGhlIGxpc3QgaXRlbXMuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQHNlZWFsc28gb25zLWxpc3RcclxuICogICBbZW5db25zLWxpc3QgY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcclxuICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXHJcbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBndWlkZSBVc2luZ0xpc3RcclxuICogICBbZW5dVXNpbmcgbGlzdHNbL2VuXVxyXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxyXG4gKiBAY29kZXBlbiB5eGNDdFxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLWxpc3QtaXRlbT5cclxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxyXG4gKiAgICAgPG9ucy1pY29uIGljb249XCJtZC1mYWNlXCIgY2xhc3M9XCJsaXN0X19pdGVtX19pY29uXCI+PC9vbnMtaWNvbj5cclxuICogICA8L2Rpdj5cclxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XHJcbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdF9faXRlbV9fdGl0bGVcIj5UaXRsZTwvZGl2PlxyXG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3RfX2l0ZW1fX3N1YnRpdGxlXCI+U3VidGl0bGU8L2Rpdj5cclxuICogICA8L2Rpdj5cclxuICogICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cclxuICogICAgIDxvbnMtc3dpdGNoPjwvb25zLXN3aXRjaD5cclxuICogICA8L2Rpdj5cclxuICogPC9vbnMtbGlzdC1pdGVtPlxyXG4gKi9cclxuY2xhc3MgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBpdGVtLlsvZW5dXHJcbiAgICogICBbamFd5ZCE6KaB57Sg44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBsb2NrLW9uLWRyYWdcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgaG9yaXpvbnRhbGx5LlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CB44Om44O844K244O844GM44GT44Gu6KaB57Sg44KS5qiq5pa55ZCR44Gr44OJ44Op44OD44Kw44GX44Gm44GE44KL5pmC44Gr44CB57im5pa55ZCR44Gu44K544Kv44Ot44O844Or44GM6LW344GN44Gq44GE44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSB0YXBwYWJsZVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXU1ha2VzIHRoZSBlbGVtZW50IHJlYWN0IHRvIHRhcHMuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHRhcC1iYWNrZ3JvdW5kLWNvbG9yXHJcbiAgICogQHR5cGUge0NvbG9yfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXSBDaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBGb3IgdGhpcyB0byB3b3JrLCB0aGUgYXR0cmlidXRlIFwidGFwcGFibGVcIiBuZWVkcyB0byBiZSBzZXQuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIFwiI2Q5ZDlkOVwiLiBJdCB3aWxsIGRpc3BsYXkgYXMgYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW0nKTtcclxuXHJcbiAgICBsZXQgbGVmdCwgY2VudGVyLCByaWdodDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnbGVmdCcpKSB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbV9fbGVmdCcpO1xyXG4gICAgICAgIGxlZnQgPSBlbDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NlbnRlcicpKSB7XHJcbiAgICAgICAgY2VudGVyID0gZWw7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbV9fcmlnaHQnKTtcclxuICAgICAgICByaWdodCA9IGVsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjZW50ZXIpIHtcclxuICAgICAgY2VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gICAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xyXG4gICAgICAgICAgY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xyXG4gICAgICAgICAgaWYgKGVsICE9PSBsZWZ0ICYmIGVsICE9PSByaWdodCkge1xyXG4gICAgICAgICAgICBjZW50ZXIuaW5zZXJ0QmVmb3JlKGVsLCBjZW50ZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShjZW50ZXIsIHJpZ2h0IHx8IG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInKTtcclxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19jZW50ZXInKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcclxuXHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcclxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncmlwcGxlJzpcclxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uVG91Y2gpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUmVsZWFzZSk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25SZWxlYXNlKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUmVsZWFzZSk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIHRoaXMuX29uUmVsZWFzZSk7XHJcblxyXG4gICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuXHJcbiAgICB0aGlzLnRhcHBlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25SZWxlYXNlKTtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9vblJlbGVhc2UpO1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcclxuICB9XHJcblxyXG4gIGdldCBfdHJhbnNpdGlvbigpIHtcclxuICAgIHJldHVybiAnYmFja2dyb3VuZC1jb2xvciAwLjBzIGxpbmVhciAwLjAycywgYm94LXNoYWRvdyAwLjBzIGxpbmVhciAwLjAycyc7XHJcbiAgfVxyXG5cclxuICBnZXQgX3RhcHBhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF90YXBCYWNrZ3JvdW5kQ29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhcC1iYWNrZ3JvdW5kLWNvbG9yJykgfHwgJyNkOWQ5ZDknO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVJpcHBsZSgpIHtcclxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgX29uRHJhZyhldmVudCkge1xyXG4gICAgY29uc3QgZ2VzdHVyZSA9IGV2ZW50Lmdlc3R1cmU7XHJcbiAgICAvLyBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyBpZiB0aGUgdXNlcnMgcGFucyBsZWZ0IG9yIHJpZ2h0LlxyXG4gICAgaWYgKHRoaXMuX3Nob3VsZExvY2tPbkRyYWcoKSAmJiBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGdlc3R1cmUuZGlyZWN0aW9uKSA+IC0xKSB7XHJcbiAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vblRvdWNoKCkge1xyXG4gICAgaWYgKHRoaXMudGFwcGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRhcHBlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcclxuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XHJcbiAgICB0aGlzLnN0eWxlLk1velRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLl90YXBwYWJsZSkge1xyXG4gICAgICBpZiAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX3RhcEJhY2tncm91bmRDb2xvcjtcclxuICAgICAgdGhpcy5zdHlsZS5ib3hTaGFkb3cgPSBgMHB4IC0xcHggMHB4IDBweCAke3RoaXMuX3RhcEJhY2tncm91bmRDb2xvcn1gO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uUmVsZWFzZSgpIHtcclxuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcclxuICAgIHRoaXMuc3R5bGUuTW96VHJhbnNpdGlvbiA9ICcnO1xyXG5cclxuICAgIHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgfHwgJyc7XHJcbiAgICB0aGlzLnN0eWxlLmJveFNoYWRvdyA9ICcnO1xyXG4gIH1cclxuXHJcbiAgX3Nob3VsZExvY2tPbkRyYWcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc0xpc3RJdGVtRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWxpc3QtaXRlbScsIHtcclxuICBwcm90b3R5cGU6IExpc3RJdGVtRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LS0qJ307XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLWxpc3RcclxuICogQGNhdGVnb3J5IGxpc3RcclxuICogQG1vZGlmaWVyIGluc2V0XHJcbiAqICAgW2VuXUluc2V0IGxpc3QgdGhhdCBkb2Vzbid0IGNvdmVyIHRoZSB3aG9sZSB3aWR0aCBvZiB0aGUgcGFyZW50LlsvZW5dXHJcbiAqICAgW2phXeimquimgee0oOOBrueUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCieOBquOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBtb2RpZmllciBub2JvcmRlclxyXG4gKiAgIFtlbl1BIGxpc3Qgd2l0aCBubyBib3JkZXJzIGF0IHRoZSB0b3AgYW5kIGJvdHRvbS5bL2VuXVxyXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dQ29tcG9uZW50IHRvIGRlZmluZSBhIGxpc3QsIGFuZCB0aGUgY29udGFpbmVyIGZvciBvbnMtbGlzdC1pdGVtKHMpLlsvZW5dXHJcbiAqICAgW2phXeODquOCueODiOOCkuihqOePvuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN0LWl0ZW3jga7jgrPjg7Pjg4bjg4rjgajjgZfjgabkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXHJcbiAqICAgW2VuXW9ucy1saXN0LWl0ZW0gY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGd1aWRlIFVzaW5nTGlzdFxyXG4gKiAgIFtlbl1Vc2luZyBsaXN0c1svZW5dXHJcbiAqICAgW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXHJcbiAqIEBjb2RlcGVuIHl4Y0N0XHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtbGlzdD5cclxuICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XHJcbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cclxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxyXG4gKiA8L29ucy1saXN0PlxyXG4gKi9cclxuY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXHJcbiAgICogICBbamFd44Oq44K544OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcclxuICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3QnKTtcclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XHJcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNMaXN0RWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWxpc3QnLCB7XHJcbiAgcHJvdG90eXBlOiBMaXN0RWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7XHJcbiAgJy50ZXh0LWlucHV0JzogJ3RleHQtaW5wdXQtLSonLFxyXG4gICcudGV4dC1pbnB1dF9fbGFiZWwnOiAndGV4dC1pbnB1dC0tKl9fbGFiZWwnLFxyXG4gICcucmFkaW8tYnV0dG9uJzogJ3JhZGlvLWJ1dHRvbi0tKicsXHJcbiAgJy5yYWRpby1idXR0b25fX2lucHV0JzogJ3JhZGlvLWJ1dHRvbi0tKl9faW5wdXQnLFxyXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnLFxyXG4gICcuY2hlY2tib3gnOiAnY2hlY2tib3gtLSonLFxyXG4gICcuY2hlY2tib3hfX2lucHV0JzogJ2NoZWNrYm94LS0qX19pbnB1dCcsXHJcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXHJcbn07XHJcblxyXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xyXG4gICdhdXRvY2FwaXRhbGl6ZScsXHJcbiAgJ2F1dG9jb21wbGV0ZScsXHJcbiAgJ2F1dG9jb3JyZWN0JyxcclxuICAnYXV0b2ZvY3VzJyxcclxuICAnZGlzYWJsZWQnLFxyXG4gICdpbnB1dG1vZGUnLFxyXG4gICdtYXgnLFxyXG4gICdtYXhsZW5ndGgnLFxyXG4gICdtaW4nLFxyXG4gICdtaW5sZW5ndGgnLFxyXG4gICduYW1lJyxcclxuICAncGF0dGVybicsXHJcbiAgJ3BsYWNlaG9sZGVyJyxcclxuICAncmVhZG9ubHknLFxyXG4gICdzaXplJyxcclxuICAnc3RlcCcsXHJcbiAgJ3R5cGUnLFxyXG4gICd2YWxpZGF0b3InLFxyXG4gICd2YWx1ZSdcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtaW5wdXRcclxuICogQGNhdGVnb3J5IGlucHV0XHJcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxyXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0LlsvZW5dXHJcbiAqICBbamFdWy9qYV1cclxuICogQG1vZGlmaWVyIHVuZGVyYmFyXHJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHRleHQgaW5wdXQuWy9lbl1cclxuICogIFtqYV1bL2phXVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogIFtlbl1cclxuICogICAgQW4gaW5wdXQgZWxlbWVudC4gVGhlIGB0eXBlYCBhdHRyaWJ1dGUgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBpbnB1dCB0eXBlLiBBbGwgdGV4dCBpbnB1dCB0eXBlcyBhcyB3ZWxsIGFzIGBjaGVja2JveGAgYW5kIGByYWRpb2AgYXJlIHN1cHBvcnRlZC5cclxuICpcclxuICogICAgVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0IG9uIEFuZHJvaWQgZGV2aWNlcy5cclxuICpcclxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQ+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWlucHV0PmAgZWxlbWVudC5cclxuICogIFsvZW5dXHJcbiAqICBbamFdWy9qYV1cclxuICogQGNvZGVwZW4gb2pReExqXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxyXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcclxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQHNlZWFsc28gb25zLXN3aXRjaFxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAZ3VpZGUgVXNpbmdGb3JtQ29tcG9uZW50c1xyXG4gKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxyXG4gKiAgIFtqYV3jg5Xjgqnjg7zjg6DjgpLkvb/jgYZbL2phXVxyXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xyXG4gKiAgIFtlbl1FdmVudCBoYW5kbGluZyBkZXNjcmlwdGlvbnNbL2VuXVxyXG4gKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLWlucHV0IHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiBmbG9hdD48L29ucy1pbnB1dD5cclxuICogPG9ucy1pbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPjwvb25zLWlucHV0PlxyXG4gKi9cclxuY2xhc3MgSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1QbGFjZWhvbGRlciB0ZXh0LiBJbiBNYXRlcmlhbCBEZXNpZ24sIHRoaXMgcGxhY2Vob2xkZXIgd2lsbCBiZSBhIGZsb2F0aW5nIGxhYmVsLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBmbG9hdFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgYW5pbWF0ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXHJcbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/mmYLjgIHjg6njg5njg6vjga/jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHR5cGVcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dXHJcbiAgICogICAgU3BlY2lmeSB0aGUgaW5wdXQgdHlwZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgXCJ0eXBlXCIgYXR0cmlidXRlIGZvciBub3JtYWwgaW5wdXRzLiBIb3dldmVyLCBmb3IgXCJyYW5nZVwiIHlvdSBzaG91bGQgaW5zdGVhZCB1c2UgPG9ucy1yYW5nZT4gZWxlbWVudC5cclxuICAgKlxyXG4gICAqICAgIFBsZWFzZSB0YWtlIGEgbG9vayBhdCBbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjYXR0ci10eXBlKSBmb3IgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSBhbmQgYnJvd3NlciB2ZXJzaW9uIHNvbWUgb2YgdGhlc2UgbWlnaHQgbm90IHdvcmsuXHJcbiAgICogIFsvZW5dXHJcbiAgICogIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIDxsYWJlbCBmb3I9XCIuLi5cIj4gZWxlbWVudHMuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgY29udGVudC1sZWZ0XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1UaGUgSFRNTCBjb250ZW50IG9mIGA8b25zLWlucHV0PmAgaXMgcGxhY2VkIGJlZm9yZSB0aGUgYWN0dWFsIGlucHV0IGFzIGEgbGFiZWwuIE9taXQgdGhpcyB0byBkaXNwbGF5IGl0IGFmdGVyIHRoZSBpbnB1dC5bL2VuXVxyXG4gICAqICBbamFdWy9qYV1cclxuICAgKi9cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnY2hlY2tlZCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdjaGVja2VkJykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fYm91bmRPbklucHV0ID0gdGhpcy5fb25JbnB1dC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fYm91bmRPbkZvY3VzaW4gPSB0aGlzLl9vbkZvY3VzaW4uYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kT25Gb2N1c291dCA9IHRoaXMuX29uRm9jdXNvdXQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCA9IHRoaXMuX2RlbGVnYXRlRXZlbnQuYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoZWxwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICBoZWxwZXIuY2xhc3NMaXN0LmFkZCgnX2hlbHBlcicpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVscGVyKTtcclxuXHJcbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2lucHV0LWxhYmVsJyk7XHJcblxyXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4gbGFiZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCkpO1xyXG4gICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQtbGVmdCcpID8gY29udGFpbmVyLmluc2VydEJlZm9yZShsYWJlbCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcbiAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XHJcbiAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94Jyk7XHJcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3hfX2lucHV0Jyk7XHJcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94X19jaGVja21hcmsnKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbicpO1xyXG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9faW5wdXQnKTtcclxuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uX19jaGVja21hcmsnKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dCcpO1xyXG4gICAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19sYWJlbCcpO1xyXG4gICAgICAgIHRoaXMuX2lucHV0LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fY29udGFpbmVyJyk7XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDb2xvcigpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2lucHV0LWlkJykpIHtcclxuICAgICAgdGhpcy5faW5wdXQuaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaW5wdXQtaWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcclxuICAgICAgcmV0dXJuIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XHJcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwbGFjZWhvbGRlcicpIHtcclxuICAgICAgcmV0dXJuIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVMYWJlbCgpKTtcclxuICAgIH0gaWYgKG5hbWUgPT09ICdpbnB1dC1pZCcpIHtcclxuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2lucHV0LmlkID0gY3VycmVudCk7XHJcbiAgICB9IGlmIChuYW1lID09PSAnY2hlY2tlZCcpIHtcclxuICAgICAgdGhpcy5jaGVja2VkID0gY3VycmVudCAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XHJcbiAgICAgIHJldHVybiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLl9pbnB1dC50eXBlICE9PSAnY2hlY2tib3gnICYmIHRoaXMuX2lucHV0LnR5cGUgIT09ICdyYWRpbycpIHtcclxuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XHJcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcclxuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX2JvdW5kT25Gb2N1c291dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcclxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XHJcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XHJcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcclxuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xyXG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3NldExhYmVsKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhpcy5faGVscGVyLnRleHRDb250ZW50ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5faGVscGVyLmlubmVyVGV4dCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUxhYmVsKCkge1xyXG4gICAgdGhpcy5fc2V0TGFiZWwodGhpcy5oYXNBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSA6ICcnKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XHJcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goKGF0dHIpID0+IHtcclxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XHJcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUxhYmVsQ29sb3IoKSB7XHJcbiAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2lucHV0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuX2hlbHBlci5zdHlsZS5jb2xvciA9ICcnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMuX2hlbHBlci5zdHlsZS5jb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuNSknO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUxhYmVsQ2xhc3MoKSB7XHJcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcclxuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtaW5wdXRfX2xhYmVsLS1hY3RpdmUnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykpID09PSAtMSl7XHJcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19sYWJlbC0tYWN0aXZlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZGVsZWdhdGVFdmVudChldmVudCkge1xyXG4gICAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7XHJcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxyXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xyXG4gIH1cclxuXHJcbiAgX29uSW5wdXQoZXZlbnQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcclxuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ29sb3IoKTtcclxuICB9XHJcblxyXG4gIF9vbkZvY3VzaW4oZXZlbnQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcclxuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ29sb3IoKTtcclxuICB9XHJcblxyXG4gIF9vbkZvY3Vzb3V0KGV2ZW50KSB7XHJcbiAgICB0aGlzLl91cGRhdGVMYWJlbENvbG9yKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgX2lucHV0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICB9XHJcblxyXG4gIGdldCBfaGVscGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLl9oZWxwZXInKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcclxuICAgICAgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxyXG4gICAgICA6IHRoaXMuX2lucHV0LnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHZhbHVlKHZhbCkge1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsKTtcclxuXHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcclxuICAgICAgdGhpcy5fb25JbnB1dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHZhbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgaW5wdXQgaXMgY2hlY2tlZCBvciBub3QuIE9ubHkgd29ya3MgZm9yIGByYWRpb2AgYW5kIGBjaGVja2JveGAgdHlwZSBpbnB1dHMuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGdldCBjaGVja2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LmNoZWNrZWQ7XHJcbiAgfVxyXG5cclxuICBzZXQgY2hlY2tlZCh2YWwpIHtcclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2lucHV0LmNoZWNrZWQgPSB2YWw7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF9pc1RleHRJbnB1dCgpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUgIT09ICdyYWRpbycgJiYgdGhpcy50eXBlICE9PSAnY2hlY2tib3gnO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNJbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1pbnB1dCcsIHtcclxuICBwcm90b3R5cGU6IElucHV0RWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEFuaW1hdG9yIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLmRlbGF5ID0gMDtcclxuICAgIHRoaXMuZHVyYXRpb24gPSAwLjI7XHJcblxyXG4gICAgdGhpcy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyB8fCB0aGlzLnRpbWluZztcclxuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogdGhpcy5kdXJhdGlvbjtcclxuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogdGhpcy5kZWxheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9XHJcbn1cclxuIiwiXHJcbi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcclxuXHJcbi8qKlxyXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XHJcbiAgICBvcHRpb25zLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCAnMC4zJztcclxuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XHJcblxyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgYW5pbWl0KG1vZGFsKVxyXG4gICAgICAucXVldWUoe1xyXG4gICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgfSlcclxuICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgLnF1ZXVlKHtcclxuICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgfSwge1xyXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgfSlcclxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgfSlcclxuICAgICAgLnBsYXkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBhbmltaXQobW9kYWwpXHJcbiAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICB9KVxyXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAucXVldWUoe1xyXG4gICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgfSwge1xyXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgfSlcclxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgfSlcclxuICAgICAgLnBsYXkoKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xyXG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcclxuaW1wb3J0IEZhZGVNb2RhbEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XHJcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xyXG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnb25zL2Rvb3Jsb2NrJztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7XHJcbiAgJyc6ICdtb2RhbC0tKicsXHJcbiAgJ21vZGFsX19jb250ZW50JzogJ21vZGFsLS0qX19jb250ZW50J1xyXG59O1xyXG5cclxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcclxuICAnZGVmYXVsdCc6IE1vZGFsQW5pbWF0b3IsXHJcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcclxuICAnbm9uZSc6IE1vZGFsQW5pbWF0b3JcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtbW9kYWxcclxuICogQGNhdGVnb3J5IG1vZGFsXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIE1vZGFsIGNvbXBvbmVudCB0aGF0IG1hc2tzIGN1cnJlbnQgc2NyZWVuLiBVbmRlcmx5aW5nIGNvbXBvbmVudHMgYXJlIG5vdCBzdWJqZWN0IHRvIGFueSBldmVudHMgd2hpbGUgdGhlIG1vZGFsIGNvbXBvbmVudCBpcyBzaG93bi5cclxuICpcclxuICogICAgIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGJsb2NrIHVzZXIgaW5wdXQgd2hpbGUgc29tZSBvcGVyYXRpb24gaXMgcnVubmluZyBvciB0byBzaG93IHNvbWUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdXHJcbiAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcclxuICogICAgIOODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBpuOBhOOCi+mWk+OBr+OCpOODmeODs+ODiOmAmuefpeOBjOihjOOCj+OCjOOBvuOBm+OCk+OAglxyXG4gKiAgIFsvamFdXHJcbiAqIEBndWlkZSBVc2luZ01vZGFsXHJcbiAqICAgW2VuXVVzaW5nIG9ucy1tb2RhbCBjb21wb25lbnRbL2VuXVxyXG4gKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7kvb/jgYTmlrlbL2phXVxyXG4gKiBAZ3VpZGUgQ2FsbGluZ0NvbXBvbmVudEFQSXNmcm9tSmF2YVNjcmlwdFxyXG4gKiAgIFtlbl1Vc2luZyBuYXZpZ2F0b3IgZnJvbSBKYXZhU2NyaXB0Wy9lbl1cclxuICogICBbamFdSmF2YVNjcmlwdOOBi+OCieOCs+ODs+ODneODvOODjeODs+ODiOOCkuWRvOOBs+WHuuOBmVsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1kaWFsb2dcclxuICogICBbZW5dVGhlIGA8b25zLWRpYWxvZz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBtb2RhbCBkaWFsb2cuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGNvZGVwZW4gZGV2SWdcclxuICogQGV4YW1wbGVcclxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XHJcbiAqICAgTW9kYWwgY29udGVudFxyXG4gKiA8L29ucy1tb2RhbD5cclxuICogPHNjcmlwdD5cclxuICogICB2YXIgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwnKTtcclxuICogICBtb2RhbC5zaG93KCk7XHJcbiAqIDwvc2NyaXB0PlxyXG4gKi9cclxuY2xhc3MgTW9kYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlZmF1bHQgZGVmYXVsdFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImZhZGVcImAuWy9lbl1cclxuICAgKiAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJmYWRlXCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXHJcbiAgICogQHR5cGUge0V4cHJlc3Npb259XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xyXG5cclxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xyXG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXHJcbiAgICAgIGJhc2VDbGFzczogTW9kYWxBbmltYXRvcixcclxuICAgICAgYmFzZUNsYXNzTmFtZTogJ01vZGFsQW5pbWF0b3InLFxyXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cclxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGhhbmRsZXIpIHtcclxuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xyXG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGhhbmRsZXIpO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ21vZGFsJyk7XHJcblxyXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLm1vZGFsX19jb250ZW50JykpIHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XHJcblxyXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcclxuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHNldEltbWVkaWF0ZSh0aGlzLl9lbnN1cmVOb2RlUG9zaXRpb24uYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9ICgpID0+IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIF9lbnN1cmVOb2RlUG9zaXRpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fCB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xyXG4gICAgICB2YXIgcGFnZSA9IHRoaXM7XHJcbiAgICAgIGZvciAoOzspIHtcclxuICAgICAgICBwYWdlID0gcGFnZS5wYXJlbnROb2RlO1xyXG5cclxuICAgICAgICBpZiAoIXBhZ2UpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtcGFnZScpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwYWdlLl9yZWdpc3RlckV4dHJhRWxlbWVudCh0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIHNob3dcclxuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXHJcbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXHJcbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNob3cgbW9kYWwuWy9lbl1cclxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcclxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxyXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBjb25zdCB0cnlTaG93ID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XHJcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xyXG5cclxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgIGFuaW1hdG9yLnNob3codGhpcywgKCkgPT4ge1xyXG4gICAgICAgICAgdW5sb2NrKCk7XHJcblxyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIHJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCB0b2dnbGVcclxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXHJcbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXHJcbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVG9nZ2xlIG1vZGFsIHZpc2liaWxpdHkuWy9lbl1cclxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIHRvZ2dsZSgpIHtcclxuICAgIGlmICh0aGlzLnZpc2libGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2hvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBoaWRlXHJcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxyXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1IaWRlIG1vZGFsLlsvZW5dXHJcbiAgICogICBbamFd44Oi44O844OA44Or44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXHJcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcclxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgY29uc3QgdHJ5SGlkZSA9ICgpID0+IHtcclxuICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xyXG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgIHVubG9jaygpO1xyXG5cclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICByZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xyXG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zTW9kYWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbW9kYWwnLCB7XHJcbiAgcHJvdG90eXBlOiBNb2RhbEVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXHJcbiAqL1xyXG53aW5kb3cuT25zTW9kYWxFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xyXG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGFsQW5pbWF0b3IpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zTW9kYWxFbGVtZW50Lk1vZGFsQW5pbWF0b3InKTtcclxuICB9XHJcbiAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xyXG59O1xyXG5cclxud2luZG93Lk9uc01vZGFsRWxlbWVudC5Nb2RhbEFuaW1hdG9yID0gTW9kYWxBbmltYXRvcjtcclxuXHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xyXG4gICAgICB0aW1pbmc6ICdsaW5lYXInLFxyXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXHJcbiAgICAgIGRlbGF5OiAnMCdcclxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmc7XHJcbiAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcclxuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xyXG4gIH1cclxuXHJcbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfVxyXG5cclxuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjaygpO1xyXG4gIH1cclxufVxyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuXHJcbi8qKlxyXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24gbGlrZSBpT1MncyBzY3JlZW4gc2xpZGUgdHJhbnNpdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcclxuICAgICAgZHVyYXRpb246IDAuNCxcclxuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcclxuICAgICAgZGVsYXk6IDBcclxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgIHN1cGVyKG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxyXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwOyB6LWluZGV4OiAyXCI+PC9kaXY+XHJcbiAgICBgKTtcclxuICB9XHJcblxyXG4gIF9kZWNvbXBvc2UocGFnZSkge1xyXG4gICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShwYWdlKTtcclxuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xyXG4gICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZSh0b29sYmFyKTtcclxuICAgIGNvbnN0IGxlZnQgPSB0b29sYmFyLl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpO1xyXG4gICAgY29uc3QgcmlnaHQgPSB0b29sYmFyLl9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKTtcclxuXHJcbiAgICBjb25zdCBleGNsdWRlQmFja0J1dHRvbkxhYmVsID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtYmFjay1idXR0b24nKSB7XHJcbiAgICAgICAgICBjb25zdCBpY29uRWxlbWVudCA9IGVsZW1lbnRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrLWJ1dHRvbl9faWNvbicpO1xyXG4gICAgICAgICAgaWYgKGljb25FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGljb25FbGVtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3RoZXIgPSBbXVxyXG4gICAgICAuY29uY2F0KGxlZnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gbGVmdCA6IGV4Y2x1ZGVCYWNrQnV0dG9uTGFiZWwobGVmdC5jaGlsZHJlbikpXHJcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbkxhYmVsKHJpZ2h0LmNoaWxkcmVuKSk7XHJcblxyXG4gICAgY29uc3QgcGFnZUxhYmVscyA9IFtcclxuICAgICAgdG9vbGJhci5fZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCgpLFxyXG4gICAgICB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBhZ2VMYWJlbHM6IHBhZ2VMYWJlbHMsXHJcbiAgICAgIG90aGVyOiBvdGhlcixcclxuICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcclxuICAgICAgYmFja2dyb3VuZDogcGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSxcclxuICAgICAgdG9vbGJhcjogdG9vbGJhcixcclxuICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIF9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xyXG4gICAgY29uc3QgYm90aFBhZ2VIYXNUb29sYmFyID1cclxuICAgICAgZW50ZXJQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpICYmIGxlYXZlUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKTtcclxuXHJcbiAgICB2YXIgbm9NYXRlcmlhbFRvb2xiYXIgPVxyXG4gICAgICAhZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbmF2aWdhdGlvbi1iYXItLW1hdGVyaWFsJykgJiZcclxuICAgICAgIWxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ25hdmlnYXRpb24tYmFyLS1tYXRlcmlhbCcpO1xyXG5cclxuICAgIHJldHVybiBib3RoUGFnZUhhc1Rvb2xiYXIgJiYgbm9NYXRlcmlhbFRvb2xiYXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcclxuXHJcbiAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZSk7XHJcbiAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZSk7XHJcblxyXG4gICAgY29uc3QgZGVsdGEgPSAoKCkgPT4ge1xyXG4gICAgICBjb25zdCByZWN0ID0gbGVhdmVQYWdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMikgKiAwLjYpO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcclxuICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcclxuICAgICAgfSlcclxuICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgLnF1ZXVlKHtcclxuICAgICAgICBvcGFjaXR5OiAwLjFcclxuICAgICAgfSwge1xyXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgfSlcclxuICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgIC5xdWV1ZSgoZG9uZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcclxuXHJcbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcclxuICAgICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgICAgbWFza0NsZWFyLFxyXG5cclxuICAgICAgICBhbmltaXQoW2VudGVyUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxyXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxyXG5cclxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5wYWdlTGFiZWxzKVxyXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEgKyAncHgsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXHJcblxyXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxyXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxyXG5cclxuICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxyXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24ucGFnZUxhYmVscylcclxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxyXG4gICAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhICsgJ3B4LCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXHJcblxyXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxyXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcblxyXG4gICAgICApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgICBtYXNrQ2xlYXIsXHJcblxyXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXHJcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXHJcblxyXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxyXG4gICAqL1xyXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSkge1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcclxuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UubmV4dFNpYmxpbmcpO1xyXG5cclxuICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlKTtcclxuICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlKTtcclxuXHJcbiAgICBjb25zdCBkZWx0YSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgY29uc3QgcmVjdCA9IGxlYXZlUGFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIpICogMC42KTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXHJcbiAgICAgIC5zYXZlU3R5bGUoKVxyXG4gICAgICAucXVldWUoe1xyXG4gICAgICAgIG9wYWNpdHk6IDAuMSxcclxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcclxuICAgICAgfSlcclxuICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgLnF1ZXVlKHtcclxuICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgIH0sIHtcclxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgIH0pXHJcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxyXG4gICAgICAucXVldWUoKGRvbmUpID0+IHtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xyXG5cclxuICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xyXG4gICAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgICBtYXNrQ2xlYXIsXHJcblxyXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXHJcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXHJcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC45XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXHJcblxyXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnBhZ2VMYWJlbHMpXHJcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEgKyAncHgsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXHJcblxyXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXHJcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcclxuXHJcbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpXHJcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXHJcblxyXG4gICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC53YWl0KDApXHJcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgZmluaXNoKCk7XHJcbiAgICAgICAgICB9LmJpbmQodGhpcykpLFxyXG5cclxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnBhZ2VMYWJlbHMpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBkZWx0YSArICdweCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgICAgbWFza0NsZWFyLFxyXG5cclxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxyXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxyXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXHJcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxyXG5cclxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxyXG4gICAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgZmluaXNoKCk7XHJcbiAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcblxyXG4vKipcclxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xyXG4gICAgICBkdXJhdGlvbjogMC40LFxyXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxyXG4gICAgICBkZWxheTogMFxyXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXHJcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGJsYWNrLCB3aGl0ZSk7XCI+PC9kaXY+XHJcbiAgICBgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcclxuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UpO1xyXG5cclxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxyXG4gICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcclxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG5cclxuICAgICAgbWFza0NsZWFyLFxyXG5cclxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xyXG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZSk7XHJcblxyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxyXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcclxuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgLTEwJSwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuXHJcbi8qKlxyXG4gKiBGYWRlLWluIHNjcmVlbiB0cmFuc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XHJcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXHJcbiAgICAgIGR1cmF0aW9uOiAnMC40JyxcclxuICAgICAgZGVsYXk6ICcwJ1xyXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdChbZW50ZXJQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBlbnRlclBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxyXG4gICAgICAgIC5zYXZlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICk7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXHJcbiAgICovXHJcbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdChbbGVhdmVQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBsZWF2ZVBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xyXG5cclxuLyoqXHJcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBuYXZpZ2F0b3IgdHJhbnNpdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xyXG4gICAgICBkdXJhdGlvbjogMC4zLFxyXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLFxyXG4gICAgICBkZWxheTogMFxyXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXHJcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDI7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+XHJcbiAgICBgKTtcclxuICAgIHRoaXMuYmxhY2tNYXNrT3BhY2l0eSA9IDAuNDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcclxuICAgIGxlYXZlUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xyXG5cclxuICAgIGFuaW1pdC5ydW5BbGwoXHJcblxyXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDAsIDApJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcclxuXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxyXG4gICAgICAgIC53YWl0KDAuMilcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxyXG4gICAqL1xyXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSkge1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcclxuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UubmV4dFNpYmxpbmcpO1xyXG5cclxuICAgIGFuaW1pdC5ydW5BbGwoXHJcblxyXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5LFxyXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcclxuICAgICAgICAuc2F2ZVN0eWxlKClcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcclxuXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KDAuMilcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICBmaW5pc2goKTtcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuXHJcbi8qKlxyXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcclxuICAgICAgZHVyYXRpb246IDAuNCxcclxuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcclxuICAgICAgZGVsYXk6IDAuMDVcclxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgIHN1cGVyKG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxyXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1wiPjwvZGl2PlxyXG4gICAgYCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XHJcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcclxuXHJcbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcclxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXHJcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIG1hc2tDbGVhcixcclxuXHJcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcclxuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xyXG5cclxuICAgIGFuaW1pdC5ydW5BbGwoXHJcblxyXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcclxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMC40XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb246IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuXHJcbi8qKlxyXG4gKiBGYWRlLWluICsgTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XHJcbiAgICAgIHRpbWluZzogJ2Vhc2Utb3V0JyxcclxuICAgICAgZHVyYXRpb246ICcwLjI1JyxcclxuICAgICAgZGVsYXk6ICcwJ1xyXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCA0MnB4LCAwKScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXHJcbiAgICovXHJcbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIGNzczoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLndhaXQoMC4xNSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCgwLjA0KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gIH1cclxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9XHJcblxyXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xyXG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcclxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcclxuaW1wb3J0IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcclxuaW1wb3J0IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9pb3MtbGlmdC1hbmltYXRvcic7XHJcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLWZhZGUtYW5pbWF0b3InO1xyXG5pbXBvcnQgTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL21kLXNsaWRlLWFuaW1hdG9yJztcclxuaW1wb3J0IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL21kLWxpZnQtYW5pbWF0b3InO1xyXG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtZmFkZS1hbmltYXRvcic7XHJcbmltcG9ydCBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbm9uZS1hbmltYXRvcic7XHJcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xyXG5cclxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcclxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXHJcbiAgJ3NsaWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXHJcbiAgJ2xpZnQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXHJcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXHJcbiAgJ3NsaWRlLWlvcyc6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxyXG4gICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXHJcbiAgJ2xpZnQtaW9zJzogSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcclxuICAnbGlmdC1tZCc6IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcclxuICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxyXG4gICdmYWRlLW1kJzogTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxyXG4gICdub25lJzogTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvclxyXG59O1xyXG5cclxuY29uc3QgcmV3cml0YWJsZXMgPSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuYXZpZ2F0b3JTaWRlRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgcmVhZHkobmF2aWdhdG9yRWxlbWVudCwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuYXZpZ2F0b3JFbGVtZW50XHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgbGluayhuYXZpZ2F0b3JFbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtbmF2aWdhdG9yXHJcbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIEEgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgcGFnZSBzdGFjayBtYW5hZ2VtZW50IGFuZCBuYXZpZ2F0aW9uLiBTdGFjayBuYXZpZ2F0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbiBuYXZpZ2F0aW9uIHBhdHRlcm4gZm9yIG1vYmlsZSBhcHBzLlxyXG4gKlxyXG4gKiAgICAgV2hlbiBhIHBhZ2UgaXMgcHVzaGVkIG9uIHRvcCBvZiB0aGUgc3RhY2sgaXQgaXMgZGlzcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIGFuaW1hdGlvbi4gV2hlbiB0aGUgdXNlciByZXR1cm5zIHRvIHRoZSBwcmV2aW91cyBwYWdlIHRoZSB0b3AgcGFnZSB3aWxsIGJlIHBvcHBlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGFuZCBoaWRkZW4gd2l0aCBhbiBvcHBvc2l0ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAY29kZXBlbiB5cmh0dlxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbmF2aWdhdG9yXHJcbiAqIEBndWlkZSBQYWdlTmF2aWdhdGlvblxyXG4gKiAgIFtlbl1HdWlkZSBmb3IgcGFnZSBuYXZpZ2F0aW9uWy9lbl1cclxuICogICBbamFd44Oa44O844K444OK44OT44Ky44O844K344On44Oz44Gu5qaC6KaBWy9qYV1cclxuICogQGd1aWRlIENhbGxpbmdDb21wb25lbnRBUElzZnJvbUphdmFTY3JpcHRcclxuICogICBbZW5dVXNpbmcgbmF2aWdhdG9yIGZyb20gSmF2YVNjcmlwdFsvZW5dXHJcbiAqICAgW2phXUphdmFTY3JpcHTjgYvjgonjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLlkbzjgbPlh7rjgZlbL2phXVxyXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xyXG4gKiAgIFtlbl1FdmVudCBoYW5kbGluZyBkZXNjcmlwdGlvbnNbL2VuXVxyXG4gKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxyXG4gKiBAZ3VpZGUgRGVmaW5pbmdNdWx0aXBsZVBhZ2VzaW5TaW5nbGVIVE1MXHJcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cclxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhcj5gIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSB0b29sYmFyIG9uIHRoZSB0b3Agb2YgYSBwYWdlLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYmFjay1idXR0b24+YCBjb21wb25lbnQgbGV0cyB0aGUgdXNlciByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1uYXZpZ2F0b3IgaWQ9XCJuYXZpZ2F0b3JcIj5cclxuICogICA8b25zLXBhZ2U+XHJcbiAqICAgICA8b25zLXRvb2xiYXI+XHJcbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cclxuICogICAgICAgICBUaXRsZVxyXG4gKiAgICAgICA8L2Rpdj5cclxuICogICAgIDwvb25zLXRvb2xiYXI+XHJcbiAqICAgICA8cD5cclxuICogICAgICAgPG9ucy1idXR0b25cclxuICogICAgICAgICBvbmNsaWNrPVwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25hdmlnYXRvcicpLnB1c2hQYWdlKCdwYWdlLmh0bWwnKVwiPlxyXG4gKiAgICAgICAgIFB1c2ggcGFnZVxyXG4gKiAgICAgICA8L29ucy1idXR0b24+XHJcbiAqICAgICA8L3A+XHJcbiAqICAgPC9vbnMtcGFnZT5cclxuICogPC9vbnMtbmF2aWdhdG9yPlxyXG4gKlxyXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwicGFnZS5odG1sXCI+XHJcbiAqICAgPG9ucy1wYWdlPlxyXG4gKiAgICAgPG9ucy10b29sYmFyPlxyXG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxyXG4gKiAgICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxyXG4gKiAgICAgICA8L2Rpdj5cclxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxyXG4gKiAgICAgICAgIEFub3RoZXIgcGFnZVxyXG4gKiAgICAgICA8L2Rpdj5cclxuICogICAgIDwvb25zLXRvb2xiYXI+XHJcbiAqICAgPC9vbnMtcGFnZT5cclxuICogPC9vbnMtdGVtcGxhdGU+XHJcbiAqL1xyXG5jbGFzcyBOYXZpZ2F0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHBhZ2VcclxuICAgKiBAaW5pdG9ubHlcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUZpcnN0IHBhZ2UgdG8gc2hvdyB3aGVuIG5hdmlnYXRvciBpcyBpbml0aWFsaXplZC5bL2VuXVxyXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dXHJcbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXHJcbiAgICpcclxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybS5cclxuICAgKiAgIFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xyXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cclxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHByZXB1c2hcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXHJcbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxyXG4gICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcclxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwdXNoLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcHVzaOWHpueQhuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVwb3BcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcG9wcGVkLlsvZW5dXHJcbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmN1cnJlbnRQYWdlXHJcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxyXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXBhZ2Xjga5wb3DjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAZXZlbnQgcG9zdHB1c2hcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cclxuICAgKiAgIFtqYV1wYWdl44GMcHVzaOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guS6huOBl+OBpuOBi+OCieeZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmVudGVyUGFnZVxyXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXHJcbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcclxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cclxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHBvc3Rwb3BcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cclxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC44KP44Gj44Gf5b6M44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXHJcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cclxuICAgKiAgIFtqYV1wb3DjgZXjgozjgabooajnpLrjgZXjgozjgovjg5rjg7zjgrjjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcclxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cclxuICAgKiAgIFtqYV1wb3DjgZXjgozjgabmtojjgYjjgovjg5rjg7zjgrjjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBnZXQgYW5pbWF0b3JGYWN0b3J5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yRmFjdG9yeTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uLmJpbmQodGhpcyk7XHJcblxyXG4gICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ3BhZ2UnKSkge1xyXG4gICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSwge2FuaW1hdGlvbjogJ25vbmUnfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5wYWdlc1tpXS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjaGlsZHJlbiBvZiA8b25zLW5hdmlnYXRvcj4gbmVlZCB0byBiZSBvZiB0eXBlIDxvbnMtcGFnZT4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRvcFBhZ2UuX3Nob3coKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XHJcbiAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcclxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xyXG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXHJcbiAgICAgIGJhc2VDbGFzczogTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxyXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yJyxcclxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBwb3BQYWdlXHJcbiAgICogQHNpZ25hdHVyZSBwb3BQYWdlKFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICAgKiAgIFtlbl1cclxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cclxuICAgKlxyXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cclxuICAgKiAgIFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWZyZXNoXVxyXG4gICAqICAgW2VuXVRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBwb3BQYWdlIGFjdGlvbi5bL2VuXVxyXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXZlYWxlZCBwYWdlLlsvZW5dXHJcbiAgICogICBbamFd5piO44KJ44GL44Gr44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUG9wcyB0aGUgY3VycmVudCBwYWdlIGZyb20gdGhlIHBhZ2Ugc3RhY2suIFRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgZGlzcGxheWVkLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44GL44KJ5Y+W44KK6Zmk44GN44G+44GZ44CC5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KK44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBwb3BQYWdlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgcG9wVXBkYXRlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdLl9kZXN0cm95KCk7XHJcbiAgICAgIHJlc29sdmUoKTtcclxuICAgIH0pO1xyXG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5yZWZyZXNoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMjtcclxuXHJcbiAgICBpZiAoIXRoaXMucGFnZXNbaW5kZXhdLm5hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZyZXNoIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHBhZ2VzIGRpcmVjdGx5IGluc2lkZSB0aGUgTmF2aWdhdG9yLiBVc2Ugb25zLXRlbXBsYXRlIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHRoaXMucGFnZXNbaW5kZXhdLm5hbWUpLnRoZW4odGVtcGxhdGVIVE1MID0+IHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5leHRlbmQodGhpcy5fY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKSwge1xyXG4gICAgICAgICAgbmFtZTogdGhpcy5wYWdlc1tpbmRleF0ubmFtZSxcclxuICAgICAgICAgIGRhdGE6IHRoaXMucGFnZXNbaW5kZXhdLmRhdGEsXHJcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiB0aGlzLnBhZ2VzW2luZGV4XS5wdXNoZWRPcHRpb25zXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgZWxlbWVudCwgdGhpcy5wYWdlc1tpbmRleF0ub3B0aW9ucywgZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSA/IHRoaXMucGFnZXNbaW5kZXhdIDogbnVsbCk7XHJcbiAgICAgICAgICB0aGlzLnBhZ2VzW2luZGV4ICsgMV0uX2Rlc3Ryb3koKTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KS50aGVuKCgpID0+IHRoaXMuX3BvcFBhZ2Uob3B0aW9ucywgcG9wVXBkYXRlKSk7XHJcbiAgfVxyXG5cclxuICBfcG9wUGFnZShvcHRpb25zLCB1cGRhdGUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSwgcGFnZXMgPSBbXSkge1xyXG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnb25zLW5hdmlnYXRvclxcJ3MgcGFnZSBzdGFjayBpcyBlbXB0eS4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZW1pdFByZVBvcEV2ZW50KCkpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwb3AgZXZlbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbCA9IHRoaXMucGFnZXMubGVuZ3RoO1xyXG5cclxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5wYWdlc1tsIC0gMl0udXBkYXRlQmFja0J1dHRvbigobCAtIDIpID4gMCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1tsIC0gMV07XHJcbiAgICAgIHZhciBlbnRlclBhZ2UgPSB0aGlzLnBhZ2VzW2wgLSAyXTtcclxuICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cclxuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb24gfHwgb3B0aW9ucy5hbmltYXRpb247XHJcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb25PcHRpb25zLCBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgcGFnZXMucG9wKCk7XHJcbiAgICAgICAgdXBkYXRlKHBhZ2VzLCB0aGlzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGVudGVyUGFnZS5fc2hvdygpO1xyXG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cG9wJywge2xlYXZlUGFnZSwgZW50ZXJQYWdlLCBuYXZpZ2F0b3I6IHRoaXN9KTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlc29sdmUoZW50ZXJQYWdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xyXG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcclxuICAgICAgYW5pbWF0b3IucG9wKHRoaXMucGFnZXNbbCAtIDJdLCB0aGlzLnBhZ2VzW2wgLSAxXSwgY2FsbGJhY2spO1xyXG4gICAgfSkuY2F0Y2goKCkgPT4gdGhpcy5faXNSdW5uaW5nID0gZmFsc2UpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgcHVzaFBhZ2VcclxuICAgKiBAc2lnbmF0dXJlIHB1c2hQYWdlKHBhZ2UsIFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhZ2VdXHJcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYSBIVE1MIGRvY3VtZW50IG9yIGEgdGVtcGxhdGUgZGVmaW5lZCB3aXRoIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5bL2VuXVxyXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxyXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBPbmx5IG5lY2Vzc2FyeSBpZiBgcGFnZWAgcGFyYW1ldGVyIGlzIG9taXR0ZWQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cclxuICAgKiAgIFtlbl1IVE1MIGNvZGUgdGhhdCB3aWxsIGJlIGNvbXB1dGVkIGFzIGEgbmV3IHBhZ2UuIE92ZXJ3cml0ZXMgYHBhZ2VgIHBhcmFtZXRlci5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICAgKiAgIFtlbl1cclxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cclxuICAgKlxyXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cclxuICAgKiAgIFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxyXG4gICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7QW55fSBbb3B0aW9ucy5kYXRhXVxyXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcHVzaGVkIHBhZ2UuWy9lbl1cclxuICAgKiAgIFtqYV3ov73liqDjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1QdXNoZXMgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrLlsvZW5dXHJcbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuaWsOOBl+OBhOODmuODvOOCuOOCueOCv+ODg+OCr+OBq+i/veWKoOOBl+OBvuOBmeOAguaWsOOBl+OBhOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgcHVzaFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBvcHRpb25zID0gdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgcGFnZSk7XHJcbiAgICBjb25zdCBydW4gPSB0ZW1wbGF0ZUhUTUwgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmV4dGVuZCh0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpLCB7XHJcbiAgICAgICAgbmFtZTogb3B0aW9ucy5wYWdlLFxyXG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICByZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5wYWdlSFRNTCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gcnVuKG9wdGlvbnMucGFnZUhUTUwpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zLCAoKSA9PiBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKG9wdGlvbnMucGFnZSkudGhlbihydW4pKTtcclxuICB9XHJcblxyXG4gIF9wdXNoUGFnZShvcHRpb25zID0ge30sIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLCBwYWdlcyA9IFtdLCBwYWdlID0ge30pIHtcclxuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSk7XHJcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwge2FuaW1hdGlvbk9wdGlvbnN9LCBvcHRpb25zKTtcclxuXHJcbiAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcclxuXHJcbiAgICBwYWdlcy5wdXNoKHBhZ2UpO1xyXG5cclxuICAgIHJldHVybiB1cGRhdGUocGFnZXMsIHRoaXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICBjb25zdCBwYWdlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XHJcblxyXG4gICAgICB2YXIgZW50ZXJQYWdlICA9IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDFdO1xyXG4gICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMl07XHJcblxyXG4gICAgICBpZiAoZW50ZXJQYWdlLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGVsZW1lbnRzIG9mIHR5cGUgPG9ucy1wYWdlPiBjYW4gYmUgcHVzaGVkIHRvIHRoZSBuYXZpZ2F0b3InKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZW50ZXJQYWdlLnVwZGF0ZUJhY2tCdXR0b24ocGFnZUxlbmd0aCAtIDEpO1xyXG5cclxuICAgICAgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICBlbnRlclBhZ2UuZGF0YSA9IGVudGVyUGFnZS5kYXRhIHx8IG9wdGlvbnMuZGF0YTtcclxuICAgICAgZW50ZXJQYWdlLm5hbWUgPSBlbnRlclBhZ2UubmFtZSB8fCBvcHRpb25zLnBhZ2U7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgdmFyIGRvbmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBpZiAobGVhdmVQYWdlKSB7XHJcbiAgICAgICAgICAgIGxlYXZlUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGVudGVyUGFnZS5fc2hvdygpO1xyXG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cHVzaCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIHZhciBwdXNoID0gKCkgPT4gIHtcclxuICAgICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcclxuICAgICAgICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XHJcbiAgICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9wdGlvbnMuX2xpbmtlZCA/IHB1c2goKSA6IHJld3JpdGFibGVzLmxpbmsodGhpcywgZW50ZXJQYWdlLCBvcHRpb25zLCBwdXNoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIHJlcGxhY2VQYWdlXHJcbiAgICogQHNpZ25hdHVyZSByZXBsYWNlUGFnZShwYWdlLCBbb3B0aW9uc10pXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZS5bL2VuXVxyXG4gICAqICAgW2phXeaWsOOBl+OBhOODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVJlcGxhY2VzIHRoZSBjdXJyZW50IHRvcCBwYWdlIHdpdGggdGhlIHNwZWNpZmllZCBvbmUuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjgpLmjIflrprjgZfjgZ/jg5rjg7zjgrjjgavnva7jgY3mj5vjgYjjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIHJlcGxhY2VQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMsIHBhZ2UpO1xyXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xyXG5cclxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMl0uX2Rlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcclxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2Uob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGluc2VydFBhZ2VcclxuICAgKiBAc2lnbmF0dXJlIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgKiAgIFtlbl1UaGUgaW5kZXggd2hlcmUgaXQgc2hvdWxkIGJlIGluc2VydGVkLlsvZW5dXHJcbiAgICogICBbamFd44K544K/44OD44Kv44Gr5oy/5YWl44GZ44KL5L2N572u44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGluc2VydGVkIHBhZ2UuWy9lbl1cclxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1JbnNlcnQgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrIHdpdGggYXQgYSBwb3NpdGlvbiBkZWZpbmVkIGJ5IHRoZSBgaW5kZXhgIGFyZ3VtZW50LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXHJcbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBrmluZGV444Gn5oyH5a6a44GX44Gf5L2N572u44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBpbnNlcnRQYWdlKGluZGV4LCBwYWdlLCBvcHRpb25zID0ge30pIHtcclxuICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBwYWdlKTtcclxuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xyXG5cclxuICAgIGlmIChpbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBydW4gPSB0ZW1wbGF0ZUhUTUwgPT4ge1xyXG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5leHRlbmQodGhpcy5fY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKSwge1xyXG4gICAgICAgIG5hbWU6IG9wdGlvbnMucGFnZSxcclxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXHJcbiAgICAgICAgcHVzaGVkT3B0aW9uczogb3B0aW9uc1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxyXG4gICAgICAgIHt9LFxyXG4gICAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxyXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSk7XHJcbiAgICAgICAgdGhpcy50b3BQYWdlLnVwZGF0ZUJhY2tCdXR0b24odHJ1ZSk7XHJcblxyXG4gICAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5wYWdlc1tpbmRleF0pO1xyXG4gICAgICAgICAgfSwgMTAwMCAvIDYwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XHJcbiAgICAgIHJldHVybiBydW4ob3B0aW9ucy5wYWdlSFRNTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhvcHRpb25zLnBhZ2UpLnRoZW4ocnVuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgcmVzZXRUb1BhZ2VcclxuICAgKiBAc2lnbmF0dXJlIHJlc2V0VG9QYWdlKHBhZ2UsIFtvcHRpb25zXSlcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxyXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUNsZWFycyBwYWdlIHN0YWNrIGFuZCBhZGRzIHRoZSBzcGVjaWZpZWQgcGFnZSB0byB0aGUgc3RhY2suIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cclxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgpLjg6rjgrvjg4Pjg4jjgZfjgIHmjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIHJlc2V0VG9QYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMsIHBhZ2UpO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24pIHtcclxuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xyXG5cclxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgIHdoaWxlICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB0aGlzLnBhZ2VzWzBdLl9kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGFnZXNbMF0udXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XHJcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5wYWdlICYmICFvcHRpb25zLnBhZ2VIVE1MICYmIHRoaXMuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcclxuICAgICAgb3B0aW9ucy5wYWdlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgYnJpbmdQYWdlVG9wXHJcbiAgICogQHNpZ25hdHVyZSBicmluZ1BhZ2VUb3AoaXRlbSwgW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbVxyXG4gICAqICAgW2VuXVBhZ2UgVVJMIG9yIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UgaW4gbmF2aWdhdG9yJ3Mgc3RhY2suWy9lbl1cclxuICAgKiAgIFtqYV3jg5rjg7zjgrjjga5VUkzjgYvjgoLjgZfjgY/jga9vbnMtbmF2aWdhdG9y44Gu44Oa44O844K444K544K/44OD44Kv44Gu44Kk44Oz44OH44OD44Kv44K55YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxyXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUJyaW5ncyB0aGUgZ2l2ZW4gcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHN0YWNrIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9yIHB1c2hlcyBpdCBpbnRvIHRoZSBzdGFjayBpZiBkb2Vzbid0LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXHJcbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44Gu5LiA55Wq5LiK44Gr56e75YuV44GX44G+44GZ44CC44KC44GX5oyH5a6a44GX44Gf44Oa44O844K444GM54Sh44GL44Gj44Gf5aC05ZCI5paw44GX44GPcHVzaOOBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgYnJpbmdQYWdlVG9wKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKFsnbnVtYmVyJywgJ3N0cmluZyddLmluZGV4T2YodHlwZW9mIGl0ZW0pID09PSAtMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwYWdlIG5hbWUgb3IgdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UuIFlvdSBzdXBwbGllZCAnICsgaXRlbSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IHRoaXMuX25vcm1hbGl6ZUluZGV4KGl0ZW0pIDogdGhpcy5fbGFzdEluZGV4T2ZQYWdlKGl0ZW0pO1xyXG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xyXG5cclxuICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UoaXRlbSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zID0gdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcclxuICAgIH1cclxuICAgIGlmICghcGFnZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGl0ZW0gJyArIGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xyXG4gICAgfVxyXG5cclxuICAgIHV0aWwuZXh0ZW5kKG9wdGlvbnMsIHtcclxuICAgICAgcGFnZTogcGFnZS5uYW1lLFxyXG4gICAgICBfbGlua2VkOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHBhZ2Uuc2V0QXR0cmlidXRlKCdfc2tpcGluaXQnLCAnJyk7XHJcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBfcHJlcGFyZU9wdGlvbnMob3B0aW9ucyA9IHt9LCBwYWdlKSB7XHJcbiAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdvYmplY3QnICYmIHBhZ2UgIT09IG51bGwpIHtcclxuICAgICAgb3B0aW9ucyA9IHBhZ2U7XHJcbiAgICAgIHBhZ2UgPSBvcHRpb25zLnBhZ2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgcGFnZSA9IHBhZ2UgfHwgb3B0aW9ucy5wYWdlO1xyXG5cclxuICAgIHJldHVybiB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zLCB7cGFnZX0pO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xyXG4gICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgdGhpcy5wYWdlc1tpbmRleF0udXBkYXRlQmFja0J1dHRvbihpbmRleCA+IDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX25vcm1hbGl6ZUluZGV4KGluZGV4KSB7XHJcbiAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogTWF0aC5hYnModGhpcy5wYWdlcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLnBhZ2VzLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgdGhpcy5wb3BQYWdlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2xhc3RJbmRleE9mUGFnZShwYWdlTmFtZSkge1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgZm9yIChpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xyXG4gICAgICBpZiAodGhpcy5wYWdlc1tpbmRleF0ubmFtZSA9PT0gcGFnZU5hbWUpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgX2VtaXRQcmVFdmVudChuYW1lLCBkYXRhID0ge30pIHtcclxuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XHJcblxyXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmUnICsgbmFtZSwgdXRpbC5leHRlbmQoe1xyXG4gICAgICBuYXZpZ2F0b3I6IHRoaXMsXHJcbiAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0sXHJcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcclxuICAgIH0sIGRhdGEpKTtcclxuXHJcbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcclxuICB9XHJcblxyXG4gIF9lbWl0UHJlUHVzaEV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncHVzaCcpO1xyXG4gIH1cclxuXHJcbiAgX2VtaXRQcmVQb3BFdmVudCgpIHtcclxuICAgIGNvbnN0IGwgPSB0aGlzLnBhZ2VzLmxlbmd0aDtcclxuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3BvcCcsIHtcclxuICAgICAgbGVhdmVQYWdlOiB0aGlzLnBhZ2VzW2wgLSAxXSxcclxuICAgICAgZW50ZXJQYWdlOiB0aGlzLnBhZ2VzW2wgLSAyXVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKSB7XHJcbiAgICBjb25zdCBwYWdlRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTCh0ZW1wbGF0ZUhUTUwpKTtcclxuXHJcbiAgICBpZiAocGFnZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBcIm9ucy1wYWdlXCIgZWxlbWVudCB0byBcIm9ucy1uYXZpZ2F0b3JcIi4nKTtcclxuICAgIH1cclxuXHJcbiAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlKHBhZ2VFbGVtZW50KTtcclxuXHJcbiAgICByZXR1cm4gcGFnZUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXHJcbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHRvcFBhZ2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ3VycmVudCB0b3AgcGFnZSBlbGVtZW50LiBVc2UgdGhpcyBtZXRob2QgdG8gYWNjZXNzIG9wdGlvbnMgcGFzc2VkIGJ5IGBwdXNoUGFnZSgpYC1saWtlIG1ldGhvZHMuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IHRvcFBhZ2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgcGFnZXNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7SFRNTENvbGxlY3Rpb259XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dTmF2aWdhdG9yJ3MgcGFnZSBzdGFjay5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgZ2V0IHBhZ2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRGVmYXVsdCBvcHRpb25zIG9iamVjdC4gQXR0cmlidXRlcyBoYXZlIHByaW9yaXR5IG92ZXIgdGhpcyBwcm9wZXJ0eS5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dXHJcbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXHJcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxyXG4gICAqICAgWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLnJlZnJlc2hcclxuICAgKiBAZGVmYXVsdCAgZmFsc2VcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1JZiB0aGlzIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIHRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBgcG9wUGFnZSgpYCBhY3Rpb24uWy9lbl1cclxuICAgKiAgIFtqYV1wb3BQYWdl44GZ44KL5YmN44Gr44CB5YmN44Gr44GC44KL44Oa44O844K444KS55Sf5oiQ44GX44Gq44GK44GX44Gm5pu05paw44GZ44KL5aC05ZCI44GrdHJ1ZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcclxuICB9XHJcbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XHJcbiAgICB0aGlzLl9vcHRpb25zID0gb2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgc2V0IF9pc1J1bm5pbmcodmFsdWUpIHtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycsIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XHJcbiAgfVxyXG4gIGdldCBfaXNSdW5uaW5nKCkge1xyXG4gICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnKSk7XHJcbiAgfVxyXG5cclxuICBfc2hvdygpIHtcclxuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcclxuICAgICAgdGhpcy50b3BQYWdlLl9zaG93KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcclxuICAgICAgdGhpcy50b3BQYWdlLl9oaWRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZGVzdHJveSgpIHtcclxuICAgIGZvciAobGV0IGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHRoaXMucGFnZXNbaV0uX2Rlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbndpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbmF2aWdhdG9yJywge1xyXG4gIHByb3RvdHlwZTogTmF2aWdhdG9yRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcclxuICovXHJcbndpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xyXG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNOYXZpZ2F0b3JFbGVtZW50Lk5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicpO1xyXG4gIH1cclxuXHJcbiAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xyXG59O1xyXG5cclxud2luZG93Lk9uc05hdmlnYXRvckVsZW1lbnQucmV3cml0YWJsZXMgPSByZXdyaXRhYmxlcztcclxud2luZG93Lk9uc05hdmlnYXRvckVsZW1lbnQuTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yID0gTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yO1xyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnJzogJ3BhZ2UtLSonLFxyXG4gICcucGFnZV9fY29udGVudCc6ICdwYWdlLS0qX19jb250ZW50JyxcclxuICAnLnBhZ2VfX2JhY2tncm91bmQnOiAncGFnZS0tKl9fYmFja2dyb3VuZCdcclxufTtcclxuXHJcbmNvbnN0IG51bGxUb29sYmFyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy10b29sYmFyJyk7XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXBhZ2VcclxuICogQGNhdGVnb3J5IHBhZ2VcclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXHJcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIFRoaXMgY29tcG9uZW50IGRlZmluZXMgdGhlIHJvb3Qgb2YgZWFjaCBwYWdlLiBJZiB0aGUgY29udGVudCBpcyBsYXJnZSBpdCB3aWxsIGJlY29tZSBzY3JvbGxhYmxlLlxyXG4gKlxyXG4gKiAgICAgQSBuYXZpZ2F0aW9uIGJhciBjYW4gYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSB1c2luZyB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFd44Oa44O844K45a6a576p44Gu44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu5YaF5a6544Gv44K544Kv44Ot44O844Or44GM6Kix5Y+v44GV44KM44G+44GZ44CCWy9qYV1cclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcclxuICogQGd1aWRlIE1hbmFnaW5nTXVsdGlwbGVQYWdlc1xyXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svZW5dXHJcbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXHJcbiAqIEBndWlkZSBQYWdlbGlmZWN5Y2xlXHJcbiAqICAgW2VuXVBhZ2UgbGlmZSBjeWNsZSBldmVudHNbL2VuXVxyXG4gKiAgIFtqYV3jg5rjg7zjgrjjg6njgqTjg5XjgrXjgqTjgq/jg6vjgqTjg5njg7Pjg4hbL2phXVxyXG4gKiBAZ3VpZGUgSGFuZGxpbmdCYWNrQnV0dG9uXHJcbiAqICAgW2VuXUhhbmRsaW5nIGJhY2sgYnV0dG9uWy9lbl1cclxuICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44Gr5a++5b+c44GZ44KLWy9qYV1cclxuICogQGd1aWRlIE92ZXJyaWRpbmdDU1NzdHlsZXNcclxuICogICBbZW5dT3ZlcnJpZGluZyBDU1Mgc3R5bGVzWy9lbl1cclxuICogICBbamFdQ1NT44K544K/44Kk44Or44Gu44Kq44O844OQ44O844Op44Kk44OJWy9qYV1cclxuICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxyXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXHJcbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cclxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcclxuICogICBbZW5dVXNlIHRoZSBgPG9ucy10b29sYmFyPmAgZWxlbWVudCB0byBhZGQgYSBuYXZpZ2F0aW9uIGJhciB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtcGFnZT5cclxuICogICA8b25zLXRvb2xiYXI+XHJcbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxyXG4gKiAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XHJcbiAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cclxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cclxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxyXG4gKiAgICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIDwvb25zLXRvb2xiYXI+XHJcbiAqXHJcbiAqICAgPHA+UGFnZSBjb250ZW50PC9wPlxyXG4gKiA8L29ucy1wYWdlPlxyXG4gKlxyXG4gKiAvLyBJbmZpbml0ZSBTY3JvbGwgaGFuZGxlclxyXG4gKiBwYWdlLm9uSW5maW5pdGVTY3JvbGwgPSBmdW5jdGlvbihkb25lKSB7XHJcbiAqICAgbG9hZE1vcmUoKS50aGVuKGRvbmUpO1xyXG4gKiB9O1xyXG4gKi9cclxuY2xhc3MgUGFnZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBpbml0XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgYXR0YWNoZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzjgqLjgr/jg4Pjg4HjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBzaG93XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgc2hvd24uWy9lbl1cclxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBoaWRlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgaGlkZGVuLlsvZW5dXHJcbiAgICogICBbamFd44Oa44O844K444GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAZXZlbnQgZGVzdHJveVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSBpcyBkZXN0cm95ZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYznoLTmo4TjgZXjgozjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNwZWNpZnkgbW9kaWZpZXIgbmFtZSB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsZXMuWy9lbl1cclxuICAgKiAgIFtqYV3jgrnjgr/jgqTjg6vlrprnvqnjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovjgZ/jgoHjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG9uLWluZmluaXRlLXNjcm9sbFxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUGF0aCBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gaW5maW5pdGUgc2Nyb2xsaW5nLiBFeGFtcGxlOiBgYXBwLmxvYWREYXRhYC4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGFnZScpO1xyXG5cclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcclxuICAgICAgdGhpcy5faXNNdXRlZCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfbXV0ZWQnKTtcclxuICAgICAgdGhpcy5fc2tpcEluaXQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX3NraXBpbml0Jyk7XHJcbiAgICAgIHRoaXMucHVzaGVkT3B0aW9ucyA9IHt9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NraXBJbml0KSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnX3NraXBpbml0Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2luaXQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQodGhpcykpIHtcclxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdHJ5VG9GaWxsU3RhdHVzQmFyKCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29uLWluZmluaXRlLXNjcm9sbCcpKSB7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlQmFja0J1dHRvbihzaG93KSB7XHJcbiAgICBpZiAodGhpcy5iYWNrQnV0dG9uKSB7XHJcbiAgICAgIHNob3cgPyB0aGlzLmJhY2tCdXR0b24uc2hvdygpIDogdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBuYW1lKHN0cikge1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBzdHIpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5hbWUoKSB7XHJcbiAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJhY2tCdXR0b24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24nKTtcclxuICB9XHJcblxyXG4gIF90cnlUb0ZpbGxTdGF0dXNCYXIoKXtcclxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcclxuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcclxuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsICFmaWxsZWQgJiYgKHRoaXMuX2NhbkFuaW1hdGVUb29sYmFyKCkgfHwgIXRoaXMuX2hhc0FQYWdlQ29udHJvbENoaWxkKCkpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2hhc0FQYWdlQ29udHJvbENoaWxkKCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2NvbnRlbnRFbGVtZW50LCBlID0+IGUubm9kZU5hbWUubWF0Y2goL29ucy0oc3BsaXR0ZXJ8c2xpZGluZy1tZW51fG5hdmlnYXRvcnx0YWJiYXIpL2kpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvbkluZmluaXRlU2Nyb2xsXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1GdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHNjcm9sbGluZyB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIGFzIGFuIGFyZ3VtZW50IHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXHJcbiAgICogIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNldCBvbkluZmluaXRlU2Nyb2xsKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uSW5maW5pdGVTY3JvbGwgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwnKTtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5fb25JbmZpbml0ZVNjcm9sbCkge1xyXG4gICAgICB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0ID0gMC45O1xyXG4gICAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcclxuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgb25JbmZpbml0ZVNjcm9sbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9vbkluZmluaXRlU2Nyb2xsO1xyXG4gIH1cclxuXHJcbiAgX29uU2Nyb2xsKCkge1xyXG4gICAgY29uc3QgYyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxyXG4gICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xyXG5cclxuICAgIGlmICh0aGlzLl9vbkluZmluaXRlU2Nyb2xsICYmICF0aGlzLl9sb2FkaW5nQ29udGVudCAmJiBvdmVyTGltaXQpIHtcclxuICAgICAgdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsKCgpID0+IHRoaXMuX2xvYWRpbmdDb250ZW50ID0gZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cclxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKTtcclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19jb250ZW50XCIgZWxlbWVudC4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgX2NhbkFuaW1hdGVUb29sYmFyKCkge1xyXG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhdXRpbC5maW5kQ2hpbGQodGhpcy5fY29udGVudEVsZW1lbnQsIGVsID0+IHtcclxuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZWwsICdvbnMtdG9vbGJhcicpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKTtcclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19iYWNrZ3JvdW5kXCIgZWxlbWVudC4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgX2dldFRvb2xiYXJFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpIHx8IG51bGxUb29sYmFyRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIHRvb2xiYXIgZWxlbWVudCB0byB0aGlzIHBhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICovXHJcbiAgX3JlZ2lzdGVyVG9vbGJhcihlbGVtZW50KSB7XHJcbiAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLmNoaWxkcmVuWzBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIHRvb2xiYXIgZWxlbWVudCB0byB0aGlzIHBhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICovXHJcbiAgX3JlZ2lzdGVyQm90dG9tVG9vbGJhcihlbGVtZW50KSB7XHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utd2l0aC1ib3R0b20tdG9vbGJhcicpO1xyXG4gICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xyXG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdfbXV0ZWQnKSB7XHJcbiAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX211dGVkJyk7XHJcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdfc2tpcGluaXQnKSB7XHJcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnb24taW5maW5pdGUtc2Nyb2xsJykge1xyXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5vbkluZmluaXRlU2Nyb2xsID0gKGRvbmUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcclxuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IGY7XHJcbiAgICAgICAgICBmKGRvbmUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcblxyXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKSkge1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XHJcblxyXG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKCFub2RlLmNsYXNzTGlzdCB8fCAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3BhZ2VfX2JhY2tncm91bmQnKSkge1xyXG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpKSB7XHJcbiAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2JhY2tncm91bmQnKTtcclxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoYmFja2dyb3VuZCwgdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50JykpO1xyXG4gICAgfVxyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xyXG4gIH1cclxuXHJcbiAgX3JlZ2lzdGVyRXh0cmFFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIGxldCBleHRyYSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fZXh0cmEnKTtcclxuICAgIGlmICghZXh0cmEpIHtcclxuICAgICAgZXh0cmEgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2V4dHJhJywge3pJbmRleDogMTAwMDF9KTtcclxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChleHRyYSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0cmEuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBfc2hvdygpIHtcclxuICAgIGlmICghdGhpcy5faXNTaG93biAmJiB1dGlsLmlzQXR0YWNoZWQodGhpcykpIHtcclxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcclxuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Nob3cnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfc2hvdycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2hpZGUoKSB7XHJcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xyXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcclxuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2hpZGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfaGlkZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2Rlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9oaWRlKCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XHJcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGVzdHJveScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9uRGV2aWNlQmFja0J1dHRvbikge1xyXG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbi5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfZGVzdHJveScpO1xyXG5cclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGF0YVxyXG4gICAqIEB0eXBlIHsqfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbn1cclxuXHJcbndpbmRvdy5PbnNQYWdlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXBhZ2UnLCB7XHJcbiAgcHJvdG90eXBlOiBQYWdlRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuXHJcbmNsYXNzIFBvcG92ZXJBbmltYXRvciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xyXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLFxyXG4gICAgICBkdXJhdGlvbjogMC4yLFxyXG4gICAgICBkZWxheTogMFxyXG4gICAgfSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjaygpO1xyXG4gIH1cclxuXHJcbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9XHJcblxyXG4gIF9hbmltYXRlKGVsZW1lbnQsIHtmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2ssIHJlc3RvcmUgPSBmYWxzZSwgYW5pbWF0aW9ufSkge1xyXG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIGlmIChhbmltYXRpb24pIHtcclxuICAgICAgZnJvbSA9IGFuaW1hdGlvbi5mcm9tO1xyXG4gICAgICB0byA9IGFuaW1hdGlvbi50bztcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRpb24gPSBhbmltaXQoZWxlbWVudCk7XHJcbiAgICBpZiAocmVzdG9yZSkge1xyXG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uc2F2ZVN0eWxlKCk7XHJcbiAgICB9XHJcbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoZnJvbSkud2FpdChvcHRpb25zLmRlbGF5KS5xdWV1ZSh7XHJcbiAgICAgIGNzczogdG8sXHJcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxyXG4gICAgICB0aW1pbmc6IG9wdGlvbnMudGltaW5nXHJcbiAgICB9KTtcclxuICAgIGlmIChyZXN0b3JlKSB7XHJcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5yZXN0b3JlU3R5bGUoKTtcclxuICAgIH1cclxuICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoKGRvbmUpID0+IHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgX2FuaW1hdGVBbGwoZWxlbWVudCwgYW5pbWF0aW9ucykge1xyXG4gICAgT2JqZWN0LmtleXMoYW5pbWF0aW9ucykuZm9yRWFjaChrZXkgPT4gdGhpcy5fYW5pbWF0ZShlbGVtZW50W2tleV0sIGFuaW1hdGlvbnNba2V5XSkucGxheSgpKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jb25zdCBmYWRlID0ge1xyXG4gIG91dDoge1xyXG4gICAgZnJvbToge29wYWNpdHk6IDEuMH0sXHJcbiAgICB0bzoge29wYWNpdHk6IDB9XHJcbiAgfSxcclxuICBpbjoge1xyXG4gICAgZnJvbToge29wYWNpdHk6IDB9LFxyXG4gICAgdG86IHtvcGFjaXR5OiAxLjB9XHJcbiAgfVxyXG59O1xyXG5cclxuY2xhc3MgTURGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgUG9wb3ZlckFuaW1hdG9yIHtcclxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcclxuICAgICAgX21hc2s6IGZhZGUuaW4sXHJcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLmluLCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XHJcbiAgICAgIF9tYXNrOiBmYWRlLm91dCxcclxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUub3V0LCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgSU9TRmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIE1ERmFkZVBvcG92ZXJBbmltYXRvciB7XHJcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XHJcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxyXG4gICAgICBfcG9wb3Zlcjoge1xyXG4gICAgICAgIGZyb206IHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4zLCAxLjMsIDEuMCknLFxyXG4gICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG86IHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4wLCAxLjAsICAxLjApJyxcclxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzdG9yZTogdHJ1ZSxcclxuICAgICAgICBjYWxsYmFja1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtQb3BvdmVyQW5pbWF0b3IsIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsIE1ERmFkZVBvcG92ZXJBbmltYXRvcn07XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcclxuaW1wb3J0IGFuaW1hdG9ycyBmcm9tICcuL2FuaW1hdG9yJztcclxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XHJcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnLnBvcG92ZXInOiAncG9wb3Zlci0tKicsXHJcbiAgJy5wb3BvdmVyLW1hc2snOiAncG9wb3Zlci1tYXNrLS0qJyxcclxuICAnLnBvcG92ZXJfX2NvbnRhaW5lcic6ICdwb3BvdmVyX19jb250YWluZXItLSonLFxyXG4gICcucG9wb3Zlcl9fY29udGVudCc6ICdwb3BvdmVyX19jb250ZW50LS0qJyxcclxuICAnLnBvcG92ZXJfX2Fycm93JzogJ3BvcG92ZXJfX2Fycm93LS0qJ1xyXG59O1xyXG5cclxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcclxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gYW5pbWF0b3JzLk1ERmFkZVBvcG92ZXJBbmltYXRvciA6IGFuaW1hdG9ycy5JT1NGYWRlUG9wb3ZlckFuaW1hdG9yLFxyXG4gICdub25lJzogYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcixcclxuICAnZmFkZS1pb3MnOiBhbmltYXRvcnMuSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcclxuICAnZmFkZS1tZCc6IGFuaW1hdG9ycy5NREZhZGVQb3BvdmVyQW5pbWF0b3JcclxufTtcclxuXHJcbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVGcmFnbWVudChgXHJcbiAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250YWluZXJcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250ZW50XCI+PC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fYXJyb3dcIj48L2Rpdj5cclxuICA8L2Rpdj5cclxuYCk7XHJcblxyXG5jb25zdCBwb3NpdGlvbnMgPSB7XHJcbiAgdXA6ICdib3R0b20nLFxyXG4gIGxlZnQ6ICdyaWdodCcsXHJcbiAgZG93bjogJ3RvcCcsXHJcbiAgcmlnaHQ6ICdsZWZ0J1xyXG59O1xyXG5cclxuY29uc3QgZGlyZWN0aW9ucyA9IE9iamVjdC5rZXlzKHBvc2l0aW9ucyk7XHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxyXG4gKiBAY2F0ZWdvcnkgcG9wb3ZlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogIFtlbl1cclxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cclxuICpcclxuICogICAgQW5vdGhlciBjb21tb24gd2F5IHRvIHVzZSB0aGUgcG9wb3ZlciBpcyB0byBkaXNwbGF5IGEgbWVudSB3aGVuIGEgYnV0dG9uIG9uIHRoZSBzY3JlZW4gaXMgdGFwcGVkLlxyXG4gKiAgWy9lbl1cclxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAY29kZXBlbiBaWVlSS29cclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BvcG92ZXJcclxuICogQGV4YW1wbGVcclxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XHJcbiAqICAgQ2xpY2sgbWUhXHJcbiAqIDwvb25zLWJ1dHRvbj5cclxuICpcclxuICogPG9ucy1wb3BvdmVyIGRpcmVjdGlvbj1cImRvd25cIiBpZD1cInBvcG92ZXJcIj5cclxuICogICA8cD5UaGlzIGlzIGEgcG9wb3ZlciE8L3A+XHJcbiAqIDwvb25zLXBvcG92ZXI+XHJcbiAqXHJcbiAqIDxzY3JpcHQ+XHJcbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gKiAgICAgdmFyIHBvcG92ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9wb3ZlcicpO1xyXG4gKiAgICAgcG9wb3Zlci5zaG93KGVsZW1lbnQpO1xyXG4gKiAgIH07XHJcbiAqIDwvc2NyaXB0PlxyXG4gKi9cclxuY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVzaG93XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXHJcbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXHJcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwb3N0c2hvd1xyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXHJcbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVoaWRlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXHJcbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXHJcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzpmqDjgozjgovlh6bnkIbjgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAZXZlbnQgcG9zdGhpZGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGhpZGRlbi5bL2VuXVxyXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwb3BvdmVyLlsvZW5dXHJcbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1cclxuICAgKiAgICBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGRpcmVjdGlvbnMuIElmIG1vcmUgdGhhbiBvbmUgZGlyZWN0aW9uIGlzIHNwZWNpZmllZCxcclxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXHJcbiAgICogIFsvZW5dXHJcbiAgICogIFtqYV1cclxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcclxuICAgKiAgICDmjIflrprjgafjgY3jgovmlrnlkJHjga/jgIFcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44GuNOOBpOOBp+OBmeOAguepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOCguOBp+OBjeOBvuOBmeOAglxyXG4gICAqICAgIOikh+aVsOaMh+WumuOBleOCjOOBn+WgtOWQiOOAgeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+WQiOOCj+OBm+OBpuaMh+WumuOBl+OBn+WApOOBi+OCieiHquWLleeahOOBq+mBuOaKnuOBleOCjOOBvuOBmeOAglxyXG4gICAqICBbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+aZguOBq+OAgeiDjOaZr+OChOODkOODg+OCr+ODnOOCv+ODs+OCkuOCv+ODg+ODl+OBl+OBn+aZguOBq+OCkuODneODg+ODl+OCquODvOODkOODvOmWieOBmOOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgY292ZXItdGFyZ2V0XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgc2V0IHRoZSBwb3BvdmVyIHdpbGwgY292ZXIgdGhlIHRhcmdldCBvbiB0aGUgc2NyZWVuLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cclxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXHJcbiAgICogQHR5cGUge0V4cHJlc3Npb259XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxyXG4gICAqIEB0eXBlIHtDb2xvcn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxyXG4gICAqICAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wicmdiYSgwLCAwLCAwLCAwLjIpXCLjgafjgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBnZXQgX21hc2soKSB7XHJcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyLW1hc2snKTtcclxuICB9XHJcblxyXG4gIGdldCBfcG9wb3ZlcigpIHtcclxuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXJfX2NvbnRhaW5lcicpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF9jb250ZW50KCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX3BvcG92ZXIsICcucG9wb3Zlcl9fY29udGVudCcpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF9hcnJvdygpIHtcclxuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICAgIHRoaXMuX2luaXRBbmltYXRvckZhY3RvcnkoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XHJcbiAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBfaW5pdEFuaW1hdG9yRmFjdG9yeSgpIHtcclxuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcclxuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxyXG4gICAgICBiYXNlQ2xhc3M6IGFuaW1hdG9ycy5Qb3BvdmVyQW5pbWF0b3IsXHJcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdQb3BvdmVyQW5pbWF0b3InLFxyXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2FuaW1hdG9yID0gKG9wdGlvbnMpID0+IGZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBfcG9zaXRpb25Qb3BvdmVyKHRhcmdldCkge1xyXG4gICAgY29uc3Qge19yYWRpdXM6IHJhZGl1cywgX2NvbnRlbnQ6IGVsLCBfbWFyZ2luOiBtYXJnaW59ID0gdGhpcztcclxuICAgIGNvbnN0IHBvcyA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IGlzTUQgPSB1dGlsLmhhc01vZGlmaWVyKHRoaXMsICdtYXRlcmlhbCcpO1xyXG4gICAgY29uc3QgY292ZXIgPSBpc01EICYmIHRoaXMuaGFzQXR0cmlidXRlKCdjb3Zlci10YXJnZXQnKTtcclxuXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IHtcclxuICAgICAgdG9wOiBwb3MudG9wIC0gbWFyZ2luLFxyXG4gICAgICBsZWZ0OiBwb3MubGVmdCAtIG1hcmdpbixcclxuICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoIC0gcG9zLnJpZ2h0IC0gbWFyZ2luLFxyXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCAtIHBvcy5ib3R0b20gLSBtYXJnaW5cclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSk7XHJcbiAgICB0aGlzLl9wb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItLScgKyBwcmltYXJ5KTtcclxuXHJcbiAgICBjb25zdCBvZmZzZXQgPSBjb3ZlciA/IDAgOiAodmVydGljYWwgPyBwb3MuaGVpZ2h0IDogcG9zLndpZHRoKSArIChpc01EID8gMCA6IDE0KTtcclxuICAgIHRoaXMuc3R5bGVbcHJpbWFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtwcmltYXJ5XSArIG9mZnNldCkgKyBtYXJnaW4gKyAncHgnO1xyXG4gICAgZWwuc3R5bGVbcHJpbWFyeV0gPSAwO1xyXG5cclxuICAgIGNvbnN0IGwgPSB2ZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcclxuICAgIGNvbnN0IHNpemVzID0gKHN0eWxlID0+ICh7XHJcbiAgICAgIHdpZHRoOiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKSxcclxuICAgICAgaGVpZ2h0OiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSlcclxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkpO1xyXG5cclxuICAgIGVsLnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtzZWNvbmRhcnldIC0gKHNpemVzW2xdIC0gcG9zW2xdKSAvIDIpICsgJ3B4JztcclxuICAgIHRoaXMuX2Fycm93LnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heChyYWRpdXMsIGRpc3RhbmNlW3NlY29uZGFyeV0gKyBwb3NbbF0gLyAyKSArICdweCc7XHJcblxyXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKGRpc3RhbmNlLCBzaXplcywgcG9zLCBwcmltYXJ5KTtcclxuXHJcbiAgICAvLyBQcmV2ZW50IGFuaW1pdCBmcm9tIHJlc3RvcmluZyB0aGUgc3R5bGUuXHJcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYW5pbWl0LW9yaWctc3R5bGUnKTtcclxuICB9XHJcblxyXG4gIF9zZXRUcmFuc2Zvcm1PcmlnaW4oZGlzdGFuY2UsIHNpemVzLCBwb3MsIHByaW1hcnkpIHtcclxuICAgIGNvbnN0IGNhbGMgPSAoYSwgbywgbCkgPT4gcHJpbWFyeSA9PT0gYSA/IHNpemVzW2xdIC8gMiA6IGRpc3RhbmNlW2FdICsgKHByaW1hcnkgPT09IG8gPyAtc2l6ZXNbbF0gOiBzaXplc1tsXSAtIHBvc1tsXSkgLyAyO1xyXG4gICAgY29uc3QgW3gsIHldID0gW2NhbGMoJ2xlZnQnLCAncmlnaHQnLCAnd2lkdGgnKSArICdweCcsIGNhbGMoJ3RvcCcsICdib3R0b20nLCAnaGVpZ2h0JykgKyAncHgnXTtcclxuICAgIHV0aWwuZXh0ZW5kKHRoaXMuX3BvcG92ZXIuc3R5bGUsIHtcclxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB4ICsgJyAnICsgeSxcclxuICAgICAgd2Via2l0VHJhbnNmb3JtT3JpZ2luWDogeCxcclxuICAgICAgd2Via2l0VHJhbnNmb3JtT3JpZ2luWTogeVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9ICh0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykgfHwgJ3VwIGRvd24gbGVmdCByaWdodCcpLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gcG9zaXRpb25zW2VdKTtcclxuICAgIGNvbnN0IHByaW1hcnkgPSBvcHRpb25zLnNvcnQoKGEsIGIpID0+IGRpc3RhbmNlW2FdIC0gZGlzdGFuY2VbYl0pWzBdO1xyXG4gICAgY29uc3QgdmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHByaW1hcnkpICE9PSAtMTtcclxuICAgIGxldCBzZWNvbmRhcnk7XHJcblxyXG4gICAgaWYgKHZlcnRpY2FsKSB7XHJcbiAgICAgIHNlY29uZGFyeSA9IGRpc3RhbmNlLmxlZnQgPCBkaXN0YW5jZS5yaWdodCA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS50b3AgPCBkaXN0YW5jZS5ib3R0b20gPyAndG9wJyA6ICdib3R0b20nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7dmVydGljYWwsIHByaW1hcnksIHNlY29uZGFyeX07XHJcbiAgfVxyXG5cclxuICBfY2xlYXJTdHlsZXMoKSB7XHJcbiAgICBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddLmZvckVhY2goZSA9PiB7XHJcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuc3R5bGVbZV0gPSAnJztcclxuICAgICAgdGhpcy5fcG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKGBwb3BvdmVyLS0ke2V9YCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9vbkNoYW5nZSgpIHtcclxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Qb3BvdmVyKHRoaXMuX2N1cnJlbnRUYXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdwb3BvdmVyJykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncG9wb3ZlcicpO1xyXG5cclxuICAgIGNvbnN0IGhhc0RlZmF1bHRDb250YWluZXIgPSB0aGlzLl9wb3BvdmVyICYmIHRoaXMuX2NvbnRlbnQ7XHJcblxyXG4gICAgaWYgKGhhc0RlZmF1bHRDb250YWluZXIpIHtcclxuXHJcbiAgICAgIGlmICghdGhpcy5fbWFzaykge1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItbWFzaycpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuZmlyc3RDaGlsZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5fYXJyb3cpIHtcclxuICAgICAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXJfX2Fycm93Jyk7XHJcbiAgICAgICAgdGhpcy5fcG9wb3Zlci5hcHBlbmRDaGlsZChhcnJvdyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcucG9wb3Zlcl9fY29udGVudCcpO1xyXG5cclxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xyXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzdHlsZScpKSB7XHJcbiAgICAgIHRoaXMuX3BvcG92ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcclxuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcclxuICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcclxuICB9XHJcblxyXG4gIF9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgIShvcHRpb25zLmFuaW1hdGlvbiBpbiBfYW5pbWF0b3JEaWN0KSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuaW1hdG9yICR7b3B0aW9ucy5hbmltYXRpb259IGlzIG5vdCByZWdpc3RlcmVkLmApO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxyXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcclxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgX2V4ZWN1dGVBY3Rpb24oYWN0aW9ucywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XHJcbiAgICBjb25zdCB7YWN0aW9uLCBiZWZvcmUsIGFmdGVyfSA9IGFjdGlvbnM7XHJcblxyXG4gICAgdGhpcy5fcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XHJcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgYHByZSR7YWN0aW9ufWAsIHsgLy8gc3luY2hyb25vdXNcclxuICAgICAgcG9wb3ZlcjogdGhpcyxcclxuICAgICAgY2FuY2VsOiAoKSA9PiBjYW5jZWxlZCA9IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChjYW5jZWxlZCkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYENhbmNlbGVkIGluIHByZSR7YWN0aW9ufSBldmVudC5gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcclxuXHJcbiAgICAgICAgYmVmb3JlICYmIGJlZm9yZSgpO1xyXG5cclxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fYW5pbWF0b3Iob3B0aW9ucylbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFmdGVyICYmIGFmdGVyKCk7XHJcblxyXG4gICAgICAgICAgICB1bmxvY2soKTtcclxuXHJcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcG9zdCR7YWN0aW9ufWAsIHtwb3BvdmVyOiB0aGlzfSk7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIHNob3dcclxuICAgKiBAc2lnbmF0dXJlIHNob3codGFyZ2V0LCBbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR8SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LiBDYW4gYmUgZWl0aGVyIGEgQ1NTIHNlbGVjdG9yLCBhbiBldmVudCBvYmplY3Qgb3IgYSBET00gZWxlbWVudC5bL2VuXVxyXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCv+ODvOOCsuODg+ODiOOBqOOBquOCi+imgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAgkNTU+OCu+ODrOOCr+OCv+OBi2V2ZW5044Kq44OW44K444Kn44Kv44OI44GLRE9N6KaB57Sg44Gu44GE44Ga44KM44GL44KS5rih44Gb44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cclxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxyXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxyXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dT3BlbiB0aGUgcG9wb3ZlciBhbmQgcG9pbnQgaXQgYXQgYSB0YXJnZXQuIFRoZSB0YXJnZXQgY2FuIGJlIGVpdGhlciBhbiBldmVudCwgYSBDU1Mgc2VsZWN0b3Igb3IgYSBET00gZWxlbWVudC4uWy9lbl1cclxuICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNob3codGFyZ2V0LCBvcHRpb25zID0ge30pIHtcclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEV2ZW50KSB7XHJcbiAgICAgIHRhcmdldCA9IHRhcmdldC50YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcclxuICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVBY3Rpb24oe1xyXG4gICAgICBhY3Rpb246ICdzaG93JyxcclxuICAgICAgYmVmb3JlOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICB9LCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaGlkZVxyXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXHJcbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIGBcImZhZGUtaW9zXCJgLCBgXCJmYWRlLW1kXCJgLCBgXCJub25lXCJgIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXHJcbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXHJcbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxyXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ2xvc2UgdGhlIHBvcG92ZXIuWy9lbl1cclxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XHJcbiAgICAgIGFjdGlvbjogJ2hpZGUnLFxyXG4gICAgICBhZnRlcjogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB0aGlzLl9jbGVhclN0eWxlcygpO1xyXG4gICAgICB9XHJcbiAgICB9LCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVxyXG4gICAqICAgICBBIGJvb2xlYW4gdmFsdWUgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIG9yIG5vdC5cclxuICAgKlxyXG4gICAqICAgICBXaGVuIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuXHJcbiAgICogICBbL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgc2V0IGNhbmNlbGFibGUodmFsdWUpIHtcclxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGdldCBjYW5jZWxhYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXHJcbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgX3Jlc2V0QmFja0J1dHRvbkhhbmRsZXIoKSB7IC8vIGRvIHdlIG5lZWQgdGhpcyB0d2ljZT9cclxuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcclxuICB9XHJcblxyXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9yZXNldEJhY2tCdXR0b25IYW5kbGVyKCk7XHJcblxyXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJ3RvcCcpKTtcclxuICAgICAgdGhpcy5fcmFkaXVzID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpKTtcclxuXHJcbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xyXG5cclxuICAgICAgdGhpcy5fcmVzZXRCYWNrQnV0dG9uSGFuZGxlcigpO1xyXG5cclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xyXG5cclxuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xyXG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XHJcblxyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcclxuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09ICdkaXJlY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcclxuICAgICAgdGhpcy5faW5pdEFuaW1hdG9yRmFjdG9yeSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIF9jYW5jZWwoKSB7XHJcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlKSB7XHJcbiAgICAgIHRoaXMuaGlkZSh7XHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zUG9wb3ZlckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wb3BvdmVyJywge1xyXG4gIHByb3RvdHlwZTogUG9wb3ZlckVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEBwYXJhbSB7UG9wb3ZlckFuaW1hdG9yfSBBbmltYXRvclxyXG4gKi9cclxud2luZG93Lk9uc1BvcG92ZXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xyXG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIGFuaW1hdG9ycy5Qb3BvdmVyQW5pbWF0b3IpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgUG9wb3ZlckFuaW1hdG9yJyk7XHJcbiAgfVxyXG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcclxufTtcclxuXHJcbndpbmRvdy5PbnNQb3BvdmVyRWxlbWVudC5Qb3BvdmVyQW5pbWF0b3IgPSBhbmltYXRvcnMuUG9wb3ZlckFuaW1hdG9yO1xyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnLnByb2dyZXNzLWJhcic6ICdwcm9ncmVzcy1iYXItLSonLFxyXG4gICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWJhcl9fcHJpbWFyeS0tKicsXHJcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXJfX3NlY29uZGFyeS0tKidcclxufTtcclxuXHJcbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcclxuICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnlcIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cclxuICA8L2Rpdj5cclxuYCk7XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWJhclxyXG4gKiBAY2F0ZWdvcnkgcHJvZ3Jlc3NcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgVGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBsaW5lYXIgcHJvZ3Jlc3MgYmFyLiBJdCBjYW4gZWl0aGVyIGRpc3BsYXkgYSBwcm9ncmVzcyBiYXIgdGhhdCBzaG93cyB0aGUgdXNlciBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGVyY2VudGFnZSBpcyBub3Qga25vd24gaXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhbiBhbmltYXRlZCBwcm9ncmVzcyBiYXIgc28gdGhlIHVzZXIgY2FuIHNlZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcy5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAY29kZXBlbiB6dlFiR2pcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXHJcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1jaXJjdWxhclxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1wcm9ncmVzcy1iYXJcclxuICogIHZhbHVlPVwiNTVcIlxyXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cclxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxyXG4gKlxyXG4gKiA8b25zLXByb2dyZXNzLWJhclxyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cclxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxyXG4gKi9cclxuY2xhc3MgUHJvZ3Jlc3NCYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxyXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcclxuICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XHJcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xyXG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcclxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpKSB7XHJcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWJhci0taW5kZXRlcm1pbmF0ZWApO1xyXG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1iYXItLWRldGVybWluYXRlYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xyXG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1iYXItLWluZGV0ZXJtaW5hdGVgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVWYWx1ZSgpIHtcclxuICAgIHRoaXMuX3ByaW1hcnkuc3R5bGUud2lkdGggPSAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKyAnJScgOiAnMCUnO1xyXG4gICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLndpZHRoID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICsgJyUnIDogJzAlJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cclxuICAgKi9cclxuICBzZXQgdmFsdWUodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XHJcbiAgfVxyXG5cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcclxuICB9XHJcblxyXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcclxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgfHwgJzAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnLCAnJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICAgIHRoaXMuX3ByaW1hcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzNdO1xyXG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdGhpcy5fdGVtcGxhdGUuY2hpbGROb2Rlc1sxXTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xyXG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcclxuXHJcbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcclxuXHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcblxyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNQcm9ncmVzc0JhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wcm9ncmVzcy1iYXInLCB7XHJcbiAgcHJvdG90eXBlOiBQcm9ncmVzc0JhckVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5cclxuY29uc3Qgc2NoZW1lID0ge1xyXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXInOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSonLFxyXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnktLSonLFxyXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5LS0qJ1xyXG59O1xyXG5cclxuY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxyXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxyXG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMTAlXCIgc3Ryb2tlLW1pdGVybGltaXQ9XCIxMFwiLz5cclxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeVwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDAlXCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxMCVcIiBzdHJva2UtbWl0ZXJsaW1pdD1cIjEwXCIvPlxyXG4gIDwvc3ZnPlxyXG5gKTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcclxuICogQGNhdGVnb3J5IHByb2dyZXNzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLiBJdCBjYW4gZWl0aGVyIGJlIHVzZWQgdG8gc2hvdyBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkIG9yIHRvIHNob3cgYSBsb29waW5nIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZy5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAY29kZXBlbiBFVnpNalJcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcclxuICogIHZhbHVlPVwiNTVcIlxyXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cclxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XHJcbiAqXHJcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcclxuICogIGluZGV0ZXJtaW5hdGU+XHJcbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxyXG4gKi9cclxuY2xhc3MgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXHJcbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcclxuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XHJcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xyXG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xyXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcclxuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtY2lyY3VsYXItLWluZGV0ZXJtaW5hdGVgKTtcclxuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlYCk7XHJcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlVmFsdWUoKSB7XHJcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcclxuICAgICAgY29uc3QgcGVyID0gTWF0aC5jZWlsKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICogMjUxLjMyICogMC4wMSk7XHJcbiAgICAgIHRoaXMuX3ByaW1hcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykpIHtcclxuICAgICAgY29uc3QgcGVyID0gIE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcclxuICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgdmFsdWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxyXG4gICAqL1xyXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgaW5kZXRlcm1pbmF0ZVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUlmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcclxuXHJcbiAgICB0aGlzLl9wcmltYXJ5ID0gdGhpcy5fdGVtcGxhdGUuY2hpbGROb2Rlc1szXTtcclxuICAgIHRoaXMuX3NlY29uZGFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbMV07XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcclxuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XHJcblxyXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XHJcblxyXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIHtcclxuICBwcm90b3R5cGU6IFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJ29ucy9nZXN0dXJlLWRldGVjdG9yJztcclxuXHJcbmNvbnN0IFNUQVRFX0lOSVRJQUwgPSAnaW5pdGlhbCc7XHJcbmNvbnN0IFNUQVRFX1BSRUFDVElPTiA9ICdwcmVhY3Rpb24nO1xyXG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtcHVsbC1ob29rXHJcbiAqIEBjYXRlZ29yeSBwdWxsLWhvb2tcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgYWRkcyAqKlB1bGwgdG8gcmVmcmVzaCoqIGZ1bmN0aW9uYWxpdHkgdG8gYW4gYDxvbnMtcGFnZT5gIGVsZW1lbnQuXHJcbiAqXHJcbiAqICAgICBJdCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGEgdGFzayB3aGVuIHRoZSB1c2VyIHB1bGxzIGRvd24gYXQgdGhlIHRvcCBvZiB0aGUgcGFnZS4gQSBjb21tb24gdXNhZ2UgaXMgdG8gcmVmcmVzaCB0aGUgZGF0YSBkaXNwbGF5ZWQgaW4gYSBwYWdlLlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBjb2RlcGVuIFdiSm9nTVxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHVsbC1ob29rXHJcbiAqIEBndWlkZSBVc2luZ1B1bGxIb29rXHJcbiAqICAgW2VuXUhvdyB0byB1c2UgUHVsbCBIb29rWy9lbl1cclxuICogICBbamFd44OX44Or44OV44OD44Kv44KS5L2/44GGWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1wYWdlPlxyXG4gKiAgIDxvbnMtcHVsbC1ob29rPlxyXG4gKiAgICAgUmVsZWFzZSB0byByZWZyZXNoXHJcbiAqICAgPC9vbnMtcHVsbC1ob29rPlxyXG4gKiA8L29ucy1wYWdlPlxyXG4gKlxyXG4gKiA8c2NyaXB0PlxyXG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wdWxsLWhvb2snKS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGRvbmUpIHtcclxuICogICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCk7XHJcbiAqICAgfTtcclxuICogPC9zY3JpcHQ+XHJcbiAqL1xyXG5jbGFzcyBQdWxsSG9va0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBjaGFuZ2VzdGF0ZVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN0YXRlIGlzIGNoYW5nZWQuIFRoZSBzdGF0ZSBjYW4gYmUgZWl0aGVyIFwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiIG9yIFwiYWN0aW9uXCIuWy9lbl1cclxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7nirbmhYvjgYzlpInjgo/jgaPjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgILnirbmhYvjga/jgIFcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiwgXCJhY3Rpb25cIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XHJcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucHVsbEhvb2tcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQuc3RhdGVcclxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Gu54q25oWL5ZCN44KS5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgXCJwdWxsLXRvLXJlZnJlc2hcIiBmdW5jdGlvbmFsaXR5IGlzIGRpc2FibGVkLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZGlzYWJsZWTnirbmhYvjgavjgarjgorjgqLjgq/jgrfjg6fjg7PjgYzlrp/ooYzjgZXjgozjgarjgY/jgarjgorjgb7jgZlbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGhlaWdodFxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQuIFdoZW4gcHVsbGVkIGRvd24gZnVydGhlciB0aGFuIHRoaXMgdmFsdWUgaXQgd2lsbCBzd2l0Y2ggdG8gdGhlIFwicHJlYWN0aW9uXCIgc3RhdGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiNjRweFwiLlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu6auY44GV5Lul5LiK44GrcHVsbCBkb3du44GZ44KL44GoXCJwcmVhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBruWApOOBr1wiNjRweFwi44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSB0aHJlc2hvbGQtaGVpZ2h0XHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSB0aHJlc2hvbGQgaGVpZ2h0LiBUaGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgc3dpdGNoZXMgdG8gdGhlIFwiYWN0aW9uXCIgc3RhdGUgd2hlbiBwdWxsZWQgZnVydGhlciB0aGFuIHRoaXMgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiOTZweFwiLiBBIG5lZ2F0aXZlIHZhbHVlIG9yIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSBoZWlnaHQgd2lsbCBkaXNhYmxlIHRoaXMgcHJvcGVydHkuWy9lbl1cclxuICAgKiAgIFtqYV3plr7lgKTjgajjgarjgovpq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lgKTjgafmjIflrprjgZfjgZ/pq5jjgZXjgojjgorjgoJwdWxsIGRvd27jgZnjgovjgajjgIHjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/oh6rli5XnmoTjgatcImFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC1jb250ZW50XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjb250ZW50IG9mIHRoZSBwYWdlIHdpbGwgbm90IG1vdmUgd2hlbiBwdWxsaW5nLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gm44GE44KL5pmC44Gr44KC44Kz44Oz44OG44Oz44OE44Gv5YuV44GN44G+44Gb44KT44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fYm91bmRPbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IDA7XHJcblxyXG4gICAgdGhpcy5fZW5zdXJlU2Nyb2xsRWxlbWVudCgpO1xyXG5cclxuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwsIHRydWUpO1xyXG4gICAgdGhpcy5fc2V0U3R5bGUoKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGVTY3JvbGxFbGVtZW50KCkge1xyXG4gICAgaWYgKHRoaXMucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Njcm9sbCcpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInNjcm9sbFwiPjxkaXY+Jyk7XHJcblxyXG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gICAgc2Nyb2xsRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzKTtcclxuICAgIHdoaWxlIChwYWdlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcbiAgICAgIHNjcm9sbEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbiAgICBwYWdlRWxlbWVudC5hcHBlbmRDaGlsZChzY3JvbGxFbGVtZW50KTtcclxuXHJcbiAgICByZXR1cm4gc2Nyb2xsRWxlbWVudDtcclxuICB9XHJcblxyXG4gIF9lbnN1cmVTY3JvbGxFbGVtZW50KCkge1xyXG4gICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCAmJiAhdGhpcy5fc2Nyb2xsRWxlbWVudCkge1xyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fY3JlYXRlU2Nyb2xsRWxlbWVudCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3NldFN0eWxlKCkge1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgdGhpcy5zdHlsZS50b3AgPSAnLScgKyBoZWlnaHQgKyAncHgnO1xyXG4gICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG4gICAgdGhpcy5zdHlsZS5saW5lSGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuICB9XHJcblxyXG4gIF9vblNjcm9sbChldmVudCkge1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3BhZ2VFbGVtZW50O1xyXG5cclxuICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IDApIHtcclxuICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKSB7XHJcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKDBweCwgJyArIHNjcm9sbCArICdweCwgMHB4KSc7XHJcbiAgfVxyXG5cclxuICBfb25EcmFnKGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWdub3JlIHdoZW4gZHJhZ2dpbmcgbGVmdCBhbmQgcmlnaHQuXHJcbiAgICBpZiAoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBldmVudC5nZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFjayB0byBtYWtlIGl0IHdvcmsgb24gQW5kcm9pZCA0LjQgV2ViVmlldy4gU2Nyb2xscyBtYW51YWxseSBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc29cclxuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uIEFsbG93aW5nIGRlZmF1bHQgc2Nyb2xsaW5nIHdpbGxcclxuICAgIC8vIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9wYWdlRWxlbWVudDtcclxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5fc3RhcnRTY3JvbGwgLSBldmVudC5nZXN0dXJlLmRlbHRhWTtcclxuICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiBldmVudC5nZXN0dXJlLmRpcmVjdGlvbiAhPT0gJ3VwJykge1xyXG4gICAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9PT0gMCAmJiB0aGlzLl9nZXRDdXJyZW50U2Nyb2xsKCkgPT09IDApIHtcclxuICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggPSBldmVudC5nZXN0dXJlLmRlbHRhWTtcclxuXHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50Lmdlc3R1cmUuaW50ZXJpbURpcmVjdGlvbjtcclxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggLT0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoZXZlbnQuZ2VzdHVyZS5kZWx0YVkgLSB0aGlzLl9zdGFydFNjcm9sbCwgMCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSAmJiBzY3JvbGwgPj0gdGhpcy50aHJlc2hvbGRIZWlnaHQpIHtcclxuICAgICAgZXZlbnQuZ2VzdHVyZS5zdG9wRGV0ZWN0KCk7XHJcblxyXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZmluaXNoKCkpO1xyXG4gICAgfSBlbHNlIGlmIChzY3JvbGwgPj0gdGhpcy5oZWlnaHQpIHtcclxuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfUFJFQUNUSU9OKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xyXG4gICAgfVxyXG5cclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgdGhpcy5fdHJhbnNsYXRlVG8oc2Nyb2xsKTtcclxuICB9XHJcblxyXG4gIF9vbkRyYWdTdGFydChldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3N0YXJ0U2Nyb2xsID0gdGhpcy5fZ2V0Q3VycmVudFNjcm9sbCgpO1xyXG4gIH1cclxuXHJcbiAgX29uRHJhZ0VuZChldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPiAwKSB7XHJcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcclxuXHJcbiAgICAgIGlmIChzY3JvbGwgPiB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBvbkFjdGlvblxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYWN0aW9uYCBzdGF0ZSBpZiBpdCBleGlzdHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgYGRvbmVgIGNhbGxiYWNrIGFzIGl0J3MgZmlyc3QgYXJndW1lbnQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICBfZmluaXNoKCkge1xyXG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfQUNUSU9OKTtcclxuICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHRoaXMuaGVpZ2h0LCB7YW5pbWF0ZTogdHJ1ZX0pO1xyXG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5vbkFjdGlvbiB8fCAoZG9uZSA9PiBkb25lKCkpO1xyXG4gICAgYWN0aW9uKCgpID0+IHtcclxuICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcclxuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBoZWlnaHRcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRoZSBoZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA2NHB4YC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xyXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaGVpZ2h0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhlaWdodCgpIHtcclxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgJzY0JywgMTApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHRocmVzaG9sZEhlaWdodFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIHRocmVzaG9sZEhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDk2cHhgLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBzZXQgdGhyZXNob2xkSGVpZ2h0KHZhbHVlKSB7XHJcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0aHJlc2hvbGQgaGVpZ2h0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcclxuICB9XHJcblxyXG4gIGdldCB0aHJlc2hvbGRIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnKSB8fCAnOTYnLCAxMCk7XHJcbiAgfVxyXG5cclxuICBfdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpIHtcclxuICAgIGNvbnN0IHRoID0gdGhpcy50aHJlc2hvbGRIZWlnaHQ7XHJcbiAgICByZXR1cm4gdGggPiAwICYmIHRoID49IHRoaXMuaGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgX3NldFN0YXRlKHN0YXRlLCBub0V2ZW50KSB7XHJcbiAgICBjb25zdCBsYXN0U3RhdGUgPSB0aGlzLl9nZXRTdGF0ZSgpO1xyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcclxuXHJcbiAgICBpZiAoIW5vRXZlbnQgJiYgbGFzdFN0YXRlICE9PSB0aGlzLl9nZXRTdGF0ZSgpKSB7XHJcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlc3RhdGUnLCB7XHJcbiAgICAgICAgcHVsbEhvb2s6IHRoaXMsXHJcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICAgIGxhc3RTdGF0ZTogbGFzdFN0YXRlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2dldFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHN0YXRlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBnZXQgc3RhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcclxuICB9XHJcblxyXG4gIF9nZXRDdXJyZW50U2Nyb2xsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VFbGVtZW50LnNjcm9sbFRvcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBwdWxsRGlzdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IG51bWJlciBvZiBwaXhlbHMgdGhlIHB1bGwgaG9vayBoYXMgbW92ZWQuWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjga7jg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgZ/ot53pm6LjgpLjg5Tjgq/jgrvjg6vmlbDjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBwdWxsRGlzdGFuY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cclxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxyXG4gICAqL1xyXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGdldCBkaXNhYmxlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcclxuICB9XHJcblxyXG4gIF9pc0NvbnRlbnRGaXhlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZml4ZWQtY29udGVudCcpO1xyXG4gIH1cclxuXHJcbiAgX2dldFNjcm9sbGFibGVFbGVtZW50KCkge1xyXG4gICAgaWYgKHRoaXMuX2lzQ29udGVudEZpeGVkKCkpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqL1xyXG4gIF90cmFuc2xhdGVUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9PSAwICYmIHNjcm9sbCA9PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkb25lID0gKCkgPT4ge1xyXG4gICAgICBpZiAoc2Nyb2xsID09PSAwICYmICF0aGlzLl9pc0NvbnRlbnRGaXhlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5fZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IHNjcm9sbDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5hbmltYXRlKSB7XHJcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXHJcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucGxheShkb25lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnBsYXkoZG9uZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZ2V0TWluaW11bVNjcm9sbCgpIHtcclxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgY29uc3QgcGFnZUhlaWdodCA9IHRoaXMuX3BhZ2VFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gc2Nyb2xsSGVpZ2h0ID4gcGFnZUhlaWdodCA/IC0oc2Nyb2xsSGVpZ2h0IC0gcGFnZUhlaWdodCkgOiAwO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLl9wYWdlRWxlbWVudCwge1xyXG4gICAgICBkcmFnTWluRGlzdGFuY2U6IDEsXHJcbiAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCaW5kIGxpc3RlbmVyc1xyXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnJywgdGhpcy5fYm91bmRPbkRyYWcpO1xyXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcclxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcclxuXHJcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50LnBhcmVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgX2Rlc3Ryb3lFdmVudExpc3RlbmVycygpIHtcclxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcclxuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZycsIHRoaXMuX2JvdW5kT25EcmFnKTtcclxuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdTdGFydCk7XHJcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XHJcblxyXG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zY3JvbGxFbGVtZW50ICYmIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuX2Vuc3VyZVNjcm9sbEVsZW1lbnQoKTtcclxuXHJcbiAgICB0aGlzLl9wYWdlRWxlbWVudCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3BhZ2VFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fY29udGVudCcpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignPG9ucy1wdWxsLWhvb2s+IG11c3QgYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiBhbiA8b25zLXBhZ2U+IGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9kZXN0cm95RXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zUHVsbEhvb2tFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcHVsbC1ob29rJywge1xyXG4gIHByb3RvdHlwZTogUHVsbEhvb2tFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuXHJcbndpbmRvdy5PbnNQdWxsSG9va0VsZW1lbnQuU1RBVEVfQUNUSU9OID0gU1RBVEVfQUNUSU9OO1xyXG53aW5kb3cuT25zUHVsbEhvb2tFbGVtZW50LlNUQVRFX0lOSVRJQUwgPSBTVEFURV9JTklUSUFMO1xyXG53aW5kb3cuT25zUHVsbEhvb2tFbGVtZW50LlNUQVRFX1BSRUFDVElPTiA9IFNUQVRFX1BSRUFDVElPTjtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNiBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBBbmltYXRvckNTUyAtIGltcGxlbWVudGF0aW9uIG9mIEFuaW1hdG9yIGNsYXNzIHVzaW5nIGNzcyB0cmFuc2l0aW9uc1xyXG4gKi9cclxuY2xhc3MgQW5pbWF0b3JDU1Mge1xyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGFuaW1hdGVcclxuICAgKiBAZGVzYyBtYWluIGFuaW1hdGlvbiBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5hbENTU1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSAtIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XHJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC50aGVuKGNhbGxiYWNrKSAtIHNldHMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBzdG9wcGVkXHJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zdG9wKG9wdGlvbnMpIC0gc3RvcHMgdGhlIGFuaW1hdGlvbjsgaWYgb3B0aW9ucy5zdG9wTmV4dCBpcyB0cnVlIHRoZW4gaXQgZG9lc24ndCBjYWxsIHRoZSBjYWxsYmFja1xyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuZmluaXNoKG1zKSAtIGZpbmlzaGVzIHRoZSBhbmltYXRpb24gaW4gdGhlIHNwZWNpZmllZCB0aW1lIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3BlZWQobXMpIC0gc2V0cyB0aGUgYW5pbWF0aW9uIHNwZWVkIHNvIHRoYXQgaXQgZmluaXNoZXMgYXMgaWYgdGhlIG9yaWdpbmFsIGR1cmF0aW9uIHdhcyB0aGUgb25lIHNwZWNpZmllZCBoZXJlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBgXHJcbiAgICogIHZhciByZXN1bHQgPSBhbmltYXRvci5hbmltYXRlKGVsLCB7b3BhY2l0eTogMC41fSwgMTAwMCk7XHJcbiAgICpcclxuICAgKiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcclxuICAgKiAgICByZXN1bHQuc3BlZWQoMjAwKS50aGVuKGZ1bmN0aW9uKCl7XHJcbiAgICogICAgICBjb25zb2xlLmxvZygnZG9uZScpO1xyXG4gICAqICAgIH0pO1xyXG4gICAqICB9LCAzMDApO1xyXG4gICAqIGBgYGBcclxuICAgKi9cclxuICBhbmltYXRlKGVsLCBmaW5hbCwgZHVyYXRpb24gPSAyMDApIHtcclxuICAgIHZhciBzdGFydCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXHJcbiAgICAgICAgaW5pdGlhbCA9IHt9LFxyXG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZSxcclxuICAgICAgICBuZXh0ID0gZmFsc2UsXHJcbiAgICAgICAgdGltZW91dCA9IGZhbHNlLFxyXG4gICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmaW5hbCk7XHJcblxyXG4gICAgdmFyIHVwZGF0ZVN0eWxlcyA9ICgpID0+IHtcclxuICAgICAgbGV0IHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChzLmdldFByb3BlcnR5VmFsdWUuYmluZChzKSk7XHJcbiAgICAgIHMgPSBlbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgIHN0b3A6IChvcHRpb25zID0ge30pID0+IHtcclxuICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB2YXIgayA9IE1hdGgubWluKDEsICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb24pO1xyXG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcclxuICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnN0b3BOZXh0KSB7XHJcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmICghc3RvcHBlZCkge1xyXG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSxcclxuICAgICAgdGhlbjogKGNiKSA9PiB7XHJcbiAgICAgICAgbmV4dCA9IGNiO1xyXG4gICAgICAgIGlmIChzdG9wcGVkKSB7XHJcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSxcclxuICAgICAgc3BlZWQ6IChuZXdEdXJhdGlvbikgPT4ge1xyXG4gICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICBuZXdEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3RvcHBlZCkge1xyXG4gICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcblxyXG4gICAgICAgICAgY29uc3QgcGFzc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xyXG4gICAgICAgICAgY29uc3QgIGsgPSBwYXNzZWQgLyBkdXJhdGlvbjtcclxuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IG5ld0R1cmF0aW9uICogKDEgLSBrKTtcclxuXHJcbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdXBkYXRlU3R5bGVzKCk7XHJcblxyXG4gICAgICAgICAgc3RhcnQgPSBlbC5zcGVlZFVwVGltZTtcclxuICAgICAgICAgIGR1cmF0aW9uID0gcmVtYWluaW5nO1xyXG5cclxuICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcclxuXHJcbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIHJlbWFpbmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIGZpbmlzaDogKG1pbGxpc2Vjb25kcyA9IDUwKSA9PiB7XHJcbiAgICAgICAgdmFyIGsgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xyXG5cclxuICAgICAgICByZXN1bHQuc3BlZWQobWlsbGlzZWNvbmRzIC8gKDEgLSBrKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IHN0b3BwZWQgfHwgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcclxuICAgICAgY29uc3QgdiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShlKSk7XHJcbiAgICAgIGluaXRpYWxbZV0gPSBpc05hTih2KSA/IDAgOiB2O1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGlmICghc3RvcHBlZCkge1xyXG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBwcm9wZXJ0aWVzLmpvaW4oJywnKTtcclxuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xyXG5cclxuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xyXG4gICAgICAgIGVsLnN0eWxlW2VdID0gZmluYWxbZV0gKyAoZSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgZHVyYXRpb24pO1xyXG4gICAgdGhpcy5fb25TdG9wQW5pbWF0aW9ucyhlbCwgcmVzdWx0LnN0b3ApO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3F1ZXVlID0gW107XHJcbiAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgfVxyXG5cclxuICBfb25TdG9wQW5pbWF0aW9ucyhlbCwgbGlzdGVuZXIpIHtcclxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xyXG4gICAgdmFyIGkgPSB0aGlzLl9pbmRleCsrO1xyXG4gICAgcXVldWVbZWxdID0gcXVldWVbZWxdIHx8IFtdO1xyXG4gICAgcXVldWVbZWxdW2ldID0gKG9wdGlvbnMpID0+IHtcclxuICAgICAgZGVsZXRlIHF1ZXVlW2VsXVtpXTtcclxuICAgICAgaWYgKHF1ZXVlW2VsXSAmJiBxdWV1ZVtlbF0ubGVuZ3RoID09IDApIHtcclxuICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaXN0ZW5lcihvcHRpb25zKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEBtZXRob2Qgc3RvcEFuaW1hdGlvbnNcclxuICAqIEBkZXNjIHN0b3BzIGFjdGl2ZSBhbmltYXRpb25zIG9uIGEgc3BlY2lmaWVkIGVsZW1lbnRcclxuICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWxlbWVudCAtIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHNcclxuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cclxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxyXG4gICovXHJcbiAgc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XHJcbiAgICAgIHJldHVybiBlbC5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgKHRoaXMuX3F1ZXVlW2VsXSB8fCBbXSkuZm9yRWFjaChlID0+IHsgZShvcHRpb25zIHx8IHt9KTsgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEBtZXRob2Qgc3RvcEFsbFxyXG4gICogQGRlc2Mgc3RvcHMgYWxsIGFjdGl2ZSBhbmltYXRpb25zXHJcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXHJcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcclxuICAqL1xyXG4gIHN0b3BBbGwob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEBtZXRob2QgZmFkZVxyXG4gICogQGRlc2MgZmFkZXMgdGhlIGVsZW1lbnQgKHNob3J0IHZlcnNpb24gZm9yIGFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSkpXHJcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXVxyXG4gICovXHJcbiAgZmFkZShlbCwgZHVyYXRpb24gPSAyMDApIHtcclxuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSwgZHVyYXRpb24pO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yQ1NTO1xyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3ItY3NzJztcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtcmlwcGxlXHJcbiAqIEBjYXRlZ29yeSByaXBwbGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgQWRkcyBhIE1hdGVyaWFsIERlc2lnbiBcInJpcHBsZVwiIGVmZmVjdCB0byBhbiBlbGVtZW50LiBUaGUgcmlwcGxlIGVmZmVjdCB3aWxsIHNwcmVhZCBmcm9tIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgdXNlciB0YXBzLlxyXG4gKlxyXG4gKiAgICAgU29tZSBlbGVtZW50cyBzdWNoIGFzIGA8b25zLWJ1dHRvbj5gIGFuZCBgPG9ucy1mYWI+YCAgc3VwcG9ydCBhIGByaXBwbGVgIGF0dHJpYnV0ZS5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg6rjg4Pjg5fjg6vlirnmnpzjgpJET03opoHntKDjgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAY29kZXBlbiB3S1FXZFpcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JpcHBsZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8ZGl2IGNsYXNzPVwibXktZGl2XCI+XHJcbiAqICA8b25zLXJpcHBsZT48L29ucy1yaXBwbGU+XHJcbiAqIDwvZGl2PlxyXG4gKlxyXG4gKiA8b25zLWJ1dHRvbiByaXBwbGU+Q2xpY2sgbWUhPC9vbnMtYnV0dG9uPlxyXG4gKi9cclxuY2xhc3MgUmlwcGxlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBjb2xvclxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIHJpcHBsZSBlZmZlY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGJhY2tncm91bmRcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLlsvZW5dXHJcbiAgICogICBbamFd6IOM5pmv44Gu6Imy44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgdGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBiZSBkaXNhYmxlZC5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBr+eEoeWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmlwcGxlJyk7XHJcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX2JhY2tncm91bmQnKVswXTtcclxuICAgICAgdGhpcy5fd2F2ZSA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX193YXZlJylbMF07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcclxuXHJcbiAgICBbJ2NvbG9yJywgJ2NlbnRlcicsICdzdGFydC1yYWRpdXMnLCAnYmFja2dyb3VuZCddLmZvckVhY2goZSA9PiB7XHJcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICBbJ193YXZlJywgJ19iYWNrZ3JvdW5kJ10uZm9yRWFjaChlID0+IHtcclxuICAgICAgdGhpc1tlXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICB0aGlzW2VdLmNsYXNzTGlzdC5hZGQoJ3JpcHBsZV8nICsgZSk7XHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpc1tlXSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XHJcbiAgfVxyXG5cclxuICBfY2FsY3VsYXRlQ29vcmRzKGUpIHtcclxuICAgIHZhciB4LCB5LCBoLCB3LCByO1xyXG4gICAgdmFyIGIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgaWYgKHRoaXMuX2NlbnRlcikge1xyXG4gICAgICB4ID0gYi53aWR0aCAvIDI7XHJcbiAgICAgIHkgPSBiLmhlaWdodCAvIDI7XHJcbiAgICAgIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gKGUuY2xpZW50WCB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgpIC0gYi5sZWZ0O1xyXG4gICAgICB5ID0gKGUuY2xpZW50WSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpIC0gYi50b3A7XHJcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xyXG4gICAgICB3ID0gTWF0aC5tYXgoeCwgYi53aWR0aCAtIHgpO1xyXG4gICAgICByID0gTWF0aC5zcXJ0KGggKiBoICsgdyAqIHcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt4LCB5LCByfTtcclxuICB9XHJcblxyXG4gIF9yaXBwbGVBbmltYXRpb24oZSwgZHVyYXRpb24gPSAzMDApIHtcclxuICAgIHZhclxyXG4gICAgICB7X2FuaW1hdG9yLCBfd2F2ZSwgX2JhY2tncm91bmQsIF9taW5SfSA9IHRoaXMsXHJcbiAgICAgIHt4LCB5LCByfSA9IHRoaXMuX2NhbGN1bGF0ZUNvb3JkcyhlKTtcclxuXHJcbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcclxuICAgIF9hbmltYXRvci5hbmltYXRlKF9iYWNrZ3JvdW5kLCB7b3BhY2l0eTogMX0sIGR1cmF0aW9uKTtcclxuXHJcbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xyXG4gICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICB0b3A6IHkgLSBfbWluUiArICdweCcsXHJcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXHJcbiAgICAgIHdpZHRoOiAyICogX21pblIgKyAncHgnLFxyXG4gICAgICBoZWlnaHQ6IDIgKiBfbWluUiArICdweCdcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBfYW5pbWF0b3IuYW5pbWF0ZShfd2F2ZSwge1xyXG4gICAgICB0b3A6IHkgLSByLFxyXG4gICAgICBsZWZ0OiB4IC0gcixcclxuICAgICAgaGVpZ2h0OiAyICogcixcclxuICAgICAgd2lkdGg6IDIgKiByXHJcbiAgICB9LCBkdXJhdGlvbik7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlUGFyZW50KCkge1xyXG4gICAgaWYgKCF0aGlzLl9wYXJlbnRVcGRhdGVkICYmIHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcclxuICAgICAgaWYgKGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uVGFwKGUpIHtcclxuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcclxuICAgICAgdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX2JhY2tncm91bmQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vbkhvbGQoZSkge1xyXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVBhcmVudCgpO1xyXG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25SZWxlYXNlKGUpIHtcclxuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XHJcbiAgICAgIHRoaXMuX2hvbGRpbmcuc3BlZWQoMzAwKS50aGVuKCgpID0+IHtcclxuICAgICAgICB0aGlzLl9hbmltYXRvci5zdG9wQWxsKHtzdG9wTmV4dDogdHJ1ZX0pO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9ob2xkaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcclxuICB9XHJcblxyXG4gIF9vbkRyYWdTdGFydChlKSB7XHJcbiAgICBpZiAodGhpcy5faG9sZGluZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZS5nZXN0dXJlLmRpcmVjdGlvbikgIT0gLTEpIHtcclxuICAgICAgdGhpcy5fb25UYXAoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcclxuICAgIHRoaXMuX2JvdW5kT25UYXAgPSB0aGlzLl9vblRhcC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fYm91bmRPbkhvbGQgPSB0aGlzLl9vbkhvbGQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fYm91bmRPblJlbGVhc2UgPSB0aGlzLl9vblJlbGVhc2UuYmluZCh0aGlzKTtcclxuXHJcbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XHJcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcclxuICAgICAgdGhpcy5fcGFyZW50Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9wYXJlbnROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX2JvdW5kT25UYXApO1xyXG4gICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fYm91bmRPbkhvbGQpO1xyXG4gICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ3N0YXJ0LXJhZGl1cycpIHtcclxuICAgICAgdGhpcy5fbWluUiA9IE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoY3VycmVudCkgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZSA9PT0gJ2NvbG9yJyAmJiBjdXJyZW50KSB7XHJcbiAgICAgIHRoaXMuX3dhdmUuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XHJcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ2JhY2tncm91bmQnKSkge1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuYW1lID09PSAnYmFja2dyb3VuZCcgJiYgKGN1cnJlbnQgfHwgbGFzdCkpIHtcclxuICAgICAgaWYgKGN1cnJlbnQgPT09ICdub25lJykge1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgIHRoaXMuX2NlbnRlciA9IGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9ICdmYWxzZSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc1JpcHBsZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1yaXBwbGUnLCB7XHJcbiAgcHJvdG90eXBlOiBSaXBwbGVFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtcm93XHJcbiAqIEBjYXRlZ29yeSBncmlkXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cclxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm6KGM44KS5a6a576p44GX44G+44GZ44CCb25zLWNvbOOBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBrumFjee9ruOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXHJcbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxyXG4gKiBAZ3VpZGUgTGF5b3V0aW5nXHJcbiAqICAgW2VuXUxheW91dGluZyBndWlkZVsvZW5dXHJcbiAqICAgW2phXeODrOOCpOOCouOCpuODiOiqv+aVtFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1jb2xcclxuICogICBbZW5dVGhlIGA8b25zLWNvbD5gIGNvbXBvbmVudCBpcyB1c2VkIGFzIGNoaWxkcmVuIG9mIGA8b25zLXJvdz5gLlsvZW5dXHJcbiAqICAgW2phXW9ucy1jb2zjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAbm90ZVxyXG4gKiAgIFtlbl1Gb3IgQW5kcm9pZCA0LjMgYW5kIGVhcmxpZXIsIGFuZCBpT1M2IGFuZCBlYXJsaWVyLCB3aGVuIHVzaW5nIG1peGVkIGFsaWdubWVudCB3aXRoIG9ucy1yb3cgYW5kIG9ucy1jb2wsIHRoZXkgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LiBZb3UgY2FuIHVzZSBvbmx5IG9uZSB2ZXJ0aWNhbC1hbGlnbi5bL2VuXVxyXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbOOCkue1hOOBv+WQiOOCj+OBm+OBpuOBneOCjOOBnuOCjOOBrm9ucy1jb2zopoHntKDjga52ZXJ0aWNhbC1hbGlnbuWxnuaAp+OBruWApOOBq+WIpeOAheOBruWApOOCkuaMh+WumuOBmeOCi+OBqOOAgeaPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAgnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr44Gv5LiA44Gk44Gu5YCk44Gg44GR44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1yb3c+XHJcbiAqICAgPG9ucy1jb2wgd2lkdGg9XCI1MHB4XCI+PG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj48L29ucy1jb2w+XHJcbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cclxuICogPC9vbnMtcm93PlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAYXR0cmlidXRlIHZlcnRpY2FsLWFsaWduXHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1TaG9ydCBoYW5kIGF0dHJpYnV0ZSBmb3IgYWxpZ25pbmcgdmVydGljYWxseS4gVmFsaWQgdmFsdWVzIGFyZSB0b3AsIGJvdHRvbSwgYW5kIGNlbnRlci5bL2VuXVxyXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gKi9cclxud2luZG93Lk9uc1Jvd0VsZW1lbnQgPSB3aW5kb3cuT25zUm93RWxlbWVudCA/IHdpbmRvdy5PbnNSb3dFbGVtZW50IDogZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcm93Jyk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnJzogJ3NwZWVkLWRpYWxfX2l0ZW0tLSonLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsLWl0ZW1cclxuICogQGNhdGVnb3J5IHNwZWVkLWRpYWxcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgZGlhbCBjb21wb25lbnQuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdXHJcbiAqICAgICBNYXRlcmlhbCBEZXNpZ27jga5TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo54++44GZ44KL6KaB57Sg44Gn44GZ44CCXHJcbiAqICAgWy9qYV1cclxuICogQGNvZGVwZW4gZFlRWUxnXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXHJcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXHJcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50LlsvZW5dXHJcbiAqICAgW2phXW9ucy1zcGVlZC1kaWFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cclxuICogICA8b25zLWZhYj5cclxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XHJcbiAqICAgPC9vbnMtZmFiPlxyXG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XHJcbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cclxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxyXG4gKiA8L29ucy1zcGVlZC1kaWFsPlxyXG4gKi9cclxuY2xhc3MgU3BlZWREaWFsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9jb21waWxlKCk7XHJcblxyXG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICBjYXNlICdtb2RpZmllcic6XHJcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVSaXBwbGUoKSB7XHJcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcclxuICB9XHJcblxyXG4gIF9vbkNsaWNrKGUpIHtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiJyk7XHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tbWluaScpO1xyXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzcGVlZC1kaWFsX19pdGVtJyk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XHJcblxyXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc1NwZWVkRGlhbEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BlZWQtZGlhbC1pdGVtJywge1xyXG4gIHByb3RvdHlwZTogU3BlZWREaWFsSXRlbUVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxyXG4gKi9cclxuY29uc3Qgc3R5bGVyID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGUpIHtcclxuICByZXR1cm4gc3R5bGVyLmNzcy5hcHBseShzdHlsZXIsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IGVsZW1lbnQncyBzdHlsZS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcclxuICogQHJldHVybiB7RWxlbWVudH1cclxuICovXHJcbnN0eWxlci5jc3MgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZXMpIHtcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XHJcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgaWYgKGtleSBpbiBlbGVtZW50LnN0eWxlKSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xyXG4gICAgfSBlbHNlIGlmIChzdHlsZXIuX3ByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcclxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZXIuX3ByZWZpeChrZXkpXSA9IHN0eWxlc1trZXldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgdmVuZG9yIHByZWZpeC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuc3R5bGVyLl9wcmVmaXggPSAoZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xyXG4gIHZhciBwcmVmaXggPSAoQXJyYXkucHJvdG90eXBlLnNsaWNlXHJcbiAgICAuY2FsbChzdHlsZXMpXHJcbiAgICAuam9pbignJylcclxuICAgIC5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKSB8fCAoc3R5bGVzLk9MaW5rID09PSAnJyAmJiBbJycsICdvJ10pXHJcbiAgKVsxXTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHJldHVybiBwcmVmaXggKyBuYW1lLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICovXHJcbnN0eWxlci5jbGVhciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICBzdHlsZXIuX2NsZWFyKGVsZW1lbnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gKi9cclxuc3R5bGVyLl9jbGVhciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICB2YXIgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7XHJcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcclxuICB2YXIga2V5cyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGtleXMucHVzaChzdHlsZVtpXSk7XHJcbiAgfVxyXG5cclxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBzdHlsZVtrZXldID0gJyc7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzdHlsZXI7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcbmltcG9ydCBzdHlsZXIgZnJvbSAnbGliL3N0eWxlcic7XHJcblxyXG5jb25zdCBzY2hlbWUgPSB7XHJcbiAgJyc6ICdzcGVlZC1kaWFsLS0qJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtc3BlZWQtZGlhbFxyXG4gKiBAY2F0ZWdvcnkgc3BlZWQtZGlhbFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogICBbZW5dXHJcbiAqICAgICBFbGVtZW50IHRoYXQgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgRGlhbG9nIGNvbXBvbmVudC4gSXQgaXMgdXNlZnVsIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBhY3Rpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGluIGEgcGFnZS5cclxuICpcclxuICogICAgIFRoZSBTcGVlZCBkaWFsIGxvb2tzIGxpa2UgYSBgPG9ucy1mYWI+YCBlbGVtZW50IGJ1dCB3aWxsIGV4cGFuZCBhIG1lbnUgd2hlbiB0YXBwZWQuXHJcbiAqICAgWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGNvZGVwZW4gZFlRWUxnXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXHJcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cclxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWwtaXRlbT5gIHJlcHJlc2VudHMgYSBtZW51IGl0ZW0uWy9lbl1cclxuICogICBbamFdb25zLXNwZWVkLWRpYWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XHJcbiAqICAgPG9ucy1mYWI+XHJcbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxyXG4gKiAgIDwvb25zLWZhYj5cclxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxyXG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XHJcbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cclxuICogPC9vbnMtc3BlZWQtZGlhbD5cclxuICovXHJcbmNsYXNzIFNwZWVkRGlhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBvcGVuXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgc2hvd24uWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAZXZlbnQgY2xvc2VcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBoaWRkZW4uWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dXHJcbiAgICogICAgIFNwZWNpZnkgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICogICAgIEkuZS4gdG8gZGlzcGxheSBpdCBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBzcGVjaWZ5IFwicmlnaHQgdG9wXCIuXHJcbiAgICogICAgIENob29zZSBmcm9tIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIgYW5kIFwiYm90dG9tXCIuXHJcbiAgICogICBbL2VuXVxyXG4gICAqICAgW2phXVxyXG4gICAqICAgICDjgZPjga7opoHntKDjgpLooajnpLrjgZnjgovlt6blj7PjgajkuIrkuIvjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcclxuICAgKiAgICAg5L6L44GI44Gw44CB5Y+z5LiK44Gr6KGo56S644GZ44KL5aC05ZCI44Gr44GvXCJyaWdodCB0b3BcIuOCkuaMh+WumuOBl+OBvuOBmeOAglxyXG4gICAqICAgICDlt6blj7PjgajkuIrkuIvjga7kvY3nva7jga7mjIflrprjgavjga/jgIFyaWdodOOBqGxlZnTjgIF0b3Djgahib3R0b23jgYzjgZ3jgozjgZ7jgozmjIflrprjgafjgY3jgb7jgZnjgIJcclxuICAgKiAgIFsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxyXG4gICAqICAgW2phXVxyXG4gICAqICAgICDopoHntKDjgYzooajnpLrjgZnjgovmlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJ1cCwgZG93biwgbGVmdCwgcmlnaHTjgYzmjIflrprjgafjgY3jgb7jgZnjgIJcclxuICAgKiAgIFsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cclxuICAgKiAgIFtqYV3nhKHlirnljJbjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9zaG93biA9IHRydWU7XHJcbiAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcclxuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucygnc3BlZWRfX2RpYWwnKSkge1xyXG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3NwZWVkX19kaWFsJyk7XHJcbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG4gICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcclxuICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbih0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcclxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAncmlwcGxlJzpcclxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUmlwcGxlKCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxyXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVEaXJlY3Rpb24oY3VycmVudCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdwb3NpdGlvbic6XHJcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBnZXQgaXRlbXMoKSB7XHJcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtc3BlZWQtZGlhbC1pdGVtJykpO1xyXG4gIH1cclxuXHJcbiAgX29uQ2xpY2soZSkge1xyXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuX3Nob3duKSB7XHJcbiAgICAgIHRoaXMudG9nZ2xlSXRlbXMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9zaG93KCkge1xyXG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xyXG4gICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oaWRlKCkge1xyXG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xyXG4gICAgICB0aGlzLmhpZGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVSaXBwbGUoKSB7XHJcbiAgICBjb25zdCBmYWIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWZhYicpO1xyXG5cclxuICAgIGlmIChmYWIpIHtcclxuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcclxuICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogaSArICdtcycsXHJcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXHJcbiAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICB0b3A6ICdhdXRvJyxcclxuICAgICAgICBsZWZ0OiAnYXV0bydcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xyXG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucmlnaHQgPSAnOHB4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcclxuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAnOHB4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xyXG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucmlnaHQgPSA3MiArIDU2ICogaSArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XHJcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcclxuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcclxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcclxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXHJcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXHJcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxyXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXHJcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XHJcbiAgICBzd2l0Y2gocG9zaXRpb24pIHtcclxuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcclxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3AgbGVmdCc6XHJcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XHJcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XHJcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxyXG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XHJcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcclxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XHJcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxyXG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcclxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2hvd1xyXG4gICAqIEBzaWduYXR1cmUgc2hvdygpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbC5bL2VuXVxyXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1mYWInKS5zaG93KCk7XHJcbiAgICB0aGlzLl9zaG93biA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGhpZGVcclxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwuWy9lbl1cclxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5oaWRlSXRlbXMoKTtcclxuICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtZmFiJykuaGlkZSgpO1xyXG4gICAgfSwgMjAwKTtcclxuICAgIHRoaXMuX3Nob3duID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIHNob3dJdGVtc1xyXG4gICAqIEBzaWduYXR1cmUgc2hvd0l0ZW1zKClcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXHJcbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgc2hvd0l0ZW1zKCkge1xyXG5cclxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXHJcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogaSArICdtcydcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5faXRlbVNob3duID0gdHJ1ZTtcclxuXHJcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ29wZW4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgaGlkZUl0ZW1zXHJcbiAgICogQHNpZ25hdHVyZSBoaWRlSXRlbXMoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cclxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICBoaWRlSXRlbXMoKSB7XHJcbiAgICBpZiAodGhpcy5faXRlbVNob3duKSB7XHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xyXG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxyXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiAyNSAqIChjaGlsZHJlbi5sZW5ndGggLSBpKSArICdtcydcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XHJcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Nsb3NlJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgdGhpcy5oaWRlSXRlbXMoKTtcclxuICAgIH1cclxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZSA9PiB7XHJcbiAgICAgIHV0aWwubWF0Y2goZSwgJy5mYWInKSAmJiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZShlLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGlubGluZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgaW5saW5lIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODs+ODqeOCpOODs+imgee0oOOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgZ2V0IGlubGluZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cclxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCB2aXNpYmxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Nob3duICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc09wZW5cclxuICAgKiBAc2lnbmF0dXJlIGlzT3BlbigpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBtZW51IGlzIG9wZW4gb3Igbm90LlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBpc09wZW4oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXRlbVNob3duO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCB0b2dnbGVcclxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVG9nZ2xlIHZpc2liaWxpdHkuWy9lbl1cclxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICB0b2dnbGUoKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCB0b2dnbGVJdGVtc1xyXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlSXRlbXMoKVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVRvZ2dsZSBpdGVtIHZpc2liaWxpdHkuWy9lbl1cclxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuICB0b2dnbGVJdGVtcygpIHtcclxuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XHJcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNob3dJdGVtcygpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc1NwZWVkRGlhbEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1zcGVlZC1kaWFsJywge1xyXG4gIHByb3RvdHlwZTogU3BlZWREaWFsRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5cclxuY29uc3QgcmV3cml0YWJsZXMgPSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICByZWFkeShlbGVtZW50LCBjYWxsYmFjaykge1xyXG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxGcmFnbWVudH0gdGFyZ2V0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIGxpbmsoZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLWNvbnRlbnRcclxuICogQGNhdGVnb3J5IHNwbGl0dGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgW2VuXVxyXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cclxuICpcclxuICogICAgSXQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZSB3aGlsZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29udGFpbnMgdGhlIGxpc3QuXHJcbiAqICBbL2VuXVxyXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gv44CBb25zLXNwbGl0dGVy6KaB57Sg44Gu5a2Q6KaB57Sg44Go44GX44Gm5Yip55So44GX44G+44GZ44CCWy9qYV1cclxuICogQGNvZGVwZW4gck9RT01MXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxyXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBlbGVtZW50LlsvZW5dXHJcbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxyXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1zcGxpdHRlcj5cclxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XHJcbiAqICAgICAuLi5cclxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxyXG4gKlxyXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XHJcbiAqICAgICAuLi5cclxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxyXG4gKiA8L29ucy1zcGxpdHRlcj5cclxuICovXHJcbmNsYXNzIFNwbGl0dGVyQ29udGVudEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dXHJcbiAgICogICAgIFRoZSB1cmwgb2YgdGhlIGNvbnRlbnQgcGFnZS4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdXNlZCB0aGUgY29udGVudCB3aWxsIGJlIGxvYWRlZCBmcm9tIGEgYDxvbnMtdGVtcGxhdGU+YCB0YWcgb3IgYSByZW1vdGUgZmlsZS5cclxuICAgKlxyXG4gICAqICAgICBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHB1dCBgPG9ucy1wYWdlPmAgZWxlbWVudCBhcyBhIGNoaWxkIG9mIHRoZSBlbGVtZW50LlxyXG4gICAqICAgWy9lbl1cclxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvbnMtc3BsaXR0ZXItY29udGVudFwiIG11c3QgaGF2ZSBcIm9ucy1zcGxpdHRlclwiIGFzIHBhcmVudE5vZGUuYCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygncGFnZScsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJykpO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoZWRDYWxsYmFjaygpIHt9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ3BhZ2UnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4gdGhpcy5sb2FkKGN1cnJlbnQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBwYWdlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGdldCBwYWdlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGxvYWRcclxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlLCBbb3B0aW9uc11cclxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQuWy9lbl1cclxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBgcGFnZWAgaW4gdGhlIGNvbnRlbnQuWy9lbl1cclxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBgPG9ucy1wYWdlPmAgZWxlbWVudFsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XHJcblxyXG4gICAgcmV0dXJuIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIHV0aWwuY3JlYXRlRnJhZ21lbnQoaHRtbCksIG9wdGlvbnMsIGZyYWdtZW50ID0+IHtcclxuICAgICAgICB0aGlzLl9oaWRlKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3Nob3coKTtcclxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xyXG4gICAgICAgIHJlc29sdmUodGhpcy5maXJzdENoaWxkKTtcclxuICAgICAgfSk7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICBfc2hvdygpIHtcclxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xyXG4gIH1cclxuXHJcbiAgX2hpZGUoKSB7XHJcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcclxuICB9XHJcblxyXG4gIF9kZXN0cm95KCkge1xyXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc1NwbGl0dGVyQ29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1zcGxpdHRlci1jb250ZW50Jywge1xyXG4gIHByb3RvdHlwZTogU3BsaXR0ZXJDb250ZW50RWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcblxyXG53aW5kb3cuT25zU3BsaXR0ZXJDb250ZW50RWxlbWVudC5yZXdyaXRhYmxlcyA9IHJld3JpdGFibGVzO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcblxyXG5jbGFzcyBTcGxpdHRlck1hc2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBfb25DbGljayhldmVudCkge1xyXG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcclxuICAgICAgdGhpcy5wYXJlbnROb2RlLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4gc2lkZS5jbG9zZSgnbGVmdCcpLmNhdGNoKCgpID0+IHt9KSk7XHJcbiAgICB9XHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zU3BsaXR0ZXJNYXNrRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snLCB7XHJcbiAgcHJvdG90eXBlOiBTcGxpdHRlck1hc2tFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckFuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLl9vcHRpb25zID0ge1xyXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxyXG4gICAgICBkdXJhdGlvbjogJzAuMycsXHJcbiAgICAgIGRlbGF5OiAnMCdcclxuICAgIH07XHJcbiAgICB0aGlzLnVwZGF0ZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdXRpbC5leHRlbmQodGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLl90aW1pbmcgPSB0aGlzLl9vcHRpb25zLnRpbWluZztcclxuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fb3B0aW9ucy5kdXJhdGlvbjtcclxuICAgIHRoaXMuX2RlbGF5ID0gdGhpcy5fb3B0aW9ucy5kZWxheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc2lkZUVsZW1lbnRcclxuICAgKi9cclxuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xyXG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnROb2RlO1xyXG5cclxuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9zaWRlID0gc2lkZUVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSBzcGxpdHRlci5jb250ZW50O1xyXG4gICAgICB0aGlzLl9tYXNrID0gc3BsaXR0ZXIubWFzaztcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5hY3RpdmF0ZSgpIHtcclxuICAgIHRoaXMuX2NvbnRlbnQgPSB0aGlzLl9zaWRlID0gdGhpcy5fbWFzayA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXQgbWludXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5fc2lkZSA9PT0gJ3JpZ2h0JyA/ICctJyA6ICcnO1xyXG4gIH1cclxuXHJcbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XHJcbiAgICBhbmltaXQodGhpcy5fc2lkZSlcclxuICAgICAgLnF1ZXVlKHtcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxyXG4gICAgICB9KVxyXG4gICAgICAucGxheSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxyXG4gICAqL1xyXG4gIG9wZW4oZG9uZSkge1xyXG4gICAgYW5pbWl0LnJ1bkFsbChcclxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXHJcbiAgICAgICAgLndhaXQodGhpcy5fZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51c30xMDAlLCAwcHgsIDBweClgXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxyXG4gICAgICAgICAgdGltaW5nOiB0aGlzLl90aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcclxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIG9wYWNpdHk6ICcxJ1xyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXHJcbiAgICovXHJcbiAgY2xvc2UoZG9uZSkge1xyXG5cclxuICAgIGFuaW1pdC5ydW5BbGwoXHJcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxyXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KSdcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMuX3RpbWluZ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcclxuICAgICAgICAgIHRoaXMuX3NpZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnO1xyXG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXHJcbiAgICAgICAgLndhaXQodGhpcy5fZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIG9wYWNpdHk6ICcwJ1xyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucXVldWUoe1xyXG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcclxuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XHJcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xyXG5cclxuLyoqXHJcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlclxyXG4gKiBAY2F0ZWdvcnkgc3BsaXR0ZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICBbZW5dXHJcbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZW5hYmxlcyByZXNwb25zaXZlIGxheW91dCBieSBpbXBsZW1lbnRpbmcgYm90aCBhIHR3by1jb2x1bW4gbGF5b3V0IGFuZCBhIHNsaWRpbmcgbWVudSBsYXlvdXQuXHJcbiAqXHJcbiAqICAgIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgZXhwYW5kIGludG8gYSBjb2x1bW4gbGF5b3V0IG9uIGxhcmdlIHNjcmVlbnMgYW5kIGNvbGxhcHNlIHRoZSBtZW51IG9uIHNtYWxsZXIgc2NyZWVucy4gV2hlbiB0aGUgbWVudSBpcyBjb2xsYXBzZWQgdGhlIHVzZXIgY2FuIG9wZW4gaXQgYnkgc3dpcGluZy5cclxuICogIFsvZW5dXHJcbiAqICBbamFdWy9qYV1cclxuICogQGNvZGVwZW4gck9RT01MXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxyXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cclxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXHJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cclxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBndWlkZSBDYWxsaW5nQ29tcG9uZW50QVBJc2Zyb21KYXZhU2NyaXB0XHJcbiAqICAgW2VuXVVzaW5nIGNvbXBvbmVudHMgZnJvbSBKYXZhU2NyaXB0Wy9lbl1cclxuICogICBbamFdSmF2YVNjcmlwdOOBi+OCieOCs+ODs+ODneODvOODjeODs+ODiOOCkuWRvOOBs+WHuuOBmVsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtc3BsaXR0ZXIgaWQ9XCJzcGxpdHRlclwiPlxyXG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cclxuICogICAgIC4uLlxyXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XHJcbiAqXHJcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZSBzd2lwZWFibGU+XHJcbiAqICAgICAuLi5cclxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxyXG4gKiA8L29ucy1zcGxpdHRlcj5cclxuICpcclxuICogPHNjcmlwdD5cclxuICogICB2YXIgc3BsaXR0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BsaXR0ZXInKTtcclxuICogICBzcGxpdHRlci5sZWZ0Lm9wZW4oKTtcclxuICogPC9zY3JpcHQ+XHJcbiAqL1xyXG5jbGFzcyBTcGxpdHRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIF9nZXRTaWRlKHNpZGUpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCBlID0+IHtcclxuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZSwgJ29ucy1zcGxpdHRlci1zaWRlJykgJiYgZS5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gc2lkZTtcclxuICAgIH0pO1xyXG4gICAgZWxlbWVudCAmJiBDdXN0b21FbGVtZW50cy51cGdyYWRlKGVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgbGVmdFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1MZWZ0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBnZXQgbGVmdCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdsZWZ0Jyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSByaWdodFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SaWdodCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgZ2V0IHJpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ3JpZ2h0Jyk7XHJcbiAgfVxyXG5cclxuICBnZXQgX3NpZGVzKCkge1xyXG4gICAgcmV0dXJuIFt0aGlzLmxlZnQsIHRoaXMucmlnaHRdLmZpbHRlcihlID0+IGUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgY29udGVudFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGdldCBjb250ZW50KCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItY29udGVudCcpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1hc2soKSB7XHJcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1tYXNrJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXHJcbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cclxuICAgKi9cclxuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xyXG4gICAgdGhpcy5fc2lkZXMuc29tZShzID0+IHMuaXNPcGVuID8gcy5jbG9zZSgpIDogZmFsc2UpIHx8IGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XHJcbiAgfVxyXG5cclxuICBfb25Nb2RlQ2hhbmdlKGUpIHtcclxuICAgIGlmIChlLnRhcmdldC5wYXJlbnROb2RlKSB7XHJcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2xheW91dCgpIHtcclxuICAgIHRoaXMuX3NpZGVzLmZvckVhY2goc2lkZSA9PiB7XHJcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZVtzaWRlLl9zaWRlXSA9IHNpZGUubW9kZSA9PT0gJ3NwbGl0JyA/IHNpZGUuX3dpZHRoIDogMDtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fYm91bmRPbk1vZGVDaGFuZ2UgPSB0aGlzLl9vbk1vZGVDaGFuZ2UuYmluZCh0aGlzKTtcclxuXHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICAgIHRoaXMuX2xheW91dCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGlmICghdGhpcy5tYXNrKSB7XHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fYm91bmRPbk1vZGVDaGFuZ2UsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxyXG5cclxuICBfc2hvdygpIHtcclxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xyXG4gIH1cclxuXHJcbiAgX2hpZGUoKSB7XHJcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcclxuICB9XHJcblxyXG4gIF9kZXN0cm95KCkge1xyXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc1NwbGl0dGVyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwbGl0dGVyJywge1xyXG4gIHByb3RvdHlwZTogU3BsaXR0ZXJFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuXHJcbndpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuX2FuaW1hdG9yRGljdCA9IHtcclxuICBkZWZhdWx0OiBTcGxpdHRlckFuaW1hdG9yLFxyXG4gIG92ZXJsYXk6IFNwbGl0dGVyQW5pbWF0b3JcclxufTtcclxuXHJcbndpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uKG5hbWUsIEFuaW1hdG9yKSB7XHJcbiAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBTcGxpdHRlckFuaW1hdG9yLicpO1xyXG4gIH1cclxuICB3aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50Ll9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcclxufTtcclxuXHJcbndpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuU3BsaXR0ZXJBbmltYXRvciA9IFNwbGl0dGVyQW5pbWF0b3I7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBPbnNTcGxpdHRlckVsZW1lbnQ7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xyXG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnb25zL29yaWVudGF0aW9uJztcclxuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb25zLXNwbGl0dGVyL2FuaW1hdG9yJztcclxuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XHJcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuaW1wb3J0IE9uc1NwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XHJcblxyXG5jb25zdCBTUExJVF9NT0RFID0gJ3NwbGl0JztcclxuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XHJcbmNvbnN0IENMT1NFRF9TVEFURSA9ICdjbG9zZWQnO1xyXG5jb25zdCBPUEVOX1NUQVRFID0gJ29wZW4nO1xyXG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XHJcblxyXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNwbGl0dGVyU2lkZUVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIHJlYWR5KHNwbGl0dGVyU2lkZUVsZW1lbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEZyYWdtZW50fSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgbGluayhzcGxpdHRlclNpZGVFbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xyXG4gIH1cclxufTtcclxuXHJcbmNsYXNzIENvbGxhcHNlRGV0ZWN0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCB0YXJnZXQpIHtcclxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICB0YXJnZXQgJiYgdGhpcy5jaGFuZ2VUYXJnZXQodGFyZ2V0KTtcclxuICB9XHJcblxyXG4gIGNoYW5nZVRhcmdldCh0YXJnZXQpIHtcclxuICAgIHRoaXMuZGlzYWJsZSgpO1xyXG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10uaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX21hdGNoKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldCA9PT0gKHZhbHVlLmlzUG9ydHJhaXQgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoZXM7XHJcbiAgfVxyXG5cclxuICBfb25DaGFuZ2UodmFsdWUpIHtcclxuICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZU1vZGUodGhpcy5fbWF0Y2godmFsdWUpID8gQ09MTEFQU0VfTU9ERSA6IFNQTElUX01PREUpO1xyXG4gIH1cclxuXHJcbiAgYWN0aXZhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcclxuICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xyXG4gICAgICB0aGlzLl9vbkNoYW5nZSh7aXNQb3J0cmFpdDogb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IHdpbmRvdy5tYXRjaE1lZGlhKHRoaXMuX3RhcmdldCk7XHJcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LmFkZExpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xyXG4gICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLl9xdWVyeVJlc3VsdCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNhYmxlKCkge1xyXG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XHJcbiAgICAgIG9yaWVudGF0aW9uLm9mZignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3F1ZXJ5UmVzdWx0KSB7XHJcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xyXG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgsIHBhcmVudCkgPT4ge1xyXG4gIGNvbnN0IFt2YWx1ZSwgcHhdID0gW3BhcnNlSW50KHdpZHRoLCAxMCksIC9weC8udGVzdCh3aWR0aCldO1xyXG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChwYXJlbnQub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XHJcbn07XHJcblxyXG5jbGFzcyBDb2xsYXBzZU1vZGUge1xyXG4gIGdldCBfYW5pbWF0b3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5fYW5pbWF0b3I7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XHJcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcclxuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xyXG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB0aGlzLl9sb2NrID0gbmV3IERvb3JMb2NrKCk7XHJcbiAgfVxyXG5cclxuICBpc09wZW4oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVHZXN0dXJlKGUpIHtcclxuICAgIGlmICghdGhpcy5fYWN0aXZlIHx8IHRoaXMuX2xvY2suaXNMb2NrZWQoKSB8fCB0aGlzLl9pc09wZW5PdGhlclNpZGVNZW51KCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGUudHlwZSA9PT0gJ2RyYWdzdGFydCcpIHtcclxuICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZSk7XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XHJcbiAgICAgIGUudHlwZSA9PT0gJ2RyYWdlbmQnID8gdGhpcy5fb25EcmFnRW5kKGUpIDogdGhpcy5fb25EcmFnKGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XHJcbiAgICBjb25zdCBzY3JvbGxpbmcgPSAhL2xlZnR8cmlnaHQvLnRlc3QoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24pO1xyXG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLl9lbGVtZW50Ll9zaWRlID09PSAnbGVmdCcgPyBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYIDogd2luZG93LmlubmVyV2lkdGggLSBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYO1xyXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2VsZW1lbnQuX3N3aXBlVGFyZ2V0V2lkdGg7XHJcbiAgICBjb25zdCBpc09wZW4gPSB0aGlzLmlzT3BlbigpO1xyXG4gICAgdGhpcy5faWdub3JlRHJhZyA9IHNjcm9sbGluZyB8fCAoYXJlYSAmJiBkaXN0YW5jZSA+IGFyZWEgJiYgIWlzT3Blbik7XHJcblxyXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFRvUHgodGhpcy5fZWxlbWVudC5fd2lkdGgsIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSk7XHJcbiAgICB0aGlzLl9zdGFydERpc3RhbmNlID0gdGhpcy5fZGlzdGFuY2UgPSBpc09wZW4gPyB0aGlzLl93aWR0aCA6IDA7XHJcbiAgfVxyXG5cclxuICBfb25EcmFnKGV2ZW50KSB7XHJcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xyXG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLl93aWR0aCwgdGhpcy5fc3RhcnREaXN0YW5jZSArIGRlbHRhKSk7XHJcbiAgICBpZiAoZGlzdGFuY2UgIT09IHRoaXMuX2Rpc3RhbmNlKSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSk7XHJcbiAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25EcmFnRW5kKGV2ZW50KSB7XHJcbiAgICBjb25zdCB7X2Rpc3RhbmNlOiBkaXN0YW5jZSwgX3dpZHRoOiB3aWR0aCwgX2VsZW1lbnQ6IGVsfSA9IHRoaXM7XHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XHJcbiAgICBjb25zdCBzaG91bGRPcGVuID0gZWwuX3NpZGUgIT09IGRpcmVjdGlvbiAmJiBkaXN0YW5jZSA+IHdpZHRoICogZWwuX3RocmVzaG9sZDtcclxuICAgIHRoaXMuZXhlY3V0ZUFjdGlvbihzaG91bGRPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJyk7XHJcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGxheW91dCgpIHtcclxuICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUpIHtcclxuICAgICAgdGhpcy5fYW5pbWF0b3Iub3BlbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZW50ZXIgY29sbGFwc2UgbW9kZVxyXG4gIGVudGVyTW9kZSgpIHtcclxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XHJcbiAgICAgIHRoaXMubGF5b3V0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBleGl0IGNvbGxhcHNlIG1vZGVcclxuICBleGl0TW9kZSgpIHtcclxuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgX2lzT3Blbk90aGVyU2lkZU1lbnUoKSB7XHJcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fZWxlbWVudC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKS5zb21lKGUgPT4ge1xyXG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlICE9PSB0aGlzLl9lbGVtZW50ICYmIGUuaXNPcGVuO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtICdvcGVuJyBvciAnY2xvc2UnXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dEFuaW1hdGlvbl1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlXHJcbiAgICovXHJcbiAgZXhlY3V0ZUFjdGlvbihuYW1lLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IEZJTkFMX1NUQVRFID0gbmFtZSA9PT0gJ29wZW4nID8gT1BFTl9TVEFURSA6IENMT1NFRF9TVEFURTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BsaXR0ZXIgc2lkZSBpcyBsb2NrZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZSA9PT0gJ29wZW4nICYmIHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgbWVudSBpcyBhbHJlYWR5IG9wZW4uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZWxlbWVudC5fZW1pdEV2ZW50KGBwcmUke25hbWV9YCkpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke25hbWV9IGV2ZW50LmApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcclxuICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2xvY2subG9jaygpO1xyXG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcclxuICAgICAgdGhpcy5fc3RhdGUgPSBGSU5BTF9TVEFURTtcclxuICAgICAgdGhpcy5sYXlvdXQoKTtcclxuICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuX2VtaXRFdmVudChgcG9zdCR7bmFtZX1gKTtcclxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKG9wdGlvbnMud2l0aG91dEFuaW1hdGlvbikge1xyXG4gICAgICBkb25lKCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zdGF0ZSA9IENIQU5HSU5HX1NUQVRFO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICB0aGlzLl9hbmltYXRvcltuYW1lXSgoKSA9PiB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIHJlc29sdmUodGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLXNpZGVcclxuICogQGNhdGVnb3J5IHNwbGl0dGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgW2VuXVxyXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cclxuICpcclxuICogICAgSXQgd2lsbCBiZSBkaXNwbGF5ZWQgb24gZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGA8b25zLXNwbGl0dGUtY29udGVudD5gIGVsZW1lbnQuXHJcbiAqXHJcbiAqICAgIEl0IHN1cHBvcnRzIHR3byBtb2RlczogY29sbGFwc2VkIGFuZCBzcGxpdC4gV2hlbiBpdCdzIGluIGNvbGxhcHNlZCBtb2RlIGl0IHdpbGwgYmUgaGlkZGVuIGZyb20gdmlldyBhbmQgY2FuIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIHN3aXBlcyB0aGUgc2NyZWVuIG9yIHRhcHMgYSBidXR0b24uIEluIHNwbGl0IG1vZGUgdGhlIGVsZW1lbnQgaXMgYWx3YXlzIHNob3duLiBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCBiZXR3ZWVuIHRoZSB0d28gbW9kZXMgZGVwZW5kaW5nIG9uIHRoZSBzY3JlZW4gc2l6ZS5cclxuICogIFsvZW5dXHJcbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxyXG4gKiBAY29kZXBlbiByT1FPTUxcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXHJcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50LlsvZW5dXHJcbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXHJcbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLXNwbGl0dGVyPlxyXG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cclxuICogICAgIC4uLlxyXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XHJcbiAqXHJcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cclxuICogICAgIC4uLlxyXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XHJcbiAqIDwvb25zLXNwbGl0dGVyPlxyXG4gKi9cclxuY2xhc3MgU3BsaXR0ZXJTaWRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IG1vZGVjaGFuZ2VcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjb21wb25lbnQncyBtb2RlIGNoYW5nZXMuWy9lbl1cclxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7jg6Ljg7zjg4njgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQubW9kZVxyXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgbW9kZS4gQ2FuIGJlIGVpdGhlciBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVvcGVuXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/liY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXHJcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nIG1lbnUuWy9lbl1cclxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/jga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwb3N0b3BlblxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHByZWNsb3NlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcclxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmctbWVudS5bL2VuXVxyXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwb3N0Y2xvc2VcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXHJcbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXHJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVmYXVsdCAgZGVmYXVsdFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uLiBVc2Ugb25lIG9mIGBcIm92ZXJsYXlcImAsIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXHJcbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm92ZXJsYXlcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXHJcbiAgICogQHR5cGUge0V4cHJlc3Npb259XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cclxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgb3Blbi10aHJlc2hvbGRcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZWZhdWx0ICAwLjNcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIG1lbnUgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBvcGVuaW5nLiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuWy9lbl1cclxuICAgKiAgW2phXeOBqeOBruOBj+OCieOBhOOCueODr+OCpOODl+OBmeOCjOOBsOOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOCkumWi+OBj+OBi+OBqeOBhuOBi+OBruWJsuWQiOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokx44Gu6ZaT44Gu5pWw5YCk44KS5oyH5a6a44GX44G+44GZ44CC44K544Ov44Kk44OX44Gu6Led6Zui44GM44GT44GT44Gn5oyH5a6a44GX44Gf5pWw5YCk5o6b44GR44KL44GT44Gu6KaB57Sg44Gu5bmF44KI44KK44KC5aSn44GN44GR44KM44Gw44CB44K544Ov44Kk44OX44GM57WC44KP44Gj44Gf5pmC44Gr44GT44Gu6KaB57Sg44KS6ZaL44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvMC4z44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBjb2xsYXBzZVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dXHJcbiAgICogICAgIFNwZWNpZnkgdGhlIGNvbGxhcHNlIGJlaGF2aW9yLiBWYWxpZCB2YWx1ZXMgYXJlIGBcInBvcnRyYWl0XCJgLCBgXCJsYW5kc2NhcGVcImAgb3IgYSBtZWRpYSBxdWVyeS5cclxuICAgKiAgICAgVGhlIHN0cmluZ3MgYFwicG9ydHJhaXRcImAgYW5kIGBcImxhbmRzY2FwZVwiYCBtZWFucyB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gZGV2aWNlIGlzIGluIGxhbmRzY2FwZSBvciBwb3J0cmFpdCBvcmllbnRhdGlvbi5cclxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIGEgbWVkaWEgcXVlcnksIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiB0aGUgbWVkaWEgcXVlcnkgcmVzb2x2ZXMgdG8gYHRydWVgLlxyXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgbm90IGRlZmluZWQsIHRoZSB2aWV3IGFsd2F5cyBiZSBpbiBgXCJjb2xsYXBzZVwiYCBtb2RlLlxyXG4gICAqICAgWy9lbl1cclxuICAgKiAgIFtqYV1cclxuICAgKiAgICAg5bem5YG044Gu44Oa44O844K444KS6Z2e6KGo56S644Gr44GZ44KL5p2h5Lu244KS5oyH5a6a44GX44G+44GZ44CCcG9ydHJhaXQsIGxhbmRzY2FwZeOAgXdpZHRoICNweOOCguOBl+OBj+OBr+ODoeODh+OCo+OCouOCr+OCqOODquOBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAglxyXG4gICAqICAgICBwb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBmeOCi+OBqOOAgeODh+ODkOOCpOOCueOBrueUu+mdouOBjOe4puWQkeOBjeOCguOBl+OBj+OBr+aoquWQkeOBjeOBq+OBquOBo+OBn+aZguOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxyXG4gICAqICAgICDjg6Hjg4fjgqPjgqLjgq/jgqjjg6rjgpLmjIflrprjgZnjgovjgajjgIHmjIflrprjgZfjgZ/jgq/jgqjjg6rjgavpganlkIjjgZfjgabjgYTjgovloLTlkIjjgavpgannlKjjgZXjgozjgb7jgZnjgIJcclxuICAgKiAgICAg5YCk44Gr5L2V44KC5oyH5a6a44GX44Gq44GE5aC05ZCI44Gr44Gv44CB5bi444GrY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgorjgb7jgZnjgIJcclxuICAgKiAgIFsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGUtdGFyZ2V0LXdpZHRoXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXHJcbiAgICogICBbamFd44K544Ov44Kk44OX44Gu5Yik5a6a6aCY5Z+f44KS44OU44Kv44K744Or5Y2Y5L2N44Gn5oyH5a6a44GX44G+44GZ44CC55S76Z2i44Gu56uv44GL44KJ5oyH5a6a44GX44Gf6Led6Zui44Gr6YGU44GZ44KL44Go44Oa44O844K444GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSB3aWR0aFxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ2FuIGJlIHNwZWNpZmllZCBpbiBlaXRoZXIgcGl4ZWxzIG9yIGFzIGEgcGVyY2VudGFnZSwgZS5nLiBgOTAlYCBvciBgMjAwcHhgLlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu5qiq5bmF44KS5oyH5a6a44GX44G+44GZ44CCcHjjgagl44Gn44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCZWcuIDkwJSwgMjAwcHhbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHNpZGVcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZWZhdWx0IGxlZnRcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoaWNoIHNpZGUgb2YgdGhlIHNjcmVlbiB0aGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgbG9jYXRlZC4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5bL2VuXVxyXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBjOW3puOBi+WPs+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+WApOOBr1wibGVmdFwi44GLXCJyaWdodFwi44Gu44G/44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBtb2RlXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1DdXJyZW50IG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuIFRoaXMgYXR0cmlidXRlIGlzIHJlYWQgb25seS5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOBjOioreWumuOBleOCjOOBvuOBmeOAglwiY29sbGFwc2VcIuOCguOBl+OBj+OBr1wic3BsaXRcIuOBjOaMh+WumuOBleOCjOOBvuOBmeOAguOBk+OBruWxnuaAp+OBr+iqreOBv+i+vOOBv+WwgueUqOOBp+OBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxyXG4gICAqIEBpbml0b25seVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIFVSTCBvZiB0aGUgbWVudSBwYWdlLlsvZW5dXHJcbiAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdG8gZW5hYmxlIHN3aXBlIGludGVyYWN0aW9uIG9uIGNvbGxhcHNlIG1vZGUuWy9lbl1cclxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieaZguOBq+OCueODr+OCpOODl+aTjeS9nOOCkuacieWKueOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuX2NvbGxhcHNlTW9kZSA9IG5ldyBDb2xsYXBzZU1vZGUodGhpcyk7XHJcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcclxuICAgICAgYW5pbWF0b3JzOiBPbnNTcGxpdHRlckVsZW1lbnQuX2FuaW1hdG9yRGljdCxcclxuICAgICAgYmFzZUNsYXNzOiBTcGxpdHRlckFuaW1hdG9yLFxyXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnU3BsaXR0ZXJBbmltYXRvcicsXHJcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9ib3VuZEhhbmRsZUdlc3R1cmUgPSAoZSkgPT4gdGhpcy5fY29sbGFwc2VNb2RlLmhhbmRsZUdlc3R1cmUoZSk7XHJcbiAgICB0aGlzLl93YXRjaGVkQXR0cmlidXRlcyA9IFsnYW5pbWF0aW9uJywgJ3dpZHRoJywgJ3NpZGUnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ3N3aXBlLXRhcmdldC13aWR0aCcsICdhbmltYXRpb24tb3B0aW9ucycsICdvcGVuLXRocmVzaG9sZCcsICdwYWdlJ107XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG11c3QgYmUgYW4gb25zLXNwbGl0dGVyIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLnBhcmVudEVsZW1lbnQsIHtkcmFnTWluRGlzdGFuY2U6IDF9KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdzaWRlJykpIHtcclxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NpZGUnLCAnbGVmdCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzLmZvckVhY2goZSA9PiB0aGlzLl91cGRhdGUoZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xyXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgaWYgKHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZShuYW1lLCBjdXJyZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGUobmFtZSwgdmFsdWUpIHtcclxuICAgIG5hbWUgPSAnX3VwZGF0ZScgKyBuYW1lLnNwbGl0KCctJykubWFwKGUgPT4gZVswXS50b1VwcGVyQ2FzZSgpICsgZS5zbGljZSgxKSkuam9pbignJyk7XHJcbiAgICByZXR1cm4gdGhpc1tuYW1lXSh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBfZW1pdEV2ZW50KG5hbWUpIHtcclxuICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpICE9PSAncHJlJykge1xyXG4gICAgICByZXR1cm4gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIG5hbWUsIHtzaWRlOiB0aGlzfSk7XHJcbiAgICB9XHJcbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xyXG5cclxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XHJcbiAgICAgIHNpZGU6IHRoaXMsXHJcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpc0NhbmNlbGVkO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUNvbGxhcHNlKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxhcHNlJykpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJ3NwbGl0Jykge1xyXG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKFNQTElUX01PREUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ2NvbGxhcHNlJykge1xyXG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKENPTExBUFNFX01PREUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmNoYW5nZVRhcmdldCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZWFkb25seSBhdHRyaWJ1dGUgZm9yIHRoZSB1c2Vyc1xyXG4gIF91cGRhdGVNb2RlKG1vZGUpIHtcclxuICAgIGlmIChtb2RlICE9PSB0aGlzLl9tb2RlKSB7XHJcbiAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xyXG4gICAgICB0aGlzLl9jb2xsYXBzZU1vZGVbbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSA/ICdlbnRlck1vZGUnIDogJ2V4aXRNb2RlJ10oKTtcclxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGUnLCBtb2RlKTtcclxuXHJcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnbW9kZWNoYW5nZScsIHtzaWRlOiB0aGlzLCBtb2RlOiBtb2RlfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlUGFnZShwYWdlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSkge1xyXG4gICAgaWYgKHBhZ2UgIT09IG51bGwpIHtcclxuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4gdGhpcy5sb2FkKHBhZ2UpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVPcGVuVGhyZXNob2xkKHRocmVzaG9sZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB7XHJcbiAgICB0aGlzLl90aHJlc2hvbGQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMC4zKSk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlU3dpcGVhYmxlKHN3aXBlYWJsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZWFibGUnKSkge1xyXG4gICAgY29uc3QgYWN0aW9uID0gc3dpcGVhYmxlID09PSBudWxsID8gJ29mZicgOiAnb24nO1xyXG5cclxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcclxuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdzdGFydCBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ2VuZCcsIHRoaXMuX2JvdW5kSGFuZGxlR2VzdHVyZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlU3dpcGVUYXJnZXRXaWR0aCh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSkge1xyXG4gICAgdGhpcy5fc3dpcGVUYXJnZXRXaWR0aCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KHZhbHVlKSB8fCAwKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVXaWR0aCgpIHtcclxuICAgIHRoaXMuc3R5bGUud2lkdGggPSB0aGlzLl93aWR0aDtcclxuICB9XHJcblxyXG4gIGdldCBfd2lkdGgoKSB7XHJcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xyXG4gICAgcmV0dXJuIC9eXFxkKyhweHwlKSQvLnRlc3Qod2lkdGgpID8gd2lkdGggOiAnODAlJztcclxuICB9XHJcblxyXG4gIHNldCBfd2lkdGgodmFsdWUpIHtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVTaWRlKHNpZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc2lkZScpKSB7XHJcbiAgICB0aGlzLl9zaWRlID0gc2lkZSA9PT0gJ3JpZ2h0JyA/IHNpZGUgOiAnbGVmdCc7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlQW5pbWF0aW9uKGFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xyXG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Ioe2FuaW1hdGlvbn0pO1xyXG4gICAgdGhpcy5fYW5pbWF0b3IuYWN0aXZhdGUodGhpcyk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlQW5pbWF0aW9uT3B0aW9ucyh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSB7XHJcbiAgICB0aGlzLl9hbmltYXRvci51cGRhdGVPcHRpb25zKEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodmFsdWUpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBwYWdlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIHNpZGUuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGdldCBwYWdlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgbW9kZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGdldCBtb2RlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgaXNPcGVuXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLi5bL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgZ2V0IGlzT3BlbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU1vZGUuaXNPcGVuKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIG9wZW5cclxuICAgKiBAc2lnbmF0dXJlIG9wZW4oW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIG9wZW5lZC5bL2VuXVxyXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dT3BlbiBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cclxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgb3BlbihvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU1vZGUuZXhlY3V0ZUFjdGlvbignb3BlbicsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBjbG9zZVxyXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIGNsb3NlZC5bL2VuXVxyXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dQ2xvc2UgbWVudSBpbiBjb2xsYXBzZSBtb2RlLlsvZW5dXHJcbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGNsb3NlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5leGVjdXRlQWN0aW9uKCdjbG9zZScsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCB0b2dnbGVcclxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXU9wZW5zIGlmIGl0J3MgY2xvc2VkLiBDbG9zZXMgaWYgaXQncyBvcGVuLlsvZW5dXHJcbiAgICogICBbamFd6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaJ44GY44G+44GZ44Gd44GX44Gm6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxyXG4gICAqICAgW2phXVsvamFdXHJcbiAgICovXHJcbiAgdG9nZ2xlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuID8gdGhpcy5jbG9zZShvcHRpb25zKSA6IHRoaXMub3BlbihvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtZXRob2QgbG9hZFxyXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcclxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXHJcbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXHJcbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcclxuXHJcbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgdXRpbC5jcmVhdGVGcmFnbWVudChodG1sKSwgb3B0aW9ucywgZnJhZ21lbnQgPT4ge1xyXG4gICAgICAgIHRoaXMuX2hpZGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2hvdygpO1xyXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmVzb2x2ZSh0aGlzLmZpcnN0Q2hpbGQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIF9zaG93KCkge1xyXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XHJcbiAgfVxyXG5cclxuICBfaGlkZSgpIHtcclxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xyXG4gIH1cclxuXHJcbiAgX2Rlc3Ryb3koKSB7XHJcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zU3BsaXR0ZXJTaWRlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwbGl0dGVyLXNpZGUnLCB7XHJcbiAgcHJvdG90eXBlOiBTcGxpdHRlclNpZGVFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuXHJcbndpbmRvdy5PbnNTcGxpdHRlclNpZGVFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xyXG5cclxuY29uc3Qgc2NoZW1lID0ge1xyXG4gICcnOiAnc3dpdGNoLS0qJyxcclxuICAnLnN3aXRjaF9faW5wdXQnOiAnc3dpdGNoLS0qX19pbnB1dCcsXHJcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXHJcbiAgJy5zd2l0Y2hfX3RvZ2dsZSc6ICdzd2l0Y2gtLSpfX3RvZ2dsZSdcclxufTtcclxuXHJcbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVGcmFnbWVudChgXHJcbiAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwic3dpdGNoX19pbnB1dFwiPlxyXG4gIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX3RvZ2dsZVwiPlxyXG4gICAgPGRpdiBjbGFzcz1cInN3aXRjaF9faGFuZGxlXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX3RvdWNoXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuYCk7XHJcblxyXG5jb25zdCBsb2NhdGlvbnMgPSB7XHJcbiAgaW9zOiBbMSwgMjFdLFxyXG4gIG1hdGVyaWFsOiBbMCwgMTZdXHJcbn07XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXN3aXRjaFxyXG4gKiBAY2F0ZWdvcnkgc3dpdGNoXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1cclxuICogICAgIFN3aXRjaCBjb21wb25lbnQuIFRoZSBzd2l0Y2ggY2FuIGJlIHRvZ2dsZWQgYm90aCBieSBkcmFnZ2luZyBhbmQgdGFwcGluZy5cclxuICpcclxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzd2l0Y2ggb24gQW5kcm9pZCBkZXZpY2VzLlxyXG4gKiAgIFsvZW5dXHJcbiAqICAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXHJcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxyXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3dpdGNoWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGNvZGVwZW4gTHBYWlFRXHJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zd2l0Y2hcclxuICogQGd1aWRlIFVzaW5nRm9ybUNvbXBvbmVudHNcclxuICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cclxuICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cclxuICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcclxuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cclxuICogICBbamFd44Kk44OZ44Oz44OI5Yem55CG44Gu5L2/44GE5pa5Wy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1zd2l0Y2ggY2hlY2tlZD48L29ucy1zd2l0Y2g+XHJcbiAqIDxvbnMtc3dpdGNoIGRpc2FibGVkPjwvb25zLXN3aXRjaD5cclxuICogPG9ucy1zd2l0Y2ggbW9kaWZpZXI9XCJtYXRlcmlhbFwiPjwvb25zLXN3aXRjaD5cclxuICovXHJcblxyXG5jbGFzcyBTd2l0Y2hFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAZXZlbnQgY2hhbmdlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3dpdGNoIGlzIHRvZ2dsZWQuWy9lbl1cclxuICAgKiAgIFtqYV1PTi9PRkbjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxyXG4gICAqICAgW2VuXVN3aXRjaCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9Td2l0Y2jjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcclxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcclxuICAgKiAgIFtlbl1UcnVlIGlmIHRoZSBjaGFuZ2Ugd2FzIHRyaWdnZXJlZCBieSB0aGUgdXNlciBjbGlja2luZyBvbiB0aGUgc3dpdGNoLlsvZW5dXHJcbiAgICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44Gq44Gp44Gu44Om44O844K244Gu5pON5L2c44Gr44KI44Gj44Gm5aSJ44KP44Gj44Gf5aC05ZCI44Gr44GvdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHN3aXRjaC5bL2VuXVxyXG4gICAqICBbamFd44K544Kk44OD44OB44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBiZSBkaXNhYmxlZC5bL2VuXVxyXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOCkueEoeWKueOBrueKtuaFi+OBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgY2hlY2tlZFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXHJcbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7nirbmhYvjgavjgZnjgovjgajjgY3jgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGBpZGAgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cclxuICAgKiAgW2phXVsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgaWYgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXHJcbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICBnZXQgY2hlY2tlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jaGVja2JveC5jaGVja2VkO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNoZWNrZWQodmFsdWUpIHtcclxuICAgIGlmICghIXZhbHVlICE9PSB0aGlzLl9jaGVja2JveC5jaGVja2VkKSB7XHJcbiAgICAgIHRoaXMuX2NoZWNrYm94LmNsaWNrKCk7XHJcbiAgICAgIHRoaXMuX2NoZWNrYm94LmNoZWNrZWQgPSAhIXZhbHVlO1xyXG4gICAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NoZWNrZWQnLCB0aGlzLmNoZWNrZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cclxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBkaXNhYmxlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jaGVja2JveC5kaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xyXG4gICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSB2YWx1ZTtcclxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB0aGlzLmRpc2FibGVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBjaGVja2JveFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgdW5kZXJseWluZyBjaGVja2JveCBlbGVtZW50LlsvZW5dXHJcbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI5YaF6YOo44GuY2hlY2tib3jopoHntKDjgavjgarjgorjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldCBjaGVja2JveCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jaGVja2JveDtcclxuICB9XHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jaGVja2JveCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnN3aXRjaF9faW5wdXQnKTtcclxuICAgIHRoaXMuX2hhbmRsZSA9IHRoaXMucXVlcnlTZWxlY3RvcignLnN3aXRjaF9faGFuZGxlJyk7XHJcblxyXG4gICAgWydjaGVja2VkJywgJ2Rpc2FibGVkJywgJ21vZGlmaWVyJywgJ25hbWUnLCAnaW5wdXQtaWQnXS5mb3JFYWNoKGUgPT4ge1xyXG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShlKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9jb21waWxlKCkge1xyXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XHJcblxyXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gnKTtcclxuXHJcbiAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSk7XHJcblxyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xyXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl9jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XHJcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtkcmFnTWluRGlzdGFuY2U6IDEsIGhvbGRUaW1lb3V0OiAyNTF9KTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XHJcbiAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xyXG4gIH1cclxuXHJcbiAgX29uQ2hhbmdlKCkge1xyXG4gICAgaWYgKHRoaXMuY2hlY2tlZCkge1xyXG4gICAgICB0aGlzLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uQ2xpY2soZXYpIHtcclxuICAgIGlmIChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzd2l0Y2hfX3RvdWNoJykpIHtcclxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsaWNrKCkge1xyXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZ2V0UG9zaXRpb24oZSkge1xyXG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcclxuICAgIHJldHVybiBNYXRoLm1pbihsWzFdLCBNYXRoLm1heChsWzBdLCB0aGlzLl9zdGFydFggKyBlLmdlc3R1cmUuZGVsdGFYKSk7XHJcbiAgfVxyXG5cclxuICBfb25Ib2xkKGUpIHtcclxuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3N3aXRjaC0tYWN0aXZlJyk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25EcmFnU3RhcnQoZSkge1xyXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdzd2l0Y2gtLWFjdGl2ZScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3N3aXRjaC0tYWN0aXZlJyk7XHJcbiAgICB0aGlzLl9zdGFydFggPSB0aGlzLl9sb2NhdGlvbnNbdGhpcy5jaGVja2VkID8gMSA6IDBdOy8vIC0gZS5nZXN0dXJlLmRlbHRhWDtcclxuXHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcclxuICB9XHJcblxyXG4gIF9vbkRyYWcoZSkge1xyXG4gICAgZS5nZXN0dXJlLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9IHRoaXMuX2dldFBvc2l0aW9uKGUpICsgJ3B4JztcclxuICB9XHJcblxyXG4gIF9vblJlbGVhc2UoZSkge1xyXG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oZSk7XHJcblxyXG4gICAgdGhpcy5jaGVja2VkID0gcG9zaXRpb24gPj0gKGxbMF0gKyBsWzFdKSAvIDI7XHJcblxyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSAnJztcclxuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc3dpdGNoLS1hY3RpdmUnKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBzd2l0Y2gobmFtZSkge1xyXG4gICAgICBjYXNlICdtb2RpZmllcic6XHJcbiAgICAgICAgdGhpcy5faXNNYXRlcmlhbCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnNbdGhpcy5faXNNYXRlcmlhbCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XHJcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2lucHV0LWlkJzpcclxuICAgICAgICB0aGlzLl9jaGVja2JveC5pZCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxyXG4gICAgICAgIHRoaXMuX2NoZWNrYm94LmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xyXG4gICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZGlzYWJsZWQnOlxyXG4gICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNTd2l0Y2hFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3dpdGNoJywge1xyXG4gIHByb3RvdHlwZTogU3dpdGNoRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5leHBvcnQgY2xhc3MgVGFiYmFyQW5pbWF0b3Ige1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XHJcbiAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6ICcwLjQnO1xyXG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVudGVyUGFnZSBvbnMtcGFnZSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBsZWF2ZVBhZ2Ugb25zLXBhZ2UgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbnRlclBhZ2VJbmRleFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZVBhZ2VJbmRleFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcclxuICAgKi9cclxuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQuJyk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFRhYmJhck5vbmVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcclxuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJJbmRleCwgbGVhdmVJbmRleCwgZG9uZSkge1xyXG4gICAgc2V0VGltZW91dChkb25lLCAxMDAwIC8gNjApO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRhYmJhckZhZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnbGluZWFyJztcclxuICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogJzAuNCc7XHJcbiAgICBvcHRpb25zLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6ICcwJztcclxuXHJcbiAgICBzdXBlcihvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlclBhZ2VJbmRleCwgbGVhdmVQYWdlSW5kZXgsIGRvbmUpIHtcclxuICAgIGFuaW1pdC5ydW5BbGwoXHJcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXHJcbiAgICAgICAgLnNhdmVTdHlsZSgpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUYWJiYXJTbGlkZUFuaW1hdG9yIGV4dGVuZHMgVGFiYmFyQW5pbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zLnRpbWluZyA9IG9wdGlvbnMudGltaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbWluZyA6ICdlYXNlLWluJztcclxuICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogJzAuMTUnO1xyXG4gICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XHJcblxyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2pxTGl0ZX0gZW50ZXJQYWdlXHJcbiAgICogQHBhcmFtIHtqcUxpdGV9IGxlYXZlUGFnZVxyXG4gICAqL1xyXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XHJcbiAgICBjb25zdCBzZ24gPSBlbnRlckluZGV4ID4gbGVhdmVJbmRleDtcclxuXHJcbiAgICBhbmltaXQucnVuQWxsKFxyXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxyXG4gICAgICAgIC5zYXZlU3R5bGUoKVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgnICsgKHNnbiA/ICcnIDogJy0nKSArICcxMDAlLCAwLCAwKScsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxyXG4gICAgICAgIC5xdWV1ZSh7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVzdG9yZVN0eWxlKClcclxuICAgICAgICAucXVldWUoZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcclxuICAgICAgICB9KVxyXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXHJcbiAgICAgICAgLnF1ZXVlKHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAoc2duID8gJy0nIDogJycpICsgJzEwMCUsIDAsIDApJyxcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XHJcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xyXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IHtUYWJiYXJBbmltYXRvciwgVGFiYmFyRmFkZUFuaW1hdG9yLCBUYWJiYXJOb25lQW5pbWF0b3IsIFRhYmJhclNsaWRlQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnLnRhYi1iYXJfX2NvbnRlbnQnOiAndGFiLWJhci0tKl9fY29udGVudCcsXHJcbiAgJy50YWItYmFyJzogJ3RhYi1iYXItLSonXHJcbn07XHJcblxyXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xyXG4gICdkZWZhdWx0JzogVGFiYmFyTm9uZUFuaW1hdG9yLFxyXG4gICdmYWRlJzogVGFiYmFyRmFkZUFuaW1hdG9yLFxyXG4gICdzbGlkZSc6IFRhYmJhclNsaWRlQW5pbWF0b3IsXHJcbiAgJ25vbmUnOiBUYWJiYXJOb25lQW5pbWF0b3JcclxufTtcclxuXHJcbmNvbnN0IHJld3JpdGFibGVzID0ge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgcmVhZHkodGFiYmFyRWxlbWVudCwgY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWJiYXJFbGVtZW50XHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgbGluayh0YWJiYXJFbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICB1bmxpbmsodGFiYmFyRWxlbWVudCwgdGFyZ2V0LCBjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZW5lcmF0ZUlkID0gKCgpID0+IHtcclxuICB2YXIgaSA9IDA7XHJcbiAgcmV0dXJuICgpID0+ICdvbnMtdGFiYmFyLWdlbi0nICsgKGkrKyk7XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXRhYmJhclxyXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIFtlbl1BIGNvbXBvbmVudCB0byBkaXNwbGF5IGEgdGFiIGJhciBvbiB0aGUgYm90dG9tIG9mIGEgcGFnZS4gVXNlZCB3aXRoIGA8b25zLXRhYj5gIHRvIG1hbmFnZSBwYWdlcyB1c2luZyB0YWJzLlsvZW5dXHJcbiAqICAgW2phXeOCv+ODluODkOODvOOCkuODmuODvOOCuOS4i+mDqOOBq+ihqOekuuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgm9ucy10YWLjgajntYTjgb/lkIjjgo/jgZvjgabkvb/jgYbjgZPjgajjgafjgIHjg5rjg7zjgrjjgpLnrqHnkIbjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gKiBAY29kZXBlbiBwR3VETFxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXHJcbiAqIEBndWlkZSBVc2luZ1RhYkJhclxyXG4gKiAgIFtlbl1Vc2luZyB0YWIgYmFyWy9lbl1cclxuICogICBbamFd44K/44OW44OQ44O844KS5L2/44GGWy9qYV1cclxuICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcclxuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cclxuICogICBbamFd44Kk44OZ44Oz44OI5Yem55CG44Gu5L2/44GE5pa5Wy9qYV1cclxuICogQGd1aWRlIENhbGxpbmdDb21wb25lbnRBUElzZnJvbUphdmFTY3JpcHRcclxuICogICBbZW5dVXNpbmcgbmF2aWdhdG9yIGZyb20gSmF2YVNjcmlwdFsvZW5dXHJcbiAqICAgW2phXUphdmFTY3JpcHTjgYvjgonjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLlkbzjgbPlh7rjgZlbL2phXVxyXG4gKiBAZ3VpZGUgRGVmaW5pbmdNdWx0aXBsZVBhZ2VzaW5TaW5nbGVIVE1MXHJcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cclxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtdGFiXHJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWI+YCBjb21wb25lbnQuWy9lbl1cclxuICogICBbamFdb25zLXRhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1wYWdlXHJcbiAqICAgW2VuXVRoZSBgPG9ucy1wYWdlPmAgY29tcG9uZW50LlsvZW5dXHJcbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy10YWJiYXI+XHJcbiAqICAgPG9ucy10YWJcclxuICogICAgIHBhZ2U9XCJob21lLmh0bWxcIlxyXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcclxuICogICAgIGFjdGl2ZT5cclxuICogICA8L29ucy10YWI+XHJcbiAqICAgPG9ucy10YWJcclxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcclxuICogICAgIGxhYmVsPVwiU2V0dGluZ3NcIlxyXG4gKiAgICAgYWN0aXZlPlxyXG4gKiAgIDwvb25zLXRhYj5cclxuICogPC9vbnMtdGFiYmFyPlxyXG4gKlxyXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XHJcbiAqICAgLi4uXHJcbiAqIDwvb25zLXRlbXBsYXRlPlxyXG4gKlxyXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwic2V0dGluZ3MuaHRtbFwiPlxyXG4gKiAgIC4uLlxyXG4gKiA8L29ucy10ZW1wbGF0ZT5cclxuICovXHJcbmNsYXNzIFRhYmJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBldmVudCBwcmVjaGFuZ2VcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGJlZm9yZSB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cclxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XHJcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXHJcbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXHJcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgY2hhbmdlIGV2ZW50LlsvZW5dXHJcbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Ki44Kv44OG44Kj44OW44Gq44K/44OW44Gu5aSJ5pu044GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGFmdGVyIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxyXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OBo+OBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XHJcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXHJcbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcclxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cclxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGV2ZW50IHJlYWN0aXZlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRmlyZXMgaWYgdGhlIGFscmVhZHkgb3BlbiB0YWIgaXMgdGFwcGVkIGFnYWluLlsvZW5dXHJcbiAgICogICBbamFd44GZ44Gn44Gr44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44GM44KC44GG5LiA5bqm44K/44OD44OX44KE44Kv44Oq44OD44Kv44GV44KM44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxyXG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cclxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxyXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxyXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlZmF1bHQgbm9uZVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgdmFsdWVzIGFyZSBgXCJub25lXCJgLCBgXCJzbGlkZVwiYCBhbmQgYFwiZmFkZVwiYC4gRGVmYXVsdCBpcyBgXCJub25lXCJgLlsvZW5dXHJcbiAgICogICBbamFd44Oa44O844K46Kqt44G/6L6844G/5pmC44Gu44Ki44OL44Oh44O844K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgIFcImZhZGVcIuOAgVwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkumBuOaKnuOBp+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wibm9uZVwi44Gn44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xyXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXHJcbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXHJcbiAgICogQGluaXRvbmx5XHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVmYXVsdCBib3R0b21cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UYWJiYXIncyBwb3NpdGlvbi4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwiYm90dG9tXCJgIGFuZCBgXCJ0b3BcImAuIFVzZSBgXCJhdXRvXCJgIHRvIGNob29zZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKGlPUyBib3R0b20sIEFuZHJvaWQgdG9wKS5bL2VuXVxyXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglwiYm90dG9tXCLjgoLjgZfjgY/jga9cInRvcFwi44KS6YG45oqe44Gn44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJib3R0b21cIuOBp+OBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMuX3RhYmJhcklkID0gZ2VuZXJhdGVJZCgpO1xyXG5cclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlyc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZC5jaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnKTtcclxuXHJcbiAgICAgIGlmIChhY3RpdmVJbmRleCAmJiB0aGlzLmNoaWxkcmVuWzFdLmNoaWxkcmVuLmxlbmd0aCA+IGFjdGl2ZUluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlblsxXS5jaGlsZHJlblthY3RpdmVJbmRleF0uc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcclxuICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG5cclxuICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XHJcbiAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxyXG4gICAgICAgIGJhc2VDbGFzczogVGFiYmFyQW5pbWF0b3IsXHJcbiAgICAgICAgYmFzZUNsYXNzTmFtZTogJ1RhYmJhckFuaW1hdG9yJyxcclxuICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fY29udGVudCcpO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICB2YXIgY29udGVudCA9IHV0aWwuY3JlYXRlKCcub25zLXRhYi1iYXJfX2NvbnRlbnQudGFiLWJhcl9fY29udGVudCcpO1xyXG4gICAgdmFyIHRhYmJhciA9IHV0aWwuY3JlYXRlKCcudGFiLWJhci5vbnMtdGFiLWJhcl9fZm9vdGVyLm9ucy10YWJiYXItaW5uZXInKTtcclxuXHJcbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XHJcbiAgICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcbiAgICB0aGlzLmFwcGVuZENoaWxkKHRhYmJhcik7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykpIHtcclxuICAgIHZhciB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgcGxhdGZvcm0uaXNBbmRyb2lkKCkpO1xyXG4gICAgdmFyIGFjdGlvbiA9IHRvcCA/IHV0aWwuYWRkTW9kaWZpZXIgOiB1dGlsLnJlbW92ZU1vZGlmaWVyO1xyXG5cclxuICAgIGFjdGlvbih0aGlzLCAndG9wJyk7XHJcblxyXG4gICAgdmFyIHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XHJcbiAgICBpZiAocGFnZSkge1xyXG4gICAgICB0aGlzLnN0eWxlLnRvcCA9IHRvcCA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIG51bGwpLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctdG9wJykgOiAnJztcclxuXHJcbiAgICAgIGlmICh1dGlsLm1hdGNoKHBhZ2UuZmlyc3RDaGlsZCwgJ29ucy10b29sYmFyJykpIHtcclxuICAgICAgICBhY3Rpb24ocGFnZS5maXJzdENoaWxkLCAnbm9zaGFkb3cnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcclxuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcclxuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsIHRvcCAmJiAhZmlsbGVkKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2dldFRhYmJhckVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbWV0aG9kIGxvYWRQYWdlXHJcbiAgICogQHNpZ25hdHVyZSBsb2FkUGFnZSh1cmwsIFtvcHRpb25zXSlcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXHJcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiBgPG9ucy10ZW1wbGF0ZT5gIGlkLlsvZW5dXHJcbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn2lk5bGe5oCn44Gu5YCk44KS5Yip55So44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1EaXNwbGF5cyBhIG5ldyBwYWdlIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGFjdGl2ZSBpbmRleC5bL2VuXVxyXG4gICAqICAgW2phXeePvuWcqOOBruOCouOCr+ODhuOCo+ODluOBquOCpOODs+ODh+ODg+OCr+OCueOCkuWkieabtOOBm+OBmuOBq+OAgeaWsOOBl+OBhOODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqICAgW2VuXVsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXHJcbiAgICogICBbZW5dWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIGxvYWRQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBPbnNUYWJFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlUGFnZUVsZW1lbnQocGFnZSwgcGFnZUVsZW1lbnQgPT4ge1xyXG4gICAgICAgIHJlc29sdmUodGhpcy5fbG9hZFBhZ2VET01Bc3luYyhwYWdlRWxlbWVudCwgb3B0aW9ucykpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYWdlRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5cclxuICAgKi9cclxuICBfbG9hZFBhZ2VET01Bc3luYyhwYWdlRWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgcGFnZUVsZW1lbnQsIG9wdGlvbnMsIHBhZ2VFbGVtZW50ID0+IHtcclxuICAgICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChwYWdlRWxlbWVudCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCkgIT09IC0xKSB7XHJcbiAgICAgICAgICByZXNvbHZlKHRoaXMuX3N3aXRjaFBhZ2UocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLl9vbGRQYWdlRWxlbWVudCA9IHBhZ2VFbGVtZW50O1xyXG4gICAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldFRhYmJhcklkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RhYmJhcklkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7RWxlbWVudC9udWxsfVxyXG4gICAqL1xyXG4gIF9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKSB7XHJcbiAgICB2YXIgcGFnZXMgPSB0aGlzLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbjtcclxuICAgIHZhciBwYWdlID0gbnVsbDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHBhZ2VzW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xyXG4gICAgICAgIHBhZ2UgPSBwYWdlc1tpXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYWdlICYmIHBhZ2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IHBhZ2UgZWxlbWVudCBtdXN0IGJlIGEgXCJvbnMtcGFnZVwiIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhZ2U7XHJcbiAgfVxyXG5cclxuICBnZXQgcGFnZXMoKSB7XHJcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbGVjdGVkVGFiSW5kZXhcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcmV2aW91c1RhYkluZGV4XHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuXHJcbiAgICovXHJcbiAgX3N3aXRjaFBhZ2UoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgdmFyIG9sZFBhZ2VFbGVtZW50ID0gdGhpcy5fb2xkUGFnZUVsZW1lbnQgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XHJcbiAgICB0aGlzLl9vbGRQYWdlRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB2YXIgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBpZiAob2xkUGFnZUVsZW1lbnQgIT09IGludGVybmFsLm51bGxFbGVtZW50KSB7XHJcbiAgICAgICAgb2xkUGFnZUVsZW1lbnQuX2hpZGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYW5pbWF0b3IuYXBwbHkoZWxlbWVudCwgb2xkUGFnZUVsZW1lbnQsIG9wdGlvbnMuc2VsZWN0ZWRUYWJJbmRleCwgb3B0aW9ucy5wcmV2aW91c1RhYkluZGV4LCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xyXG4gICAgICAgICAgb2xkUGFnZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgZWxlbWVudC5fc2hvdygpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXNvbHZlKGVsZW1lbnQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVUYWJcclxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZVRhYihpbmRleCwgW29wdGlvbnNdKVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAqICAgW2VuXVRhYiBpbmRleC5bL2VuXVxyXG4gICAqICAgW2phXeOCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cclxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMua2VlcFBhZ2VdXHJcbiAgICogICBbZW5dSWYgdHJ1ZSB0aGUgcGFnZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLlsvZW5dXHJcbiAgICogICBbamFd44K/44OW44OQ44O844GM54++5Zyo6KGo56S644GX44Gm44GE44KLcGFnZeOCkuWkieOBiOOBquOBhOWgtOWQiOOBq+OBr3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXHJcbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgLCBgXCJzbGlkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgmBcImZhZGVcImDjgIFgXCJzbGlkZVwiYOOAgWBcIm5vbmVcImDjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxyXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxyXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1TaG93IHNwZWNpZmllZCB0YWIgcGFnZS4gQW5pbWF0aW9ucyBhbmQgb3RoZXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXHJcbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gu44K/44OW44KS6KGo56S644GX44G+44GZ44CC44Ki44OL44Oh44O844K344On44Oz44Gq44Gp44Gu44Kq44OX44K344On44Oz44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBzZXRBY3RpdmVUYWIoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxyXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXHJcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5hbmltYXRpb24gJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XHJcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2aW91c1RhYiA9IHRoaXMuX2dldEFjdGl2ZVRhYkVsZW1lbnQoKSxcclxuICAgICAgc2VsZWN0ZWRUYWIgPSB0aGlzLl9nZXRUYWJFbGVtZW50KGluZGV4KSxcclxuICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSxcclxuICAgICAgc2VsZWN0ZWRUYWJJbmRleCA9IGluZGV4LFxyXG4gICAgICBwcmV2aW91c1BhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XHJcblxyXG4gICAgaWYgKCFzZWxlY3RlZFRhYikge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwZWNpZmllZCBpbmRleCBkb2VzIG5vdCBtYXRjaCBhbnkgdGFiLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWxlY3RlZFRhYkluZGV4ID09PSBwcmV2aW91c1RhYkluZGV4KSB7XHJcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVhY3RpdmUnLCB7XHJcbiAgICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXHJcbiAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByZXZpb3VzUGFnZUVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xyXG5cclxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlY2hhbmdlJywge1xyXG4gICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcclxuICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWIsXHJcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoY2FuY2VsZWQpIHtcclxuICAgICAgc2VsZWN0ZWRUYWIuc2V0SW5hY3RpdmUoKTtcclxuICAgICAgaWYgKHByZXZpb3VzVGFiKSB7XHJcbiAgICAgICAgcHJldmlvdXNUYWIuc2V0QWN0aXZlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVjaGFuZ2UgZXZlbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0ZWRUYWIuc2V0QWN0aXZlKCk7XHJcblxyXG4gICAgdmFyIG5lZWRMb2FkID0gIXNlbGVjdGVkVGFiLmlzTG9hZGVkKCkgJiYgIW9wdGlvbnMua2VlcFBhZ2U7XHJcblxyXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuKS5mb3JFYWNoKCh0YWIpID0+IHtcclxuICAgICAgaWYgKHRhYiAhPSBzZWxlY3RlZFRhYikge1xyXG4gICAgICAgIHRhYi5zZXRJbmFjdGl2ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghbmVlZExvYWQpIHtcclxuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcclxuICAgICAgICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXHJcbiAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChuZWVkTG9hZCkge1xyXG4gICAgICB2YXIgcmVtb3ZlRWxlbWVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKCghcHJldmlvdXNUYWIgJiYgcHJldmlvdXNQYWdlRWxlbWVudCkgfHwgKHByZXZpb3VzVGFiICYmIHByZXZpb3VzVGFiLl9wYWdlRWxlbWVudCAhPT0gcHJldmlvdXNQYWdlRWxlbWVudCkpIHtcclxuICAgICAgICByZW1vdmVFbGVtZW50ID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xyXG4gICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcclxuICAgICAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJldmlvdXNUYWJJbmRleDogcHJldmlvdXNUYWJJbmRleCxcclxuICAgICAgICBzZWxlY3RlZFRhYkluZGV4OiBzZWxlY3RlZFRhYkluZGV4XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcclxuICAgICAgICBwYXJhbXMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhcmFtcy5hbmltYXRpb25PcHRpb25zID0gb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9O1xyXG5cclxuXHJcbiAgICAgIGNvbnN0IGxpbmsgPSAoZWxlbWVudCwgY2FsbGJhY2spID0+IHtcclxuICAgICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICBzZWxlY3RlZFRhYi5fbG9hZFBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50ID0+IHtcclxuICAgICAgICAgIHJlc29sdmUodGhpcy5fbG9hZFBlcnNpc3RlbnRQYWdlRE9NKHBhZ2VFbGVtZW50LCBwYXJhbXMpKTtcclxuICAgICAgICB9LCBsaW5rKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmV2aW91c1BhZ2VFbGVtZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgX2xvYWRQZXJzaXN0ZW50UGFnZURPTShlbGVtZW50LCBvcHRpb25zID0ge30pIHtcclxuXHJcbiAgICBpZiAoIXV0aWwuaXNBdHRhY2hlZChlbGVtZW50KSkge1xyXG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgIHJldHVybiB0aGlzLl9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzZXRUYWJiYXJWaXNpYmlsaXR5XHJcbiAgICogQHNpZ25hdHVyZSBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVXNlZCB0byBoaWRlIG9yIHNob3cgdGhlIHRhYiBiYXIuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG4gIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSkge1xyXG4gICAgdGhpcy5fY29udGVudEVsZW1lbnQuc3R5bGVbdGhpcy5fdG9wID8gJ3RvcCcgOiAnYm90dG9tJ10gPSB2aXNpYmxlID8gJycgOiAnMHB4JztcclxuICAgIHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVUYWJJbmRleFxyXG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlVGFiSW5kZXgoKVxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKiAgIFtlbl1UaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1SZXR1cm5zIHRhYiBpbmRleCBvbiBjdXJyZW50IGFjdGl2ZSB0YWIuIElmIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlsvZW5dXHJcbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CC54++5Zyo44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM44Gq44GE5aC05ZCI44Gr44GvLTHjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxyXG4gICAqL1xyXG4gIGdldEFjdGl2ZVRhYkluZGV4KCkge1xyXG4gICAgdmFyIHRhYnMgPSB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW47XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0YWJzW2ldIGluc3RhbmNlb2Ygd2luZG93Lk9uc1RhYkVsZW1lbnQgJiYgdGFic1tpXS5pc0FjdGl2ZSAmJiB0YWJzW2ldLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gV2hlbiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5cclxuICAgKi9cclxuICBfZ2V0QWN0aXZlVGFiRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRUYWJFbGVtZW50KHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9nZXRUYWJFbGVtZW50KGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuW2luZGV4XTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7IH1cclxuXHJcbiAgYXR0YWNoZWRDYWxsYmFjaygpIHsgfVxyXG5cclxuICBfc2hvdygpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xyXG4gICAgaWYgKGN1cnJlbnRQYWdlRWxlbWVudCkge1xyXG4gICAgICBjdXJyZW50UGFnZUVsZW1lbnQuX3Nob3coKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oaWRlKCkge1xyXG4gICAgY29uc3QgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XHJcbiAgICBpZiAoY3VycmVudFBhZ2VFbGVtZW50KSB7XHJcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5faGlkZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2Rlc3Ryb3koKSB7XHJcbiAgICBjb25zdCBwYWdlcyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHBhZ2VzW2ldLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XHJcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNUYWJiYXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiYmFyJywge1xyXG4gIHByb3RvdHlwZTogVGFiYmFyRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcclxuICovXHJcbndpbmRvdy5PbnNUYWJiYXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xyXG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFRhYmJhckFuaW1hdG9yKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc1RhYmJhckVsZW1lbnQuVGFiYmFyQW5pbWF0b3InKTtcclxuICB9XHJcbiAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xyXG59O1xyXG5cclxud2luZG93Lk9uc1RhYmJhckVsZW1lbnQucmV3cml0YWJsZXMgPSByZXdyaXRhYmxlcztcclxud2luZG93Lk9uc1RhYmJhckVsZW1lbnQuVGFiYmFyQW5pbWF0b3IgPSBUYWJiYXJBbmltYXRvcjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE9uc1RhYmJhckVsZW1lbnQ7XHJcbiIsIi8qXHJcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xyXG5pbXBvcnQgT25zVGFiYmFyRWxlbWVudCBmcm9tICcuL29ucy10YWJiYXInO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnJzogJ3RhYi1iYXItLSpfX2l0ZW0nLFxyXG4gICcudGFiLWJhcl9fYnV0dG9uJzogJ3RhYi1iYXItLSpfX2J1dHRvbidcclxufTtcclxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxyXG4gIDxkaXY+XHJcbiAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XHJcbiAgICA8YnV0dG9uIGNsYXNzPVwidGFiLWJhcl9fYnV0dG9uIHRhYi1iYXItaW5uZXJcIj48L2J1dHRvbj5cclxuICA8L2Rpdj5cclxuYCk7XHJcbmNvbnN0IGRlZmF1bHRJbm5lclRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcclxuICA8ZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2ljb25cIj5cclxuICAgICAgPG9ucy1pY29uIGljb249XCJpb24tY2xvdWRcIj48L29ucy1pY29uPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwidGFiLWJhcl9fbGFiZWxcIj5sYWJlbDwvZGl2PlxyXG4gIDwvZGl2PlxyXG5gKTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtdGFiXHJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVJlcHJlc2VudHMgYSB0YWIgaW5zaWRlIHRhYiBiYXIuIEVhY2ggYDxvbnMtdGFiPmAgcmVwcmVzZW50cyBhIHBhZ2UuWy9lbl1cclxuICogICBbamFdXHJcbiAqICAgICDjgr/jg5bjg5Djg7zjgavphY3nva7jgZXjgozjgovlkITjgqLjgqTjg4bjg6Djga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZ3jgozjgZ7jgozjga5vbnMtdGFi44Gv44Oa44O844K444KS6KGo44GX44G+44GZ44CCXHJcbiAqICAgICBvbnMtdGFi6KaB57Sg44Gu5Lit44Gr44Gv44CB44K/44OW44Gr6KGo56S644GV44KM44KL44Kz44Oz44OG44Oz44OE44KS55u05o6l6KiY6L+w44GZ44KL44GT44Go44GM5Ye65p2l44G+44GZ44CCXHJcbiAqICAgWy9qYV1cclxuICogQGNvZGVwZW4gcEd1RExcclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxyXG4gKiBAZ3VpZGUgVXNpbmdUYWJCYXJcclxuICogICBbZW5dVXNpbmcgdGFiIGJhclsvZW5dXHJcbiAqICAgW2phXeOCv+ODluODkOODvOOCkuS9v+OBhlsvamFdXHJcbiAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcclxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxyXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXHJcbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcclxuICogICBbZW5db25zLXRhYmJhciBjb21wb25lbnRbL2VuXVxyXG4gKiAgIFtqYV1vbnMtdGFiYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQHNlZWFsc28gb25zLXBhZ2VcclxuICogICBbZW5db25zLXBhZ2UgY29tcG9uZW50Wy9lbl1cclxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxyXG4gKiAgIFtlbl1vbnMtaWNvbiBjb21wb25lbnRbL2VuXVxyXG4gKiAgIFtqYV1vbnMtaWNvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtdGFiYmFyPlxyXG4gKiAgIDxvbnMtdGFiXHJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcclxuICogICAgIGxhYmVsPVwiSG9tZVwiXHJcbiAqICAgICBhY3RpdmU+XHJcbiAqICAgPC9vbnMtdGFiPlxyXG4gKiAgIDxvbnMtdGFiXHJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXHJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcclxuICogICAgIGFjdGl2ZT5cclxuICogICA8L29ucy10YWI+XHJcbiAqIDwvb25zLXRhYmJhcj5cclxuICpcclxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxyXG4gKiAgIC4uLlxyXG4gKiA8L29ucy10ZW1wbGF0ZT5cclxuICpcclxuICogPG9ucy10ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cclxuICogICAuLi5cclxuICogPC9vbnMtdGVtcGxhdGU+XHJcblxyXG4gKi9cclxuY2xhc3MgVGFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBwYWdlXHJcbiAgICogQGluaXRvbmx5XHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgcGFnZSB0aGF0IGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWIgaXMgdGFwcGVkLlsvZW5dXHJcbiAgICogICBbamFdb25zLXRhYuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dXHJcbiAgICogICAgIFRoZSBpY29uIG5hbWUgZm9yIHRoZSB0YWIuIENhbiBzcGVjaWZ5IHRoZSBzYW1lIGljb24gbmFtZSBhcyBgPG9ucy1pY29uPmAuXHJcbiAgICogICAgIElmIHlvdSBuZWVkIHRvIHVzZSB5b3VyIG93biBpY29uLCBjcmVhdGUgYSBDU1MgY2xhc3Mgd2l0aCBgYmFja2dyb3VuZC1pbWFnZWAgb3IgYW55IENTUyBwcm9wZXJ0aWVzIGFuZCBzcGVjaWZ5IHRoZSBuYW1lIG9mIHlvdXIgQ1NTIGNsYXNzIGhlcmUuXHJcbiAgICogICBbL2VuXVxyXG4gICAqICAgW2phXVxyXG4gICAqICAgICDjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJvbnMtaWNvbuOBqOWQjOOBmOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxyXG4gICAqICAgICDlgIvliKXjgavjgqLjgqTjgrPjg7PjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovloLTlkIjjga/jgIFiYWNrZ3JvdW5kLWltYWdl44Gq44Gp44GuQ1NT44K544K/44Kk44Or44KS55So44GE44Gm5oyH5a6a44Gn44GN44G+44GZ44CCXHJcbiAgICogICBbL2phXVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZS1pY29uXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgbmFtZSBvZiB0aGUgaWNvbiB3aGVuIHRoZSB0YWIgaXMgYWN0aXZlLlsvZW5dXHJcbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gu6Zqb44Gu44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBsYWJlbFxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhlIGxhYmVsIG9mIHRoZSB0YWIgaXRlbS5bL2VuXVxyXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+S4i+OBq+ihqOekuuOBleOCjOOCi+ODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dVGhpcyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldCB0byB0aGUgdGFiIHRoYXQgaXMgYWN0aXZlIGJ5IGRlZmF1bHQuWy9lbl1cclxuICAgKiAgIFtqYV1bL2phXVxyXG4gICAqL1xyXG5cclxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xhYmVsJykgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSkge1xyXG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xyXG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xyXG4gICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgX2NvbXBpbGUoKSB7XHJcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcclxuXHJcbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgIGxldCBoYXNDaGlsZHJlbiA9IGZhbHNlO1xyXG5cclxuICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcclxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcclxuICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XHJcblxyXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgd2hpbGUgKHRlbXBsYXRlLmNoaWxkcmVuWzBdKSB7XHJcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd0YWItYmFyX19pdGVtJyk7XHJcblxyXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcclxuXHJcbiAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcclxuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICAgICAgdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLl91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcclxuXHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVJpcHBsZSgpIHtcclxuICAgIC8vIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2J1dHRvbicpLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcclxuXHJcbiAgICBpZiAoYnV0dG9uLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gZGVmYXVsdElubmVyVGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcclxuICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpKSB7XHJcbiAgICAgICAgYnV0dG9uLmluc2VydEJlZm9yZSh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpLCBidXR0b24uZmlyc3RDaGlsZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19sYWJlbCcpKSB7XHJcbiAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19sYWJlbCcpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgaWNvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJyk7XHJcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsYWJlbCcpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgZ2V0SWNvbkVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2ljb24nLCBpY29uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKTtcclxuICAgICAgaWYgKHdyYXBwZXIpIHtcclxuICAgICAgICB3cmFwcGVyLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgZ2V0TGFiZWxFbGVtZW50KCkudGV4dENvbnRlbnQgPSBsYWJlbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWxFbGVtZW50KCk7XHJcbiAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgIGxhYmVsLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxFbGVtZW50KCkge1xyXG4gICAgICByZXR1cm4gc2VsZi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJY29uRWxlbWVudCgpIHtcclxuICAgICAgcmV0dXJuIHNlbGYucXVlcnlTZWxlY3Rvcignb25zLWljb24nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vbkNsaWNrKCkge1xyXG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcclxuICAgIGlmICh0YWJiYXIpIHtcclxuICAgICAgdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLl9maW5kVGFiSW5kZXgoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRBY3RpdmUoKSB7XHJcbiAgICBjb25zdCByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xyXG4gICAgcmFkaW8uY2hlY2tlZCA9IHRydWU7XHJcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG5cclxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItaW5hY3RpdmVdLCBvbnMtdGFiLWluYWN0aXZlJykpXHJcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcclxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSlcclxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCcpO1xyXG4gIH1cclxuXHJcbiAgc2V0SW5hY3RpdmUoKSB7XHJcbiAgICBjb25zdCByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xyXG4gICAgcmFkaW8uY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHJcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKVxyXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0Jyk7XHJcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWFjdGl2ZV0sIG9ucy10YWItYWN0aXZlJykpXHJcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaXNMb2FkZWQoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtcclxuICAgKi9cclxuICBfbG9hZFBhZ2VFbGVtZW50KGNhbGxiYWNrLCBsaW5rKSB7XHJcbiAgICBpZiAoIXRoaXMucGFnZUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5fY3JlYXRlUGFnZUVsZW1lbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSwgKGVsZW1lbnQpID0+IHtcclxuICAgICAgICBsaW5rKGVsZW1lbnQsIGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wYWdlRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsYmFjayh0aGlzLnBhZ2VFbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBwYWdlRWxlbWVudChlbCkge1xyXG4gICAgdGhpcy5fcGFnZUVsZW1lbnQgPSBlbDtcclxuICB9XHJcblxyXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fcGFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9maW5kVGFiSW5kZXgoKTtcclxuXHJcbiAgICByZXR1cm4gdGFiYmFyLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbltpbmRleF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHBhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XHJcbiAgICAgIGNhbGxiYWNrKHV0aWwuY3JlYXRlRWxlbWVudChodG1sLnRyaW0oKSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzQWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKTtcclxuICB9XHJcblxyXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xyXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgdGhpcy5fZW5zdXJlRWxlbWVudFBvc2l0aW9uKCk7XHJcblxyXG4gICAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpO1xyXG5cclxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcclxuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpICsgJyAnIDogJyc7XHJcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgcHJlZml4ICsgdGFiYmFyLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnYWN0aXZlJykpIHtcclxuICAgICAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xyXG5cclxuICAgICAgICBPbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgKCkgPT4ge1xyXG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRhYmJhci5zZXRBY3RpdmVUYWIodGFiSW5kZXgsIHthbmltYXRpb246ICdub25lJ30pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBPbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgKCkgPT4ge1xyXG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpLCBwYWdlRWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBPbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLmxpbmsodGFiYmFyLCBwYWdlRWxlbWVudCwge30sIHBhZ2VFbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlRWxlbWVudCA9IHBhZ2VFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgIHRhYmJhci5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5wYWdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRUYWJiYXJFbGVtZW50KCkge1xyXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBfZmluZFRhYkluZGV4KCkge1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzID09PSBlbGVtZW50c1tpXSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZW5zdXJlRWxlbWVudFBvc2l0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBvbnMtdGFiIGVsZW1lbnQgaXMgbXVzdCBiZSBjaGlsZCBvZiBvbnMtdGFiYmFyIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xyXG4gICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcclxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdyaXBwbGUnOlxyXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2ljb24nOlxyXG4gICAgICBjYXNlICdsYWJlbCc6XHJcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbndpbmRvdy5PbnNUYWJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiJywge1xyXG4gIHByb3RvdHlwZTogVGFiRWxlbWVudC5wcm90b3R5cGVcclxufSk7XHJcblxyXG5kb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy10YWJiYXItaXRlbScsIHtcclxuICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoVGFiRWxlbWVudC5wcm90b3R5cGUpXHJcbn0pO1xyXG4iLCIvKlxyXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xyXG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcclxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xyXG5cclxuY29uc3Qgc2NoZW1lID0geycnOiAndG9vbGJhci1idXR0b24tLSonfTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cclxuICogQGNhdGVnb3J5IHRvb2xiYXJcclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXHJcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxyXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cclxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS44KC44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cclxuICogICBbamFdb25zLXRvb2xiYXLjgYLjgovjgYTjga9vbnMtYm90dG9tLXRvb2xiYXLjgavoqK3nva7jgafjgY3jgovjg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxyXG4gKiBAY29kZXBlbiBhSG1HTFxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXHJcbiAqIEBndWlkZSBBZGRpbmdhdG9vbGJhclxyXG4gKiAgIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1cclxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cclxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcclxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBuYXZpZ2F0aW9uIGJhciBhdCB0aGUgdG9wIG9mIGEgcGFnZS5bL2VuXVxyXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYmFjay1idXR0b24+YCBkaXNwbGF5cyBhIGJhY2sgYnV0dG9uIGluIHRoZSBuYXZpZ2F0aW9uIGJhci5bL2VuXVxyXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8b25zLXRvb2xiYXI+XHJcbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cclxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XHJcbiAqICAgICAgIEJ1dHRvblxyXG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XHJcbiAqICAgPC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxyXG4gKiAgICAgVGl0bGVcclxuICogICA8L2Rpdj5cclxuICogICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cclxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XHJcbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XHJcbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cclxuICogICA8L2Rpdj5cclxuICogPC9vbnMtdG9vbGJhcj5cclxuICovXHJcbmNsYXNzIFRvb2xiYXJCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXHJcbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxyXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXHJcbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cclxuICAgKi9cclxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcclxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBnZXQgZGlzYWJsZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndG9vbGJhci1idXR0b24nKTtcclxuXHJcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XHJcblxyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcclxuICB9XHJcblxyXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xyXG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zVG9vbGJhckJ1dHRvbiA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRvb2xiYXItYnV0dG9uJywge1xyXG4gIHByb3RvdHlwZTogVG9vbGJhckJ1dHRvbkVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcclxuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XHJcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XHJcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xyXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XHJcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xyXG5cclxuY29uc3Qgc2NoZW1lID0ge1xyXG4gICcnOiAnbmF2aWdhdGlvbi1iYXItLSonLFxyXG4gICcubmF2aWdhdGlvbi1iYXJfX2xlZnQnOiAnbmF2aWdhdGlvbi1iYXItLSpfX2xlZnQnLFxyXG4gICcubmF2aWdhdGlvbi1iYXJfX2NlbnRlcic6ICduYXZpZ2F0aW9uLWJhci0tKl9fY2VudGVyJyxcclxuICAnLm5hdmlnYXRpb24tYmFyX19yaWdodCc6ICduYXZpZ2F0aW9uLWJhci0tKl9fcmlnaHQnXHJcbn07XHJcblxyXG4vKipcclxuICogQGVsZW1lbnQgb25zLXRvb2xiYXJcclxuICogQGNhdGVnb3J5IHRvb2xiYXJcclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXHJcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxyXG4gKiAgIFtlbl1UcmFuc3BhcmVudCB0b29sYmFyWy9lbl1cclxuICogICBbamFd6YCP5piO44Gq6IOM5pmv44KS5oyB44Gk44OE44O844Or44OQ44O844KS6KGo56S644GX44G+44GZ44CCWy9qYV1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgVG9vbGJhciBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIG5hdmlnYXRpb24uXHJcbiAqXHJcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlxyXG4gKlxyXG4gKiAgICAgVGhpcyBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgd2hlbiBydW5uaW5nIG9uIEFuZHJvaWQgZGV2aWNlcy5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV3jg4rjg5PjgrLjg7zjgrfjg6fjg7Pjgafkvb/nlKjjgZnjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgq/jg6njgrnlkI3jgavjgojjgorjgIHlt6bjgIHkuK3lpK7jgIHlj7Pjga7jgrPjg7Pjg4bjg4rjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxyXG4gKiBAY29kZXBlbiBhSG1HTFxyXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXHJcbiAqIEBndWlkZSBBZGRpbmdhdG9vbGJhciBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1ib3R0b20tdG9vbGJhclxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYm90dG9tLXRvb2xiYXI+YCBkaXNwbGF5cyBhIHRvb2xiYXIgb24gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxyXG4gKiAgIFtqYV1vbnMtYm90dG9tLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxyXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cclxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXHJcbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyLWJ1dHRvblxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhci1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSB0b29sYmFyIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cclxuICogICBbamFdb25zLXRvb2xiYXItYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cclxuICogQGV4YW1wbGVcclxuICogPG9ucy1wYWdlPlxyXG4gKiAgIDxvbnMtdG9vbGJhcj5cclxuICogICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XHJcbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+XHJcbiAqICAgICAgICAgQmFja1xyXG4gKiAgICAgICA8L29ucy1iYWNrLWJ1dHRvbj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxyXG4gKiAgICAgICBUaXRsZVxyXG4gKiAgICAgPC9kaXY+XHJcbiAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cclxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cclxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxyXG4gKiAgICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIDwvb25zLXRvb2xiYXI+XHJcbiAqIDwvb25zLXBhZ2U+XHJcbiAqL1xyXG5cclxuY2xhc3MgVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgaW5saW5lXHJcbiAgICogQGluaXRvbmx5XHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogICBbZW5dRGlzcGxheSB0aGUgdG9vbGJhciBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxyXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOCkuOCpOODs+ODqeOCpOODs+OBq+e9ruOBjeOBvuOBmeOAguOCueOCr+ODreODvOODq+mgmOWfn+WGheOBq+OBneOBruOBvuOBvuihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxyXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcclxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpO1xyXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCkpO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XHJcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpO1xyXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCkpO1xyXG4gIH1cclxuXHJcbiAgX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XHJcblxyXG4gICAgaWYgKHBhZ2UgJiYgcGFnZSAhPT0gdGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHBhZ2UuX3JlZ2lzdGVyVG9vbGJhcih0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5sZWZ0JykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5jZW50ZXInKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbiAuYmFjay1idXR0b25fX2xhYmVsJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCduYXZpZ2F0aW9uLWJhcicpO1xyXG4gICAgdGhpcy5fZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpO1xyXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcclxuICB9XHJcblxyXG4gIF9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcclxuICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxyXG4gICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDEpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGROb2Rlc1tpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnY2VudGVyJyk7XHJcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfX3RpdGxlJyk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0aGlzLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcclxuICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdsZWZ0Jyk7XHJcbiAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ3JpZ2h0Jyk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jaGlsZHJlblswXSAhPT0gbGVmdCB8fCB0aGlzLmNoaWxkcmVuWzFdICE9PSBjZW50ZXIgfHwgdGhpcy5jaGlsZHJlblsyXSAhPT0gcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGxlZnQpO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcclxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHJpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2Vuc3VyZVRvb2xiYXJFbGVtZW50KG5hbWUpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLicgKyBuYW1lKSB8fCB1dGlsLmNyZWF0ZSgnLicgKyBuYW1lKTtcclxuXHJcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25hdmlnYXRpb24tYmFyX18nICsgbmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG53aW5kb3cuT25zVG9vbGJhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy10b29sYmFyJywge1xyXG4gIHByb3RvdHlwZTogVG9vbGJhckVsZW1lbnQucHJvdG90eXBlXHJcbn0pO1xyXG5cclxuIiwiLypcclxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xyXG5cclxuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcclxuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XHJcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcclxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xyXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcclxuXHJcbmNvbnN0IHNjaGVtZSA9IHtcclxuICAnLnJhbmdlJzogJ3JhbmdlLS0qJyxcclxuICAnLnJhbmdlX19sZWZ0JzogJ3JhbmdlLS0qX19sZWZ0J1xyXG59O1xyXG5cclxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYDxkaXY+XHJcbiAgPGRpdiBjbGFzcz1cInJhbmdlX19sZWZ0XCI+PC9kaXY+XHJcbiAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwicmFuZ2VcIj5cclxuPC9kaXY+YCk7XHJcblxyXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xyXG4gICdhdXRvZm9jdXMnLFxyXG4gICdkaXNhYmxlZCcsXHJcbiAgJ2lucHV0bW9kZScsXHJcbiAgJ21heCcsXHJcbiAgJ21pbicsXHJcbiAgJ25hbWUnLFxyXG4gICdwbGFjZWhvbGRlcicsXHJcbiAgJ3JlYWRvbmx5JyxcclxuICAnc2l6ZScsXHJcbiAgJ3N0ZXAnLFxyXG4gICd2YWxpZGF0b3InLFxyXG4gICd2YWx1ZSdcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBAZWxlbWVudCBvbnMtcmFuZ2VcclxuICogQGNhdGVnb3J5IHJhbmdlXHJcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxyXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc2xpZGVyWy9lbl1cclxuICogICBbamFdWy9qYV1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgW2VuXVxyXG4gKiAgICAgUmFuZ2UgaW5wdXQgY29tcG9uZW50LiBVc2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgc2xpZGVyLlxyXG4gKlxyXG4gKiAgICAgV29ya3MgdmVyeSBzaW1pbGFyIHRvIHRoZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cclxuICogICBbL2VuXVxyXG4gKiAgIFtqYV1bL2phXVxyXG4gKiBAY29kZXBlbiB4WlFvbU1cclxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JhbmdlXHJcbiAqIEBndWlkZSBVc2luZ0Zvcm1Db21wb25lbnRzXHJcbiAqICAgW2VuXVVzaW5nIGZvcm0gY29tcG9uZW50c1svZW5dXHJcbiAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXHJcbiAqIEBndWlkZSBFdmVudEhhbmRsaW5nXHJcbiAqICAgW2VuXUV2ZW50IGhhbmRsaW5nIGRlc2NyaXB0aW9uc1svZW5dXHJcbiAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXHJcbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxyXG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IHRleHQgaW5wdXRzLCByYWRpbyBidXR0b25zIGFuZCBjaGVja2JveGVzLlsvZW5dXHJcbiAqICAgW2phXVsvamFdXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxvbnMtcmFuZ2UgdmFsdWU9XCIyMFwiPjwvb25zLXJhbmdlPlxyXG4gKiA8b25zLXJhbmdlIG1vZGlmaWVyPVwibWF0ZXJpYWxcIiB2YWx1ZT1cIjEwXCI+PC9yYW5nZT5cclxuICovXHJcbmNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcclxuXHJcbiAgY3JlYXRlZENhbGxiYWNrKCkge1xyXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcclxuICAgICAgICB0aGlzLl9jb21waWxlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xyXG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfY29tcGlsZSgpIHtcclxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xyXG5cclxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcucmFuZ2VfX2xlZnQnKSAmJiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKSkpIHtcclxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xyXG5cclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XHJcbiAgfVxyXG5cclxuICBfb25DaGFuZ2UoKSB7XHJcbiAgICB0aGlzLl9sZWZ0LnN0eWxlLndpZHRoID0gKDEwMCAqIHRoaXMuX3JhdGlvKSArICclJztcclxuICB9XHJcblxyXG4gIGdldCBfcmF0aW8oKSB7XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxyXG4gICAgY29uc3QgbWluID0gdGhpcy5faW5wdXQubWluID09PSAnJyA/IDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5taW4pO1xyXG4gICAgY29uc3QgbWF4ID0gdGhpcy5faW5wdXQubWF4ID09PSAnJyA/IDEwMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1heCk7XHJcblxyXG4gICAgcmV0dXJuICh0aGlzLnZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xyXG4gIH1cclxuXHJcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcclxuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XHJcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcclxuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcclxuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdtaW4nIHx8IG5hbWUgPT09ICdtYXgnKSB7XHJcbiAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiB9XHJcblxyXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25DaGFuZ2UpO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xyXG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKChhdHRyKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xyXG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldCBfaW5wdXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF9sZWZ0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnJhbmdlX19sZWZ0Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxyXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXHJcbiAgICovXHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc2FibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3BlcnR5IHZhbHVlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXHJcbiAgICogICBbamFdWy9qYV1cclxuICAgKi9cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5wdXQudmFsdWU7XHJcbiAgfVxyXG5cclxuICBzZXQgdmFsdWUodmFsKSB7XHJcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcclxuICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxud2luZG93Lk9uc1JhbmdlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXJhbmdlJywge1xyXG4gIHByb3RvdHlwZTogUmFuZ2VFbGVtZW50LnByb3RvdHlwZVxyXG59KTtcclxuIiwiaW1wb3J0IG9ucyBmcm9tICcuL29ucy9vbnMnO1xyXG5cclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaWYnO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZyc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYmFjay1idXR0b24nO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1idXR0b24nO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jb2wnO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtZmFiJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pY29uJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1sYXp5LXJlcGVhdCc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXInO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QtaXRlbSc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdCc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaW5wdXQnO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLW1vZGFsJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXBhZ2UnO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXBvcG92ZXInO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXInO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXB1bGwtaG9vayc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmlwcGxlJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yb3cnO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbSc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbCc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItY29udGVudCc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzayc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZSc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXInO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXN3aXRjaCc7XHJcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10YWJiYXInO1xyXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyJztcclxuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yYW5nZSc7XHJcblxyXG4vLyBmYXN0Y2xpY2tcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICBvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcclxufSwgZmFsc2UpO1xyXG5cclxuLy8gb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5lbmFibGUoKTtcclxuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xyXG4gICAgbmF2aWdhdG9yLmFwcC5leGl0QXBwKCk7XHJcbiAgfSk7XHJcbiAgZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSk7XHJcbn0sIGZhbHNlKTtcclxuXHJcbi8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcclxub25zLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gIG9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzKCk7XHJcbn0pO1xyXG5cclxuLy8gdmlld3BvcnQuanNcclxubmV3IFZpZXdwb3J0KCkuc2V0dXAoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG9ucztcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
